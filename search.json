[{"title":"Mysql进阶篇","date":"2023-03-02T08:24:15.000Z","url":"/post/Mysql%E8%BF%9B%E9%98%B6%E7%AF%87.html","categories":[["undefined",""]],"content":"进阶篇存储引擎MySQL体系结构： 存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎。默认存储引擎是InnoDB。 相关操作： InnoDBInnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎。 特点： DML 操作遵循 ACID 模型，支持事务 行级锁，提高并发访问性能 支持外键约束，保证数据的完整性和正确性 文件： xxx.ibd: xxx代表表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。 参数：innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间 知识点： 查看 Mysql 变量：show variables like &#39;innodb_file_per_table&#39;; 从idb文件提取表结构数据：（在cmd运行）ibd2sdi xxx.ibd InnoDB 逻辑存储结构： MyISAMMyISAM 是 MySQL 早期的默认存储引擎。 特点： 不支持事务，不支持外键 支持表锁，不支持行锁 访问速度快 文件： xxx.sdi: 存储表结构信息 xxx.MYD: 存储数据 xxx.MYI: 存储索引 MemoryMemory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。 特点： 存放在内存中，速度快 hash索引（默认） 文件： xxx.sdi: 存储表结构信息 存储引擎特点 特点 InnoDB MyISAM Memory 存储限制 64TB 有 有 事务安全 支持 - - 锁机制 行锁 表锁 表锁 B+tree索引 支持 支持 支持 Hash索引 - - 支持 全文索引 支持（5.6版本之后） 支持 - 空间使用 高 低 N&#x2F;A 内存使用 高 低 中等 批量插入速度 低 高 高 支持外键 支持 - - 存储引擎的选择在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。 InnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择 MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。 Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性 电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。 性能分析查看执行频次查看当前数据库的 INSERT, UPDATE, DELETE, SELECT 访问频次：SHOW GLOBAL STATUS LIKE &#39;Com_______&#39;; 或者 SHOW SESSION STATUS LIKE &#39;Com_______&#39;;例：show global status like &#39;Com_______&#39; 慢查询日志慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息： # 开启慢查询日志开关 slow_query_log&#x3D;1 # 设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志 long_query_time&#x3D;2更改后记得重启MySQL服务，日志文件位置：&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;localhost-slow.log 查看慢查询日志开关状态：show variables like &#39;slow_query_log&#39;; profileshow profile 能在做SQL优化时帮我们了解时间都耗费在哪里。通过 have_profiling 参数，能看到当前 MySQL 是否支持 profile 操作：SELECT @@have_profiling;profiling 默认关闭，可以通过set语句在session&#x2F;global级别开启 profiling：SET profiling = 1;查看所有语句的耗时：show profiles;查看指定query_id的SQL语句各个阶段的耗时：show profile for query query_id;查看指定query_id的SQL语句CPU的使用情况show profile cpu for query query_id; explainEXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。语法： # 直接在select语句之前加上关键字 explain &#x2F; desc EXPLAIN SELECT 字段列表 FROM 表名 HWERE 条件; EXPLAIN 各字段含义： id：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行） select_type：表示 SELECT 的类型，常见取值有 SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT&#x2F;WHERE之后包含了子查询）等 type：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all possible_key：可能应用在这张表上的索引，一个或多个 Key：实际使用的索引，如果为 NULL，则没有使用索引 Key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好 rows：MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的 filtered：表示返回结果的行数占需读取行数的百分比，filtered的值越大越好 索引索引是帮助 MySQL 高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。 优缺点： 优点： 提高数据检索效率，降低数据库的IO成本 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗 缺点： 索引列也是要占用空间的 索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE 索引结构 索引结构 描述 B+Tree 最常见的索引类型，大部分引擎都支持B+树索引 Hash 底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询 R-Tree(空间索引) 空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 Full-Text(全文索引) 是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES 索引 InnoDB MyISAM Memory B+Tree索引 支持 支持 支持 Hash索引 不支持 不支持 支持 R-Tree索引 不支持 支持 不支持 Full-text 5.6版本后支持 支持 不支持 B-Tree 二叉树的缺点可以用红黑树来解决： 红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。 为了解决上述问题，可以使用 B-Tree 结构。B-Tree (多路平衡查找树) 以一棵最大度数（max-degree，指一个节点的子节点个数）为5（5阶）的 b-tree 为例（每个节点最多存储4个key，5个指针） B-Tree 的数据插入过程动画参照：演示地址： B+Tree结构图： 演示地址： 与 B-Tree 的区别： 所有的数据都会出现在叶子节点 叶子节点形成一个单向链表 MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。 Hash哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。 特点： Hash索引只能用于对等比较（&#x3D;、in），不支持范围查询（betwwn、&gt;、&lt;、…） 无法利用索引完成排序操作 查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引 存储引擎支持： Memory InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的 面试题 为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？ 相对于二叉树，层级更少，搜索效率高 对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低 相对于 Hash 索引，B+Tree 支持范围匹配及排序操作 索引分类 分类 含义 特点 关键字 主键索引 针对于表中主键创建的索引 默认自动创建，只能有一个 PRIMARY 唯一索引 避免同一个表中某数据列中的值重复 可以有多个 UNIQUE 常规索引 快速定位特定数据 可以有多个 全文索引 全文索引查找的是文本中的关键词，而不是比较索引中的值 可以有多个 FULLTEXT 在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种： 分类 含义 特点 聚集索引(Clustered Index) 将数据存储与索引放一块，索引结构的叶子节点保存了行数据 必须有，而且只有一个 二级索引(Secondary Index) 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 可以存在多个 演示图： 聚集索引选取规则： 如果存在主键，主键索引就是聚集索引 如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引 如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引 思考题1. 以下 SQL 语句，哪个执行效率高？为什么？ 答：第一条语句，因为第二条需要回表查询，相当于两个步骤。 2. InnoDB 主键索引的 B+Tree 高度为多少？ 答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8.可得公式：n * 8 + (n + 1) * 6 = 16 * 1024，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。 如果树的高度为2，那么他能存储的数据量大概为：1171 * 16 = 18736；如果树的高度为3，那么他能存储的数据量大概为：1171 * 1171 * 16 = 21939856。 另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。 语法创建索引：CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name, ...);如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引 查看索引：SHOW INDEX FROM table_name; 删除索引：DROP INDEX index_name ON table_name; 案例： 使用规则最左前缀法则如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将部分失效（后面的字段索引失效）。 联合索引中，出现范围查询（&lt;, &gt;），范围查询右侧的列索引失效。可以用&gt;&#x3D;或者&lt;&#x3D;来规避索引失效问题。 索引失效情况 在索引列上进行运算操作，索引将失效。如：explain select * from tb_user where substring(phone, 10, 2) = &#39;15&#39;; 字符串类型字段使用时，不加引号，索引将失效。如：explain select * from tb_user where phone = 17799990015;，此处phone的值没有加引号 模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：explain select * from tb_user where profession like &#39;%工程&#39;;，前后都有 % 也会失效。 用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。 如果 MySQL 评估使用索引比全表更慢，则不使用索引。 SQL 提示是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。 例如，使用索引：explain select * from tb_user use index(idx_user_pro) where profession=&quot;软件工程&quot;;不使用哪个索引：explain select * from tb_user ignore index(idx_user_pro) where profession=&quot;软件工程&quot;;必须使用哪个索引：explain select * from tb_user force index(idx_user_pro) where profession=&quot;软件工程&quot;; use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。 覆盖索引&amp;回表查询尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *。 explain 中 extra 字段含义：using index condition：查找使用了索引，但是需要回表查询数据using where; using index;：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询 如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *；如果在辅助索引中找聚集索引，如select id, name from xxx where name=&#39;xxx&#39;;，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；如果是通过辅助索引查找其他字段，则需要回表查询，如select id, name, gender from xxx where name=&#39;xxx&#39;; 所以尽量不要用select *，容易出现回表查询，降低效率，除非有联合索引包含了所有字段 面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案：select id, username, password from tb_user where username=&#39;itcast&#39;; 解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引 前缀索引当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。 语法：create index idx_xxxx on table_name(columnn(n));前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。求选择性公式： show index 里面的sub_part可以看到接取的长度 单列索引&amp;联合索引单列索引：即一个索引只包含单个列联合索引：即一个索引包含了多个列在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。 单列索引情况：explain select id, phone, name from tb_user where phone = &#39;17799990010&#39; and name = &#39;韩信&#39;;这句只会用到phone索引字段 注意事项 多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询 设计原则 针对于数据量较大，且查询比较频繁的表建立索引 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高 如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询 SQL 优化插入数据普通插入： 采用批量插入（一次插入的数据不建议超过1000条） 手动提交事务 主键顺序插入 大批量插入：如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令插入。 主键优化数据组织方式：在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（Index organized table, IOT） 页分裂：页可以为空，也可以填充一般，也可以填充100%，每个页包含了2-N行数据（如果一行数据过大，会行溢出），根据主键排列。页合并：当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录到达 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前后）看看是否可以将这两个页合并以优化空间使用。 MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或创建索引时指定 文字说明不够清晰明了，具体可以看视频里的PPT演示过程： 主键设计原则： 满足业务需求的情况下，尽量降低主键的长度 插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键 尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号 业务操作时，避免对主键的修改 order by优化 Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序 Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高 如果order by字段全部使用升序排序或者降序排序，则都会走索引，但是如果一个字段升序排序，另一个字段降序排序，则不会走索引，explain的extra信息显示的是Using index, Using filesort，如果要优化掉Using filesort，则需要另外再创建一个索引，如：create index idx_user_age_phone_ad on tb_user(age asc, phone desc);，此时使用select id, age, phone from tb_user order by age asc, phone desc;会全部走索引 总结： 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则 尽量使用覆盖索引 多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC&#x2F;DESC） 如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k） group by优化 在分组操作时，可以通过索引来提高效率 分组操作时，索引的使用也是满足最左前缀法则的 如索引为idx_user_pro_age_stat，则句式可以是select ... where profession order by age，这样也符合最左前缀法则 limit优化常见的问题如limit 2000000, 10，此时需要 MySQL 排序前2000000条记录，但仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。优化方案：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化 例如： count优化MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高（前提是不适用where）；InnoDB 在执行 count(*) 时，需要把数据一行一行地从引擎里面读出来，然后累计计数。优化方案：自己计数，如创建key-value表存储在内存或硬盘，或者是用redis count的几种用法： 如果count函数的参数（count里面写的那个字段）不是NULL（字段值不为NULL），累计值就加一，最后返回累计值 用法：count(*)、count(主键)、count(字段)、count(1) count(主键)跟count(*)一样，因为主键不能为空；count(字段)只计算字段值不为NULL的行；count(1)引擎会为每行添加一个1，然后就count这个1，返回结果也跟count(*)一样；count(null)返回0 各种用法的性能： count(主键)：InnoDB引擎会遍历整张表，把每行的主键id值都取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键不可能为空） count(字段)：没有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加；有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加 count(1)：InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一层，放一个数字 1 进去，直接按行进行累加 count(*)：InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加 按效率排序：count(字段) &lt; count(主键) &lt; count(1) &lt; count(*)，所以尽量使用 count(*) update优化（避免行锁升级为表锁）InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。 如以下两条语句：update student set no = &#39;123&#39; where id = 1;，这句由于id有主键索引，所以只会锁这一行；update student set no = &#39;123&#39; where name = &#39;test&#39;;，这句由于name没有索引，所以会把整张表都锁住进行数据更新，解决方法是给name字段添加索引 数据类型整型 类型名称 取值范围 大小 TINYINT -128〜127 1个字节 SMALLINT -32768〜32767 2个宇节 MEDIUMINT -8388608〜8388607 3个字节 INT (INTEGHR) -2147483648〜2147483647 4个字节 BIGINT -9223372036854775808〜9223372036854775807 8个字节 无符号在数据类型后加 unsigned 关键字。 浮点型 类型名称 说明 存储需求 FLOAT 单精度浮点数 4 个字节 DOUBLE 双精度浮点数 8 个字节 DECIMAL (M, D)，DEC 压缩的“严格”定点数 M+2 个字节 日期和时间 类型名称 日期格式 日期范围 存储需求 YEAR YYYY 1901 ~ 2155 1 个字节 TIME HH:MM:SS -838:59:59 ~ 838:59:59 3 个字节 DATE YYYY-MM-DD 1000-01-01 ~ 9999-12-3 3 个字节 DATETIME YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59 8 个字节 TIMESTAMP YYYY-MM-DD HH:MM:SS 1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC 4 个字节 字符串 类型名称 说明 存储需求 CHAR(M) 固定长度非二进制字符串 M 字节，1&lt;&#x3D;M&lt;&#x3D;255 VARCHAR(M) 变长非二进制字符串 L+1字节，在此，L&lt; &#x3D; M和 1&lt;&#x3D;M&lt;&#x3D;255 TINYTEXT 非常小的非二进制字符串 L+1字节，在此，L&lt;2^8 TEXT 小的非二进制字符串 L+2字节，在此，L&lt;2^16 MEDIUMTEXT 中等大小的非二进制字符串 L+3字节，在此，L&lt;2^24 LONGTEXT 大的非二进制字符串 L+4字节，在此，L&lt;2^32 ENUM 枚举类型，只能有一个枚举字符串值 1或2个字节，取决于枚举值的数目 (最大值为65535) SET 一个设置，字符串对象可以有零个或 多个SET成员 1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员） 二进制类型 类型名称 说明 存储需求 BIT(M) 位字段类型 大约 (M+7)&#x2F;8 字节 BINARY(M) 固定长度二进制字符串 M 字节 VARBINARY (M) 可变长度二进制字符串 M+1 字节 TINYBLOB (M) 非常小的BLOB L+1 字节，在此，L&lt;2^8 BLOB (M) 小 BLOB L+2 字节，在此，L&lt;2^16 MEDIUMBLOB (M) 中等大小的BLOB L+3 字节，在此，L&lt;2^24 LONGBLOB (M) 非常大的BLOB L+4 字节，在此，L&lt;2^32 权限一览表 具体权限的作用详见官方文档 GRANT 和 REVOKE 允许的静态权限 Privilege Grant Table Column Context ALL [PRIVILEGES] Synonym for “all privileges” Server administration ALTER Alter_priv Tables ALTER ROUTINE Alter_routine_priv Stored routines CREATE Create_priv Databases, tables, or indexes CREATE ROLE Create_role_priv Server administration CREATE ROUTINE Create_routine_priv Stored routines CREATE TABLESPACE Create_tablespace_priv Server administration CREATE TEMPORARY TABLES Create_tmp_table_priv Tables CREATE USER Create_user_priv Server administration CREATE VIEW Create_view_priv Views DELETE Delete_priv Tables DROP Drop_priv Databases, tables, or views DROP ROLE Drop_role_priv Server administration EVENT Event_priv Databases EXECUTE Execute_priv Stored routines FILE File_priv File access on server host GRANT OPTION Grant_priv Databases, tables, or stored routines INDEX Index_priv Tables INSERT Insert_priv Tables or columns LOCK TABLES Lock_tables_priv Databases PROCESS Process_priv Server administration PROXY See proxies_priv table Server administration REFERENCES References_priv Databases or tables RELOAD Reload_priv Server administration REPLICATION CLIENT Repl_client_priv Server administration REPLICATION SLAVE Repl_slave_priv Server administration SELECT Select_priv Tables or columns SHOW DATABASES Show_db_priv Server administration SHOW VIEW Show_view_priv Views SHUTDOWN Shutdown_priv Server administration SUPER Super_priv Server administration TRIGGER Trigger_priv Tables UPDATE Update_priv Tables or columns USAGE Synonym for “no privileges” Server administration GRANT 和 REVOKE 允许的动态权限 Privilege Context APPLICATION_PASSWORD_ADMIN Dual password administration AUDIT_ABORT_EXEMPT Allow queries blocked by audit log filter AUDIT_ADMIN Audit log administration AUTHENTICATION_POLICY_ADMIN Authentication administration BACKUP_ADMIN Backup administration BINLOG_ADMIN Backup and Replication administration BINLOG_ENCRYPTION_ADMIN Backup and Replication administration CLONE_ADMIN Clone administration CONNECTION_ADMIN Server administration ENCRYPTION_KEY_ADMIN Server administration FIREWALL_ADMIN Firewall administration FIREWALL_EXEMPT Firewall administration FIREWALL_USER Firewall administration FLUSH_OPTIMIZER_COSTS Server administration FLUSH_STATUS Server administration FLUSH_TABLES Server administration FLUSH_USER_RESOURCES Server administration GROUP_REPLICATION_ADMIN Replication administration GROUP_REPLICATION_STREAM Replication administration INNODB_REDO_LOG_ARCHIVE Redo log archiving administration NDB_STORED_USER NDB Cluster PASSWORDLESS_USER_ADMIN Authentication administration PERSIST_RO_VARIABLES_ADMIN Server administration REPLICATION_APPLIER PRIVILEGE_CHECKS_USER for a replication channel REPLICATION_SLAVE_ADMIN Replication administration RESOURCE_GROUP_ADMIN Resource group administration RESOURCE_GROUP_USER Resource group administration ROLE_ADMIN Server administration SESSION_VARIABLES_ADMIN Server administration SET_USER_ID Server administration SHOW_ROUTINE Server administration SYSTEM_USER Server administration SYSTEM_VARIABLES_ADMIN Server administration TABLE_ENCRYPTION_ADMIN Server administration VERSION_TOKEN_ADMIN Server administration XA_RECOVER_ADMIN Server administration "},{"title":"Redis入门","date":"2023-01-09T02:59:24.000Z","url":"/post/Redis%E5%85%A5%E9%97%A8.html","categories":[["undefined",""]],"content":"NOSQL优点1.解决CPU及内存压力 2.解决IO压力 概述NoSQL(NoSQL &#x3D; Not Only SQL )，意即“不仅仅是SQL”，泛指非关系型的数据库。 NoSQL 不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。 1.不遵循SQL标准。 2.不支持ACID。 3.远超于SQL的性能。 NoSQL适用场景 1.对数据高并发的读写 2.海量数据的读写 3.对数据高可扩展性的 NoSQL不适用场景 1.需要事务支持 2.基于sql的结构化查询存储，处理复杂的关系,需要即席查询。 3.（用不着sql的和用了sql也不行的情况，请考虑用NoSq） 常用五大数据类型Redis键keys *查看当前库所有key (匹配：keys *1) exists key 判断某个key是否存在 type key 查看你的key是什么类型 del key 删除指定的key数据 unlink key 根据value选择非阻塞删除 仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。 expire key 10 10秒钟：为给定的key设置过期时间 ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期 select 命令切换数据库 dbsize 查看当前数据库的key的数量 flushdb 清空当前库 flushall 通杀全部库 Redis字符串(String)简介String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。 String类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。 String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M 常用命令set 添加键值对 *NX：当数据库中key不存在时，可以将key-value添加数据库 *XX：当数据库中key存在时，可以将key-value添加数据库，与NX参数互斥 *EX：key的超时秒数 *PX：key的超时毫秒数，与EX互斥 get 查询对应键值 append 将给定的 追加到原值的末尾 strlen 获得值的长度 setnx 只有在 key 不存在时 设置 key 的值 incr 将 key 中储存的数字值增1 只能对数字值操作，如果为空，新增值为1 decr 将 key 中储存的数字值减1 只能对数字值操作，如果为空，新增值为-1 incrby &#x2F; decrby &lt;步长&gt;将 key 中储存的数字值增减。自定义步长。 mset ….. 同时设置一个或多个 key-value对 mget ….. 同时获取一个或多个 value msetnx ….. 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。 由于原子性，有一个失败则都失败 getrange &lt;起始位置&gt;&lt;结束位置&gt; 获得值的范围，类似java中的substring，前包，后包 setrange &lt;起始位置&gt; 用 覆写所储存的字符串值，从&lt;起始位置&gt;开始(索引从0开始)。 setex &lt;过期时间&gt; 设置键值的同时，设置过期时间，单位秒。 getset 以新换旧，设置了新值同时获得旧值。 Java 中的 i++ 是原子操作吗？不是原子操作 所谓原子操作是指不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程） 在单线程中， 能够在单条指令中完成的操作都可以认为是”原子操作”，因为中断只能发生于指令之间在多线程中，不能被其它进程（线程）打断的操作就叫原子操作 Redis 单命令的原子性主要得益于 Redis 的单线程 给定 i &#x3D; 0，两个线程分别执行 i++ 100次，值是多少？2~200 数据结构String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配. 内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。 Redis列表(List)简介单键多值 Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。 它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。 常用命令lpush&#x2F;rpush …. 从左边&#x2F;右边插入一个或多个值。 lpop&#x2F;rpop 从左边&#x2F;右边吐出一个值。值在键在，值光键亡。 rpop|push 从列表右边吐出一个值，插到列表左边。 lrange 按照索引下标获得元素(从左到右) lrange mylist 0 -1 0左边第一个，-1右边第一个，（0-1表示获取所有） lindex 按照索引下标获得元素(从左到右) llen 获得列表长度 linsert before 在的后面插入插入值 lrem 从左边删除n个value(从左到右) lset将列表key下标为index的值替换成value 数据结构List的数据结构为快速链表quickList。 首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。 它将所有的元素紧挨着一起存储，分配的是一块连续的内存。 当数据量比较多的时候才会改成quicklist。 因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。 Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。 Redis集合(Set)简介Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。 Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的*复杂度都是***O(1)**。 一个算法，随着数据的增加，执行时间的长短，如果是O(1)，数据增加，查找数据的时间不变 常用命令sadd ….. 将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略 smembers 取出该集合的所有值。 sismember 判断集合是否为含有该值，有1，没有0 scard返回该集合的元素个数。 srem …. 删除集合中的某个元素。 spop 随机从该集合中吐出一个值。 srandmember 随机从该集合中取出n个值。不会从集合中删除 。 smove value把集合中一个值从一个集合移动到另一个集合 sinter 返回两个集合的交集元素。 sunion 返回两个集合的并集元素。 sdiff 返回两个集合的差集元素(key1中的，不包含key2中的) 数据结构Set数据结构是dict字典，字典是用哈希表实现的。 Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。 Redis哈希(Hash)简介Redis hash 是一个键值对集合。 Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。 类似Java里面的Map&lt;String,Object&gt; 用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key&#x2F;value结构来存储 常用命令 hset 给集合中的 键赋值 hget 从集合取出 value hset … 批量设置hash的值 hexists查看哈希表 key 中，给定域 field 是否存在。 hkeys 列出该hash集合的所有field hvals 列出该hash集合的所有value hincrby 为哈希表 key 中的域 field 的值加上增量 1 -1 hsetnx 将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在 数据结构Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable Redis有序集合(Zset)简介Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。 不同之处是有序集合的每个成员都关联了一个评分（score）,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了 。 因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。 访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。 常用命令zadd … 将一个或多个 member 元素及其 score 值加入到有序集 key 当中。 zrange [WITHSCORES] 返回有序集 key 中，下标在之间的元素 带WITHSCORES，可以让分数一起和值返回到结果集。 zrangebyscore key minmax [withscores] [limit offset count] 返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。 zrevrangebyscore key maxmin [withscores] [limit offset count] 同上，改为从大到小排列。 zincrby 为元素的score加上增量 zrem 删除该集合下，指定值的元素 zcount 统计该集合，分数区间内的元素个数 zrank 返回该值在集合中的排名，从0开始。 数据结构SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String, Double&gt;，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。 zset底层使用了两个数据结构 （1）hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。 （2）跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。 跳表1、简介 有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。 2、实例 对比有序链表和跳跃表，从链表中查询出51 （1） 有序链表 要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较。 （2） 跳表 从第2层开始，1节点比51节点小，向后比较。 21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层 在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下 在第0层，51节点为要查找的节点，节点被找到，共查找4次。 从此可以看出跳跃表比有序链表效率要高 Redis的三种新数据类型Bitmaps简介现代计算机用二进制（位） 作为信息的基础单位， 1个字节等于8位， 例如“abc”字符串是由3个字节组成， 但实际在计算机存储时将其用二进制表示， “abc”分别对应的ASCII码分别是97、 98、 99， 对应的二进制分别是01100001、 01100010和01100011，如下图 合理地使用操作位能够有效地提高内存使用率和开发效率。 Redis提供了Bitmaps这个“数据类型”可以实现对位的操作： （1） Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。 （2） Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。 命令1、setbit （1）格式 setbit设置Bitmaps中某个偏移量的值（0或1） *offset:偏移量从0开始 （2）实例 每个独立用户是否访问过网站存放在Bitmaps中， 将访问的用户记做1， 没有访问的用户记做0， 用偏移量作为用户的id。 设置键的第offset个位的值（从0算起） ， 假设现在有20个用户，userid&#x3D;1， 6， 11， 15， 19的用户对网站进行了访问， 那么当前Bitmaps初始化结果如图 unique:users:20201106代表2020-11-06这天的独立访问用户的Bitmaps 注： 很多应用的用户id以一个指定数字（例如10000） 开头， 直接将用户id和Bitmaps的偏移量对应势必会造成一定的浪费， 通常的做法是每次做setbit操作时将用户id减去这个指定数字。 在第一次初始化Bitmaps时， 假如偏移量非常大， 那么整个初始化过程执行会比较慢， 可能会造成Redis的阻塞。 2、getbit （1）格式 getbit获取Bitmaps中某个偏移量的值 获取键的第offset位的值（从0开始算） （2）实例 获取id&#x3D;8的用户是否在2020-11-06这天访问过， 返回0说明没有访问过： 注：因为100根本不存在，所以也是返回0 3、bitcount 统计字符串被设置为1的bit数。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。start 和 end 参数的设置，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，start、end 是指bit组的字节的下标数，二者皆包含。 （1）格式 bitcount[start end] 统计字符串从start字节到end字节比特值为1的数量 举例： K1 【01000001 01000000 00000000 00100001】，对应【0，1，2，3】 bitcount K1 1 2 ： 统计下标1、2字节组中bit&#x3D;1的个数，即01000000 00000000 –》bitcount K1 1 2 –》1 bitcount K1 1 3 ： 统计下标1、2字节组中bit&#x3D;1的个数，即01000000 00000000 00100001 –》bitcount K1 1 3 –》3 bitcount K1 0 -2 ： 统计下标0到下标倒数第2，字节组中bit&#x3D;1的个数，即01000001 01000000 00000000 –》bitcount K1 0 -2 –》3 注意：redis的setbit设置或清除的是bit位置，而bitcount计算的是byte位置。 4、bitop (1)格式 bitop and(or&#x2F;not&#x2F;xor) [key…] bitop是一个复合操作， 它可以做多个Bitmaps的and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在destkey中。 Bitmaps与set对比 HyperLogLog简介在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量）,可以使用Redis的incr、incrby轻松实现。 但像UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。 解决基数问题有很多种方案： （1）数据存储在MySQL表中，使用distinct count计算不重复个数 （2）使用Redis提供的hash、set、bitmaps等数据结构来处理 以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。 能否能够降低一定的精度来平衡存储空间？Redis推出了HyperLogLog Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。 在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。 但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。 什么是基数? 比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。 命令1、pfadd （1）格式 pfadd &lt; element&gt; [element …] 添加指定元素到 HyperLogLog 中 将所有元素添加到指定HyperLogLog数据结构中。如果执行命令后HLL估计的近似基数发生变化，则返回1，否则返回0。 2、pfcount （1）格式 pfcount [key …] 计算HLL的近似基数，可以计算多个HLL，比如用HLL存储每天的UV，计算一周的UV可以使用7天的UV合并计算即可 3、pfmerge （1）格式 pfmerge [sourcekey …] 将一个或多个HLL合并后的结果存储在另一个HLL中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得 Geospatial简介Redis 3.2 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。 命令1、geoadd （1）格式 geoadd&lt; longitude&gt; [longitude latitude member…] 添加地理位置（经度，纬度，名称） 2、geopos （1）格式 geopos [member…] 获得指定地区的坐标值 3、geodist （1）格式 geodist [m|km|ft|mi ] 获取两个位置之间的直线距离 4、georadius （1）格式 georadius&lt; longitude&gt;radius m|km|ft|mi 以给定的经纬度为中心，找出某一半径内的元素 Redis的发布和订阅Redis 发布订阅 (pub&#x2F;sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。 Redis 客户端可以订阅任意数量的频道。 Jedis引入jar包 Jedis-APIKey String List set hash Zset Jedis完成手机验证码功能 SpringBoot整合Jedis1、 在pom.xml文件中引入redis相关依赖 2、application.properties配置redis配置 3、添加redis配置类 4、RedisTestController中添加测试方法 "},{"title":"Java集合框架","date":"2022-11-20T08:41:47.000Z","url":"/post/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6.html","categories":[["undefined",""]],"content":"HashMap方法1：put方法：put(key，value)，我们经常用存储一些常用的数据，比如flag、百分比之类的，我们就可以返回map结构，如果key相同则值会覆盖，允许key和value为null。 9：Map.getOrDefault(key，默认值)； 简介HashMap基于哈希表的Map接口实现，是以key-value存储形式存在，即主要用来存放键值对。HashMap的实现不是同步的，这意味着他不是线程安全的，它的key、value都可以为null，此外，HashMap中的映射不是有序的。 JDK 1.8之前是由数组+链表组成的。数组是HashMap的主体，链表则是主要为了解决哈希冲突**(两个对象调用的hashCode方法计算的哈希码值一致导致计算的数组索引值相同)**而存在的(‘拉链法解决hash冲突’) JDK1.8 以后，当链表长度大于阈值（或者红黑树的边界值，默认为 8）并且当前数组的长度大于64时，此时此索引位置上的所有数据改为使用红黑树存储。 补充：将链表转换成红黑树前会判断，即使阈值大于8，但是数组长度小于64，此时并不会将链表变为红黑树。而是选择进行数组扩容。 这样做的目的是因为数组比较小，尽量避开红黑树结构，这种情况下变为红黑树结构，反而会降低效率，因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡 。同时数组长度小于64时，搜索时间相对要快些。所以综上所述为了提高性能和减少搜索时间，底层在阈值大于8并且数组长度大于64时，链表才转换为红黑树。具体可以参考 treeifyBin方法。 当然虽然增了红黑树作为底层数据结构，结构变得复杂了，但是阈值大于8并且数组长度大于64时，链表转换为红黑树时，效率也变的更高效。 特点：1.存取无序的 2.键和值位置都可以是null，但是键位置只能是一个null 3.键位置是唯一的，底层的数据结构控制键的 4.jdk1.8前数据结构是：链表 + 数组 jdk1.8之后是 ： 链表 + 数组 + 红黑树 5.阈值(边界值) &gt; 8 并且数组长度大于64，才将链表转换为红黑树，变为红黑树的目的是为了高效的查询。 数据结构 说明： 1.面试题：HashMap中hash函数是怎么实现的？还有哪些hash函数的实现方式？ 2.面试题：当两个对象的hashCode相等时会怎么样？ 3.面试题：何时发生哈希碰撞和什么是哈希碰撞,如何解决哈希碰撞？ 4.面试题：如果两个键的hashcode相同，如何存储键值对？ 5.在不断的添加数据的过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。 6.通过上述描述，当位于一个链表中的元素较多，即hash值相等但是内容不相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度(阀值)超过 8 时且当前数组的长度 &gt; 64时，将链表转换为红黑树，这样大大减少了查找时间。jdk8在哈希表中引入红黑树的原因只是为了查找效率更高。 简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的。如下图所示。 但是这样的话问题来了，传统hashMap的缺点，1.8为什么引入红黑树？这样结构的话不是更麻烦了吗，为何阈值大于8换成红黑树？ JDK 1.8 以前 HashMap 的实现是 数组+链表，即使哈希函数取得再好，也很难达到元素百分百均匀分布。当 HashMap 中有大量的元素都存放到同一个桶中时，这个桶下有一条长长的链表，这个时候 HashMap 就相当于一个单链表，假如单链表有 n 个元素，遍历的时间复杂度就是 O(n)，完全失去了它的优势。针对这种情况，JDK 1.8 中引入了 红黑树（查找时间复杂度为 O(logn)）来优化这个问题。 当链表长度很小的时候，即使遍历，速度也非常快，但是当链表长度不断变长，肯定会对查询性能有一定的影响，所以才需要转成树。 至于为什么阈值是8，我想，去源码中找寻答案应该是最可靠的途径。 下面我们在分析源码的时候会介绍。 jdk8存储过程: 继承关系 说明： Cloneable 空接口，表示可以克隆。 创建并返回HashMap对象的一个副本。 Serializable 序列化接口。属于标记性接口。HashMap对象可以被序列化和反序列化。 AbstractMap 父类提供了Map实现接口。以最大限度地减少实现此接口所需的工作。 补充：通过上述继承关系我们发现一个很奇怪的现象， 就是HashMap已经继承了AbstractMap而AbstractMap类实现了Map接口，那为什么HashMap还要在实现Map接口呢？同样在ArrayList中LinkedList中都是这种结构。 成员成员变量1.序列化版本号 2.集合的初始化容量( 必须是二的n次幂 ) 问题： 为什么必须是2的n次幂？如果输入值不是2的幂比如10会怎么样？ HashMap构造方法还可以指定集合的初始化容量大小： 根据上述讲解我们已经知道，当向HashMap中添加一个元素的时候，需要根据key的hash值，去确定其在数组中的具体位置。 HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现就在把数据存到哪个链表中的算法。 这个算法实际就是取模，hash%length，计算机中直接求余效率不如位移运算(这点上述已经讲解)。所以源码中做了优化,使用 hash&amp;(length-1)，而实际上hash%length等于hash&amp;(length-1)的前提是length是2的n次幂。 为什么这样能均匀分布减少碰撞呢？2的n次方实际就是1后面n个0，2的n次方-1 实际就是n个1； 小结： ​ 1.由上面可以看出，当我们根据key的hash确定其在数组的位置时，如果n为2的幂次方，可以保证数据的均匀插入，如果n不是2的幂次方，可能数组的一些位置永远不会插入数据，浪费数组的空间，加大hash冲突。 ​ 2.另一方面，一般我们可能会想通过 % 求余来确定位置，这样也可以，只不过性能不如 &amp; 运算。而且当n是2的幂次方时：hash &amp; (length - 1) &#x3D;&#x3D; hash % length ​ 3.因此，HashMap 容量为2次幂的原因，就是为了数据的的均匀分布，减少hash冲突，毕竟hash冲突越大，代表数组中一个链的长度越大，这样的话会降低hashmap的性能 ​ 4.如果创建HashMap对象时，输入的数组长度是10，不是2的幂，HashMap通过一通位移运算和或运算得到的肯定是2的幂次数，并且是离那个数最近的数字。 源代码如下： 默认的负载因子，默认值是0.75 当链表的值超过8则会转红黑树(1.8新增) 因为树节点的大小大约是普通节点的两倍，所以我们只在箱子包含足够的节点时才使用树节点(参见TREEIFY_THRESHOLD)。当它们变得太小(由于删除或调整大小)时，就会被转换回普通的桶。在使用分布良好的用户hashcode时，很少使用树箱。理想情况下，在随机哈希码下，箱子中节点的频率服从泊松分布 因为树节点的大小大约是普通节点的两倍，所以我们只在箱子包含足够的节点时才使用树节点(参见TREEIFY_THRESHOLD)。当它们变得太小(由于删除或调整大小)时，就会被转换回普通的桶。在使用分布良好的用户hashcode时，很少使用树箱。理想情况下，在随机哈希码下，箱子中节点的频率服从泊松分布 红黑树的平均查找长度是log(n)，如果长度为8，平均查找长度为log(8)&#x3D;3，链表的平均查找长度为n&#x2F;2，当长度为8时，平均查找长度为8&#x2F;2&#x3D;4，这才有转换成树的必要；链表长度如果是小于等于6，6&#x2F;2&#x3D;3，而log(6)&#x3D;2.6，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。 集合最大容量 原因： 1 int类型是32位整型，占4个字节。 2 Java的原始类型里没有无符号类型。 –&gt; 所以首位是符号位 正数为0，负数为1 3 java中存放的是补码，1左移31位的为 16进制的0x80000000代表的是-2147483648–&gt;所以最大只能是30 1 &lt;&lt; 30 &#x3D; 10737418241 &lt;&lt; 31 &#x3D; -21474836481 &lt;&lt; 32 &#x3D; 11 &lt;&lt; 33 &#x3D; 21 &lt;&lt; -1 &#x3D; -2147483648 当链表的值小于6则会从红黑树转回链表 当Map里面的数量超过这个值时，表中的桶才能进行树形化 ，否则桶内元素太多时会扩容，而不是树形化 为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD (8) table用来初始化(必须是二的n次幂)(重点) table在JDK1.8中我们了解到HashMap是由数组加链表加红黑树来组成的结构其中table就是HashMap中的数组，jdk8之前数组类型是Entry&lt;K,V&gt;类型。从jdk1.8之后是Node&lt;K,V&gt;类型。只是换了个名字，都实现了一样的接口：Map.Entry&lt;K,V&gt;。负责存储键值对数据的。 用来存放缓存 HashMap中存放元素的个数(重点) size为HashMap中K-V的实时数量，不是数组table的长度。 用来记录HashMap的修改次数 用来调整大小下一个容量的值计算方式为(容量*负载因子) 哈希表的加载因子(重点) 说明： 1.loadFactor加载因子，是用来衡量 HashMap 满的程度，表示HashMap的疏密程度，影响hash操作到同一个数组位置的概率，计算HashMap的实时加载因子的方法为：size&#x2F;capacity，而不是占用桶的数量去除以capacity。capacity 是桶的数量，也就是 table 的长度length。 loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值。 当HashMap里面容纳的元素已经达到HashMap数组长度的75%时，表示HashMap太挤了，需要扩容，而扩容这个过程涉及到 rehash、复制数据等操作，非常消耗性能。，所以开发中尽量减少扩容的次数，可以通过创建HashMap集合对象时指定初始容量来尽量避免。 同时在HashMap的构造器中可以定制loadFactor。 2.为什么加载因子设置为0.75,初始化临界值是12？ loadFactor越趋近于1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。 threshold计算公式：capacity(数组长度默认16) * loadFactor(负载因子默认0.75)。这个值是当前已占用数组长度的最大值。当Size&gt;&#x3D;threshold的时候，那么就要考虑对数组的resize(扩容)，也就是说，这个的意思就是 衡量数组是否需要扩增的一个标准。 扩容后的 HashMap 容量是之前容量的两倍. 遍历方式 容量的初始化把默认容量的数字设置成 initialCapacity&#x2F; 0.75F + 1.0F 集合概述 概念：对象的容器，定义了对多个对象进项操作的的常用方法。可实现数组的功能。 和数组的区别： 数组长度固定，集合长度不固定。 数组可以存储基本类型和引用类型，集合只能存储引用类型。 位置： java.util.*; Collection Collection父接口 特点：代表一组任意类型的对象，无序，无下标，不能重复。 方法： boolean add(Object obj) //添加一个对象。 boolean addAll(Collection c) //讲一个集合中的所有对象添加到此集合中。 void clear() //清空此集合中的所有对象。 boolean contains(Object o) //检查此集合中是否包含o对象。 boolean equals(Object o) //比较此集合是否与指定对象相等。 boolean isEmpty() //判断此集合是否为空。 boolean remove(Object o) //在此集合中移除o对象。 int size() //返回此集合中的元素个数。 Object[] toArray() //姜此集合转换成数组。 Collection子接口LinkedList增加：add(E e)：在链表后添加一个元素； 通用方法addFirst(E e)：在链表头部插入一个元素； 特有方法addLast(E e)：在链表尾部添加一个元素； 特有方法push(E e)：与addFirst方法一致offer(E e)：在链表尾部插入一个元素add(int index, E element)：在指定位置插入一个元素。offerFirst(E e)：JDK1.6版本之后，在头部添加； 特有方法offerLast(E e)：JDK1.6版本之后，在尾部添加； 特有方法 删除：remove() ：移除链表中第一个元素; 通用方法remove(E e)：移除指定元素； 通用方法removeFirst(E e)：删除头，获取元素并删除； 特有方法removeLast(E e)：删除尾； 特有方法pollFirst()：删除头； 特有方法pollLast()：删除尾； 特有方法pop()：和removeFirst方法一致，删除头。poll()：查询并移除第一个元素 特有方法 查：get(int index)：按照下标获取元素； 通用方法getFirst()：获取第一个元素； 特有方法getLast()：获取最后一个元素； 特有方法peek()：获取第一个元素，但是不移除； 特有方法peekFirst()：获取第一个元素，但是不移除；peekLast()：获取最后一个元素，但是不移除；pollFirst()：查询并删除头； 特有方法pollLast()：删除尾； 特有方法poll()：查询并移除第一个元素 特有方法 ArrayList1、add(Object element) 方法2、size() 方法3、get(int index) 方法4、add(int index, Object element) 方法5、set(int i, Object element) 方法6、clear() 方法7、isEmpty() 方法8、iterator() 方法9、contains(Object o) 方法10、remove(int index) 方法11、remove(Object o) 方法 Queueadd 增加一个元索 如果队列已满，则抛出一个IIIegaISlabEepeplian异常remove 移除并返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常element 返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常offer 添加一个元素并返回true 如果队列已满，则返回falsepoll 移除并返问队列头部的元素 如果队列为空，则返回nullpeek 返回队列头部的元素 如果队列为空，则返回nullput 添加一个元素 如果队列满，则阻塞take 移除并返回队列头部的元素 如果队列为空，则阻塞 PriorityQueue HashSet"},{"title":"面试精选问题","date":"2022-09-26T08:13:25.000Z","url":"/post/%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89%E9%97%AE%E9%A2%98.html","categories":[["undefined",""]],"content":"JAVA1.一道关于Integer的面试题1，来，先来一道考题，你看做对了吗？ 大家可以猜测下结果，然后将程序运行起来，验证自己的答案是否正确 这道题主要考查大家对Integer实现原理的掌握程度 下面，我给大家对这里的关键原理做解读，相信理解之后，你心中自然有答案了 答案揭晓 分情况来比较 都定义为Integer的比较： new：一旦new，就是开辟一块新内存，结果肯定是false不new：看范围Integer做了缓存，-128至127，当你取值在这个范围的时候，会采用缓存的对象，所以会相等当不在这个范围，内部创建新的对象，此时不相等 Integer和int的比较： 实际比较的是数值，Integer会做拆箱的动作，来跟基本数据类型做比较此时跟是否在缓存范围内或是否new都没关系 源码分析： 当我们写Integer i &#x3D; 126,实际上做了自动装箱：Integer i &#x3D; Integer.valueOf(126);分析这段源码 2.StringBuffer，StringBuilder开发中如何做选择？ String是final类型，每次声明的都是不可变的对象， 所以每次操作都会产生新的String对象，然后将指针指向新的String对象。 StringBuffer，StringBuilder都是在原有对象上进行操作 所以，如果需要经常改变字符串内容，则建议采用StringBuffer 和 StringBuilder StringBuffer是线程安全的，StringBuilder是线程不安全的。线程不安全的StringBuilder性能更高，所以在开发中，优先采用StringBuilder.StringBuilder &gt; StringBuffer &gt; String注意： 我们在开发中为什么会选择StringBuilder？ 这个要看场景，有同学说可以为了性能放弃安全，这是不对的。 大家想想，什么情况下需要考虑线程安全的问题？ 有一个前提条件就是：多线程访问同一个资源，且有更新操作 所以，只要不是这样的场景，我们就可以放心使用StringBuilder 而我们在开发中，通常使用StringBuilder在方法内来创建对象和拼接信息，而这种情况是一个线程对应一个StringBuilder对象"},{"title":"JVM","date":"2022-07-28T00:37:05.000Z","url":"/post/JVM.html","categories":[["undefined",""]],"content":"定义： Java Virtual Machine - java程序的运行环境 (java二进制字节码的运行环境) 好处： 一次编写，到处运行 自动内存管理，垃圾回收功能 数据下标越界检查 多态 比较： ​ JRE: Java Runtime Enviroment（） 常见的JVM: 学习路线： 内存结构程序计数器 Program Counter Register 程序计数器（寄存器） 作用：​ 用于保存下一条JVM指令的执行地址地址 特点：​ 1.是线程私有的: CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码 程序计数器是每个线程所私有的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令 ​ 2.不会存在内存溢出 虚拟机栈定义： 每个线程运行时所需要的内存，称为虚拟机栈 每个栈由多个栈帧组成，对应着每次方法调用时所占用的内存 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法 问题辨析： 1.垃圾回收是否涉及栈内存？ 不涉及，因为虚拟机栈是有一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。 2.栈内存的分配越大越好吗？ 不是，因为物理内存是一定的，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越来越少 3.方法内的局部变量是否是线程安全的？ 如果方法内局部变量没有逃离方法的作用范围，则是线程安全的 如果局部变量引用了对象，并逃离了方法的作用范围，则需要考虑线程安全问题 栈内存溢出Java.lang.stackOverflowError 栈内存溢出 栈帧过多导致栈内存溢出（无限递归） 栈帧过大导致内存溢出 线程运行诊断CPU占用过高 Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这是需要定位占用CPU过高的线程 ps H -en pid, tid, %cpu | grep 刚才通过top查到的进程号 通过ps命令进一步查看是哪个线程占用CPU过高 jstack 进程id 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来对比定位，注意jstack查找出的线程id是16禁止的，需要转换 迟迟得不到结果 可能发生了死锁 本地方法栈一些带有native关键字的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法 堆定义通过new关键字，创建的对象都会使用堆内存 特点 他是线程共享的，堆中对象都需要考虑线程安全的问题 有垃圾回收机制 堆内存溢出java.lang.OutofMemoryError ：java heap space 堆内存诊断1.jps工具 查看当前系统中有哪些java进程 2.jmap工具 查看堆内存占用情况 3.jconsole工具 图形界面的，多功能的监测工具，可以连续监测 4.jvirsalvm 方法区定义方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。 方法区内存溢出 1.8以前会导致永久代内存溢出 1.8之后会导致元空间内存溢出 通过反编译来查看类的信息 获得对应类的.class文件 在JDK对应的bin目录下运行cmd，也可以在IDEA控制台输入 输入 javac 对应类的绝对路径 输入完成后，对应的目录下就会出现类的.class文件 在控制台输入 javap -v 类的绝对路径 然后能在控制台看到反编译以后类的信息了 运行时常量池 常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息 运行时常量池，常量池是*.class文件中的，当该类被加载，他的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址 "},{"title":"SSM","date":"2022-07-26T08:33:15.000Z","url":"/post/SSM.html","categories":[["undefined",""]],"content":"spring官网 Spring Spring Framework是Spring生态圈中最基础的项目，是其他项目的根基 学习路线 核心容器的核心概念 代码书写现状 代码耦合度高 解决方案 使用对象时，在程序中不要主动使用new产生对象，转换为由外部提供对象 IoC(Inversion of Control) 控制反转 对象的创建控制权由程序转移到外部，这种思想称为控制反转 目标：解耦 Spring技术对IoC思想进行了实现 Spring提供了一个容器，称为IoC容器，用来充当IoC思想的外部 IoC容器负责对象的创建、初始化等一系列工作，被创建或被管理的对象在IoC容器中统称为Bean DI(Dependency Injection)依赖注入 在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入 本节总结： 目标：充分解耦 在IoC容器中管理bean（IoC） 在IoC容器内将有依赖关系的bean进行关系绑定（DI） 最终效果 使用对象时不仅可以直接从IoC容器中获取，并且获取的bean已经绑定了所有的依赖关系 IoC入门案例思路分析 1.管理什么？(Service与Dao) 2.如何将被管理的对象告知IoC容器？(配置) 3.被管理的对象交给IoC容器，如何获取到IoC容器？(接口) 4.IoC容器得到后，如何从容器中获取bean？(接口方法) 5.使用Spring时怎么导入坐标(pom.xml) 使用步骤： 1.导jar包 2.定义spring管理的类（接口） 3.创建Spirng配置文件，配置对应类作为Spring管理的bean 注意事项：bean定义式id属性在同一个上下文中不能重复 4.初始化IoC容器，通过容器获取bean applicationContext.getBean(“”)获取的是一个Object类型的对象，应对其进行强制类型转换 DI入门案例1.基于IoC管理bean 2.Service中使用new形式创建的Dao对象是否保留？(否) 3.Service中需要的Dao对象如何进入到Service中？(提供方法) 4.Service与Dao间的关系如何描述？(配置) 使用步骤： 1.删除使用new的形式创建对象的代码 private BookDao bookDao &#x3D; new BookDaoImpl(); public void save(){ System.out.println(“book service 。。。”); bookDao.save();} 2.提供依赖对象对应的setter方法 3.配置service与dao之间的关系 bean基础配置别名配置姓名：name 类型：属性 所属：bean标签 范例 注意事项 获取bean无论是通过id还是name获取，如果无法获取到，将抛出异常NoSuchBeanDefinitionException NoSuchBeanDefinitionException: No bean named ‘bookServiceImpl’ available bean作用范围说明 可见，Spring默认给我们创建的bean是一个单例模式， 我们可以通过在 bean标签中设置属性 scope&#x3D;”prototype”来讲bean设置成非单例 适合交给容器进行管理的bean 表现层对象 业务层对象 数据层对象 工具对象 不适合交给容器进行管理的bean 封装实体的域对象 单例bean与原型bean的区别单例bean：如果一个bean被声明为单例的时候，在处理多次请求的时候在Spring容器里只实例化出一个bean，后续的请求都公用这个对象，这个对象会保存在一个map里面。当有请求来的时候会先从缓存(map)里查看有没有，有的话直接使用这个对象，没有的话才实例化一个新的对象，所以这是个单例的。（ThreadLocal ）创建完后，后面都会复用这个bean 原型(prototype)bean来说当每次请求来的时候直接实例化新的bean，没有缓存以及从缓存查的过程。 结论： 单例的bean只有第一次创建新的bean 后面都会复用该bean，所以不会频繁创建对象。 原型的bean每次都会新创建 单例bean的优势由于不会每次都新创建新对象所以有一下几个性能上的优势： 1.减少了新生成实例的消耗新生成实例消耗包括两方面，第一，Spring会通过反射或者cglib来生成bean实例这都是耗性能的操作，其次给对象分配内存也会涉及复杂算法。 2.减少jvm垃圾回收由于不会给每个请求都新生成bean实例，所以自然回收的对象少了。 3.可以快速获取到bean因为单例的获取bean操作除了第一次生成之外其余的都是从缓存里获取的所以很快。 单例bean的劣势单例的bean一个很大的劣势就是他不能做到线程安全！！！尤其是高并发情况下。 由于所有请求都共享一个bean实例，所以这个bean要是有状态的一个bean的话可能在并发场景下出现问题，而原型的bean则不会有这样问题（但也有例外，比如他被单例bean依赖），因为给每个请求都新创建实例。 bean实例化的三种方式构造方法（常用） bean本质上就是对象，创建bean使用构造方法完成 提供可访问的构造方法 静态工厂（了解） 实例工厂 FactoryBean（实用） bean生命周期 生命周期：从创建到销毁的完整过程 bean生命周期控制：在bean创建后到销毁前做一些事情 接口控制（了解） bean生命周期 初始化容器 1.创建对象（内存分配） 2.执行构造方法 3.执行属性注入（set操作） 4.执行bean初始化方法 使用bean 1.执行业务操作 关闭&#x2F;销毁容器 1.执行bean销毁方法 bean销毁时机 容器关闭前触发bean的销毁 关闭容器方式： 手工关闭容器 ConfigurableApplicationContext接口close（）方法 注册关闭钩子，在虚拟机退出前先关闭容器再退出虚拟机 ConfigurableApplicationContext接口registerShutdownHook（）操作 依赖注入方式 思考：向一个类中传递数据的方式有几种？ 普通方法（set方法） 构造方法 思考：依赖注入描述了在容器中简历bean与bean之间依赖关系的过程，如果bean运行需要的是数据或字符串呢？ setter注入 简单类型 引用类型 构造器注入 简单类型 引用类型 依赖注入方式选择1.强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现 2.可选依赖使用setter注入进行，灵活性强 3.Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨 4.如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入 5.实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入 6.自己开发的模块推荐使用setter注入 自动装配 IoC容器根据bean所以来的资源在容器中自动查找并注入到bean中的过程称为自动装配 自动装配方式 按类型（常用） 按名称 按构造方法 不启用自动装配 配种中使用bean标签autowire 自动装配用于引用类型依赖注入，不能对简单类型进行操作 使用按类型装配时(byType)必须保障容器中想同类型的bean唯一，推荐使用 使用按名称装配时(byName)必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用 自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效 集合注入数组，List，Set，Map,Properties bean所依赖的实现类 applicationContext.xml 第三方资源配置管理 导入druid坐标 配置数据源对象作为spring管理的bean 加载properties文件由于上次学习将数据库的用户名，密码，全配置在applicationContext.xml之中，非常的危险，故应该使用properties文件记录数据库信息 1.开启context命名空间 2.使用context空间加载properties文件 使用属性占位符${}读取properties文件中的属性 4.自己配置的 jdbc.properties文件内容 容器创建容器 获取bean 容器类结构层次 BeanFactory 类路径加载配置文件 核心容器总结 BeanFactory是IoC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载 ApplicationContext接口是Spring容器的核心接口，初始化时bean立即加载 ApplicationContext接口提供基础的bean操作相关方法，通过其他接口扩展其功能 ApplicationContext接口常用初始化类 ClassPathXmlApplicationContext FileSystemXmlApplicationContext bean相关 依赖注入相关 注解开发注解开发定义bean 同时这几个注解后面也可以添加一些参数，比如比较常用的一个是注解的括号中加value属性，来表示这个组件在容器中的ID，如果不设置value值时，默认的ID是类名的全称（第一个字母小写）。 在这里有一点需要注意：事实上Spring并没有能力识别一个组件到底是不是它所标记的类型，即使将@Respository注解用在一个表述层控制器组件上面也不会产生任何错误，所以@Respository、@Service、@Controller这几个注解仅仅是为了让开发人员自己明确当前的组件扮演的角色。方便将组件加入到容器中去。 纯注解开发 Spring3.0升级了纯注解开发模式，使用java类替代配置文件，开启了Spring快速开发赛道 读取Spring核心配置文件初始化容器对象切换为读取Java配置类初始化容器对象 Java类替代Spring核心配置文件 @Configuration注解用于设定当前类为配置类 @ComponentScan注解用于设定扫描路径，次注解只能添加一次，多个数据请用数组格式 注解开发小结1.定义bean @Component @Controller @Service @Repository &lt;context:component-scan&#x2F;&gt; 2.纯注解开发 @Configuration @ComponentScan AnnotationConfigApplicationContext bean作用范围与生命周期管理 使用@Scope定义bean作用范围 使用@PostConstruct、@PreDestroy定义bean生命周期 依赖注入 使用@Autowired注解开发自动装配模式(按类型) 注意：自动装配基于反射设计创建对象并暴力反射对应属性为私有属性初始化数据，隐藏无需提供setter方法 注意：自动装配建议使用无参构造方法创建对象(默认)，如果不提供对应构造对象，请提供唯一的构造方法 使用@Qualifier注解开启指定名称装配bean 注意：@Qualifier注解无法单独使用，必须配合@Autowired注解使用 使用@Value实现简单类型注入 加载properties文件 使用@PropertySource注解加载properties文件 注意：路径仅支持单一文件配置，多文件请使用数组格式配置，不允许使用通配符* 第三方bean第三方bean管理 使用@bean配置第三方bean 建议使用方式一，因为方式二看不出你用过哪些配置类 第三方bean依赖注入 简单类型依赖注入 引用类型依赖注入 引用类型注入只需要为bean定义方法设置形参即可，容器会根据类型自动装配对象 注解开发总结XML配置对比注解配置 Spring整合mybatis ![]( Spring应该管理的bean是SqlsessionFactory Spring整合junit AOP AOP(Aspect Oriented Programming)面向切面编程，一种编程范式，指导开发者如何组织程序结构 OOP（Object Oriented Programming）面向对象编程 作用：在不惊动原始设计的基础上为其进行功能增强 Spring理念：无入侵式&#x2F;无侵入式 AOP核心概念 连接点(JoinPoint):程序执行过程中的任意位置，粒度为执行方法、抛出异常、设置变量等 在SpringAop中，理解为方法的执行 切入点（Pointcut）：匹配连接点的式子 在SpringAOP中，一个切入点可以只描述一个具体方法，也可以匹配多个方法 一个具体方法 匹配多个方法：所有的save方法，所有的get开头的方法，所有以D奥结尾的接口中的任意方法，所有带有一个参数的方法 通知（Advice）：在切入点处执行的操作，也就是共性功能 在SpringAOP中，功能最终以方法的形式呈现 通知类：定义通知的类 切面(Aspect)：描述通知与切入点的对应关系 目标对象（Target）：原始功能去掉共性功能对应的类产生的对象，这种对象是无法完成最终工作的 代理（Proxy）：目标对象无法直接完成工作，需要对其进行功能回填，通过原始对象的代理对象实现 AOP入门案例思路分析开发模式：XML 或 注解 思路分析： 1.导入坐标（pom.xml） 2.制作连接点方法（原始操作，Dao接口与实现类） 3.制作共性功能（通知类与通知） 4.定义切入点 5.绑定切入点与通知关系（切面） 步骤1.导入aop相关坐标 2.定义dao接口与实现类 3.定义通知类和切入点 说明：切入点定义依托一个不具有实际意义的方法进行，即无参数，无返回值，方法体无实际逻辑, 4.最后绑定切入点与通知关系，并指定通知添加到原始连接点的具体执行位置 5.定义通知类受Spring容器管理，并定义当前类为切面类 6.开启Spring对AOP注解驱动支持 AOP工作流程1.Spring容器启动 2.读取所有切面配置中的切入点 3.初始化bean，判定bean对应的类中的方法是否匹配到任意切入点 匹配失败，创建对象 匹配成功，创建原始对象(目标对象)的代理对象 4.获取bean执行方法 获取bean，调用方法并执行，完成操作 获取的bean是代理对象时，根据代理对象的运行模式运行原始方法与增强的内容，完成操作 AOP切入点表达式 切入点：要进行增强的方法 切入点表达式：要进行增强的方法的描述方法 切入点表达式标准格式：动作关键字(访问修饰符 返回值 包名.类&#x2F;接口名.方法名(参数)异常名) 动作关键字：描述切入点的行为动作，例如execution表示执行到指定切入点 访问修饰符：public，private等，可以省略 返回值 包名 类&#x2F;接口名 方法名 参数 异常名：方法定义中抛出指定异常，可以省略 *****：必有最少一个 ..:可以没有，也可以有任意个 书写技巧 所有代码按照规范标准开发，否则以下技巧全部失效 描述切入点通常描述接口，而不描述实现类 访问控制修饰符针对接口开发均采用public描述(可省略访问控制修饰符描述) 返回值类型对于增删改类使用精准类型加速匹配，对于查询类使用*通配快速描述 包名书写尽量不使用**..*匹配，效率过低，常用做单个包描述匹配，或精准匹配 接口名&#x2F;类型书写名称与模块相关的采用*匹配，例如UserService书写成*Service，绑定业务层接口 方法名书写以动词进行精准匹配，名次采用*匹配，例如getById书写成getBy* 参数规则较为复杂，根据业务方法灵活调整 通常不适用异常作为匹配规则 AOP通知类型 AOP通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置 AOP通知共分为5种类型 前置通知 @Before 后置通知 @After 环绕通知（重点） @Around 返回后通知（了解）@AfterReturning 抛出异常后通知（了解）@AfterThrowing 案例：测量业务层接口执行效率 AOP通知获取数据 获取切入点方法的参数、 JoinPoint：适用于前置、后置、返回后、抛出异常后通知 ProceedJoinPoint：适用于环绕通知 获取切入点方法返回值 返回后通知 环绕通知 获取切入点方法运行异常信息 抛出异常后通知 环绕通知 AOP总结 概念：AOP面向切面编程，一种编程范式 作用：在不惊动原始设计的基础上为方法进行功能增强 核心概念： 代理：SpringAOP的核心本质是采用代理模式实现的 连接点：在SpringAOP中，理解为任意方法的执行 切入点：匹配连接点的式子，也是具有共性功能的方法描述 切入点表达式标准格式：动作关键字（访问修饰符 返回值 包名.类&#x2F;接口名.方法名（参数）异常名） execution(* com.itheima.service.*Service.*(..)) 切入点表达式描述通配符： 作用：用于快速描述，范围描述 *：匹配任意符号（常用） ..：匹配多个连续的任意符号(常用) +：匹配子类类型 切入点表达式书写技巧 1.按标准规范开发 2.查询操作的返回值建议使用*匹配 3.减少使用..的形式描述包 4.对接口进行描述，使用*表示模块名，例如UserService的匹配描述为*Service 5.方法名书写保留动词，例如get,使用*表示名词，例如getById匹配描述为*getBy* 6.参数根据实际情况灵活调整 通知：若干个方法的共性功能，在切入点处执行，具体体现为一个方法 环绕通知： 环绕通知依赖形参ProceedingJoinPoint才能实现对原始方法的调用 环绕通知可以隔离原始方法的调用执行 环绕通知返回值设置为Object类型 环绕通知中可以对原始方法调用过程中出现的异常进行处理 切面：描述通知与切入点的对应关系 目标对象：被代理的原始对象称为目标对象 事务 Spirng事务作用：在数据层或业务层保障一系列的数据库操作同成功同失败 案例：银行账户转账1.在业务层接口上添加Spring事务管理 注意事项 Spring注解式事务通常添加在业务层接口中而不会添加到业务层实现类中，降低耦合 注解式事务可以添加到业务方法上表示当前方法开启事务，也可以添加到接口上表示当前接口所有方法开启事务 2.设置事务管理器 注意事项 事务管理器要根据实现技术进行选择 MyBatis框架使用的是JDBC事务 3.开启注解式事务驱动 Spring事务角色 事务管理员：发起事务方，在Spring中通常指代业务层开启事务的方法 事务协调员：加入事务方，在Spring中通常代指数据层方法，也可以是业务层方法 事务相关配置 有些异常默认事务不回滚，如IOEXCEPTION需手动设置 roolbackFor属性 案例：转账业务追加日志1.在业务层接口上添加Spring事务，设置事务传播行为REQUIRES_NEW(需要新事物) 事务传播行为 SpringMVC SpringMVC技术与Servlet技术功能等同，均属于web层开发技术 SpringMVC是一种基于java实现MVC模型的轻量级Web框架 优点 使用简单，开发便捷（相比于Servlet） 灵活性强 学习目标： 1.掌握基于SpringMVC获取请求参数与响应json数据操作 2.熟练应用基于REST风格的请求路径设置与参数传递 3.能够根据实际业务简历前后端开发通讯协议并进行实现 4.基于SSM整合技术开发任意业务模块功能 SpringMVC入门案例1.使用SpringMVC技术需要先导入SpringMVC坐标与Servlet坐标 2.创建SpringMVC控制器类（等同于Servlet功能） 3.初始化SpringMVC环境（同Spring环境），设定SpringMVC加载对应的bean 知识点1：@Controller 名称 @Controller 类型 类注解 位置 SpringMVC控制器类定义上方 作用 设定SpringMVC的核心控制器bean 知识点2：@RequestMapping 名称 @RequestMapping 类型 类注解或方法注解 位置 SpringMVC控制器类或方法定义上方 作用 设置当前控制器方法请求访问路径 相关属性 value(默认)，请求访问路径 知识点3：@ResponseBody 名称 @ResponseBody 类型 类注解或方法注解 位置 SpringMVC控制器类或方法定义上方 作用 设置当前控制器方法响应内容为当前返回值，无需解析 注意事项 SpringMVC是基于Spring的，在pom.xml只导入了spring-webmvcjar包的原因是它会自动依赖spring相关坐标 AbstractDispatcherServletInitializer类是SpringMVC提供的快速初始化Web3.0容器的抽象类 AbstractDispatcherServletInitializer提供了三个接口方法供用户实现 createServletApplicationContext方法，创建Servlet容器时，加载SpringMVC对应的bean并放入WebApplicationContext对象范围中，而WebApplicationContext的作用范围为ServletContext范围，即整个web容器范围 getServletMappings方法，设定SpringMVC对应的请求映射路径，即SpringMVC拦截哪些请求 createRootApplicationContext方法，如果创建Servlet容器时需要加载非SpringMVC对应的bean,使用当前方法进行，使用方式和createServletApplicationContext相同。 createServletApplicationContext用来加载SpringMVC环境 createRootApplicationContext用来加载Spring环境 入门案例工作流程分析 启动服务器初始化过程 1.服务器启动，执行ServletContainerInitConfig类，初始化web容器 2.执行createServletApplicationContext方法，创建了WebApplicationContext对象 3.加载SpringMvcConfig 4.执行@ComponentScan加载对应的bean 5.加载UserController，每个@RequestMapping的名称对应一个具体的方法 6.执行getServletMappings方法，定义所有的请求都通过SpringMVC 单次请求过程 1.发送请求localhost&#x2F;save 2.web容器发现所有请求都经过SpringMVC，将请求交给SpringMVC处理 3.解析请求路径&#x2F;save 4.由&#x2F;save匹配执行对应的方法save() 5.执行save() 6.检测到有@ResponseBody直接将save()方法的返回值作为响应体返回给请求方 bean加载控制 方式一:修改Spring配置类，设定扫描范围为精准范围。 方式二:修改Spring配置类，设定扫描范围为com.itheima,排除掉controller包中的bean excludeFilters属性：设置扫描加载bean时，排除的过滤规则 bean的加载格式： 对于上述的配置方式，Spring还提供了一种更简单的配置方式，可以不用再去创建AnnotationConfigWebApplicationContext对象，不用手动register对应的配置类，如何实现? 简化开发的格式 请求与响应请求映射路径优化映射路径 注意: 当类上和方法上都添加了@RequestMapping注解，前端发送请求的时候，要和两个注解的value值相加匹配才能访问到。 @RequestMapping注解value属性前面加不加/都可以 请求参数 Get请求 Post请求 Post请求中文乱码处理 为web容器添加过滤器并指定字符集，Spring-web包中提供了专用的字符过滤器 解决方法：配置过滤器 发送请求与参数: 后台接收参数: 因为前端给的是name,后台接收使用的是userName,两个名称对不上，导致接收数据失败: 解决方案:使用@RequestParam注解 用集合接收前台参数也需要@RequestParam注解 日期类型参数传递 类型转换器 json数据接受请求中json数据1.添加json数据转换相关坐标 2.设置发送json数据(请求body中添加json数据) 3.开启自动转换json数据的支持 4.设置接收json数据 @RequestBody一个处理器方法只能使用一次 @RequestBody与@RequestParam区别 区别 @RequestParam用于接收url地址传参，表单传参 @RequestBody用于接收json数据 应用 后期开发中，发送json格式数据为主，@RequestBody应用较广 如果发送非json格式数据，选用@RequestParam接收请求参数 名称 @ResponseBody 类型 &#x3D;&#x3D;方法\\类注解&#x3D;&#x3D; 位置 SpringMVC控制器方法定义上方和控制类上 作用 设置当前控制器返回值作为响应体,写在类上，该类的所有方法都有该注解功能 相关属性 pattern：指定日期时间格式字符串 说明: 该注解可以写在类上或者方法上 写在类上就是该类下的所有方法都有@ReponseBody功能 当方法上有@ReponseBody注解后 方法的返回值为字符串，会将其作为文本内容直接响应给前端 方法的返回值为对象，会将对象转换成JSON响应给前端 此处又使用到了类型转换，内部还是通过Converter接口的实现类完成的，所以Converter除了前面所说的功能外，它还可以实现: 对象转Json数据(POJO -&gt; json) 集合转Json数据(Collection -&gt; json) Rest简介 REST（Representational State Transfer），表现形式状态转换 当我们想表示一个网络资源的时候，可以使用两种方式: 传统风格资源描述形式  查询id为1的用户信息  保存用户信息 REST风格描述形式   优点： 隐藏资源的访问行为，无法通过地址得知对资源是何种操作 书写简化 按照REST风格访问资源时使用&#x3D;&#x3D;行为动作&#x3D;&#x3D;区分对资源进行了何种操作  查询全部用户信息 GET（查询）  查询指定用户信息 GET（查询）  添加用户信息 POST（新增&#x2F;保存）  修改用户信息 PUT（修改&#x2F;更新）  删除用户信息 DELETE（删除） 根据REST风格对资源进行访问称为RESTful 请求的方式比较多，但是比较常用的就4种，分别是GET,POST,PUT,DELETE。 按照不同的请求方式代表不同的操作类型。 发送GET请求是用来做查询 发送POST请求是用来做新增 发送PUT请求是用来做修改 发送DELETE请求是用来做删除 入门案例 (2)如果有多个参数需要传递该如何编写? 前端发送请求的时候使用:,路径中的1和tom就是我们想要传递的两个参数。 后端获取参数，需要做如下修改: 关于接收参数，我们学过三个注解@RequestBody、@RequestParam、@PathVariable,这三个注解之间的区别和应用分别是什么? 区别 @RequestParam用于接收url地址传参或表单传参 @RequestBody用于接收json数据 @PathVariable用于接收路径参数，使用{参数名称}描述路径参数 应用 后期开发中，发送请求参数超过1个时，以json格式为主，@RequestBody应用较广 如果发送非json格式数据，选用@RequestParam接收请求参数 采用RESTful进行开发，当参数数量较少时，例如1个，可以采用@PathVariable接收请求路径变量，通常用于传递id值 RESTful快速开发问题1：每个方法的@RequestMapping注解中都定义了访问路径&#x2F;books，重复性太高。 问题2：每个方法的@RequestMapping注解中都要使用method属性定义请求方式，重复性太高。 问题3：每个方法响应json都需要加上@ResponseBody注解，重复性太高。 对于刚才的问题，我们都有对应的解决方案： 问题1：每个方法的@RequestMapping注解中都定义了访问路径&#x2F;books，重复性太高。 问题2：每个方法的@RequestMapping注解中都要使用method属性定义请求方式，重复性太高。 问题3：每个方法响应json都需要加上@ResponseBody注解，重复性太高。 知识点1：@RestController 名称 @RestController 类型 &#x3D;&#x3D;类注解&#x3D;&#x3D; 位置 基于SpringMVC的RESTful开发控制器类定义上方 作用 设置当前控制器类为RESTful风格，等同于@Controller与@ResponseBody两个注解组合功能 知识点2：@GetMapping @PostMapping @PutMapping @DeleteMapping 名称 @GetMapping @PostMapping @PutMapping @DeleteMapping 类型 &#x3D;&#x3D;方法注解&#x3D;&#x3D; 位置 基于SpringMVC的RESTful开发控制器方法定义上方 作用 设置当前控制器方法请求访问路径与请求动作，每种对应一个请求动作，例如@GetMapping对应GET请求 相关属性 value（默认）：请求访问路径 案例：基于RESTful页面数据交互编写Controller类并使用RESTful进行配置 SpringMVC需要将静态资源进行放行。 该配置类是在config目录下，SpringMVC扫描的是controller包，所以该配置类还未生效，要想生效需要将SpringMvcConfig配置类进行修改 SSM整合1.创建工程 2.SSM整合 Spring SpringConfig MyBatis MybatisConfig JdbcConfig jdbc.properties SpringMVC ServletConfig SpirngMvcConfig 3.功能模块 表与实现类 dao(接口+自动代理) service(接口+实现类) 业务层接口测试(整合JUnit) controller 表现层接口测试(PostMan) 异常处理器 出现异常现象的常见位置与常见诱因如下： 框架内部抛出的异常：因使用不合规导致 数据层抛出的异常：因外部服务器故障导致（例如：服务器访问超时） 业务层抛出的异常：因业务逻辑书写失败导致（例如：遍历业务书写操作，导致索引异常等） 表现层抛出的异常：因数据收集、校验等规则导致（例如：不匹配的数据类型间导致异常） 工具类抛出的异常：因工具类书写不严谨不够健壮导致（例如：必要释放的连接长期未释放导致等） 所有异常均抛出到表现层处理 对于上面这些问题及解决方案，SpringMVC已经为我们提供了一套解决方案: 对于上面这些问题及解决方案，SpringMVC已经为我们提供了一套解决方案: 异常处理器: 集中的、统一的处理项目中出现的异常。 知识点1：@RestControllerAdvice 名称 @RestControllerAdvice 类型 &#x3D;&#x3D;类注解&#x3D;&#x3D; 位置 Rest风格开发的控制器增强类定义上方 作用 为Rest风格开发的控制器类做增强 **说明:**此注解自带@ResponseBody注解与@Component注解，具备对应的功能 知识点2：@ExceptionHandler 名称 @ExceptionHandler 类型 &#x3D;&#x3D;方法注解&#x3D;&#x3D; 位置 专用于异常处理的控制器方法上方 作用 设置指定异常的处理方案，功能等同于控制器方法，出现异常后终止原始控制器执行,并转入当前方法执行 说明：此类方法可以根据处理的异常不同，制作多个方法分别处理对应的异常 项目异常分类及处理项目异常分类 业务异常（BusinessException） 规范的用户行为产生的异常 用户在页面输入内容的时候未按照指定格式进行数据填写，如在年龄框输入的是字符串 不规范的用户行为操作产生的异常 如用户故意传递错误数据 系统异常（SystemException） 项目运行过程中可预计但无法避免的异常 比如数据库或服务器宕机 其他异常（Exception） 编程人员未预期到的异常，如:用到的文件不存在 处理方案 业务异常（BusinessException） 发送对应消息传递给用户，提醒规范操作 大家常见的就是提示用户名已存在或密码格式不正确等 系统异常（SystemException） 发送固定消息传递给用户，安抚用户 系统繁忙，请稍后再试 系统正在维护升级，请稍后再试 系统出问题，请联系系统管理员等 发送特定消息给运维人员，提醒维护 可以发送短信、邮箱或者是公司内部通信软件 记录日志 发消息和记录日志对用户来说是不可见的，属于后台程序 其他异常（Exception） 发送固定消息传递给用户，安抚用户 发送特定消息给编程人员，提醒维护（纳入预期范围内） 一般是程序没有考虑全，比如未做非空校验等 记录日志 拦截器 拦截器是一种动态拦截方法调用的机制，在SpirngMVC中动态拦截控制器方法的执行 作用： 在指定的方法调用前后执行预先设定的代码 阻止原始方法的执行 拦截器和过滤器区别 归属不同：Filter输入Servlet技术，Interceptor呼入SpringMVC技术 拦截内容不同：Filter对所有访问进行增强，Interceptor仅针对SpringMVC的访问进行增强 拦截器入门案例 创建拦截器类 让类实现HandlerInterceptor接口，重写接口中的三个方法 配置拦截器类 SpringMVC添加SpringMvcSupport包扫描 简化SpringMvcSupport的编写 拦截器中的preHandler方法，如果返回true,则代表放行，会执行原始Controller类中要请求的方法，如果返回false，则代表拦截，后面的就不会再执行了。 当有拦截器后，请求会先进入preHandle方法， ​ 如果方法返回true，则放行继续执行后面的handle[controller的方法]和后面的方法 ​ 如果返回false，则直接跳过后面方法的执行。 多拦截器执行顺序 SpringBootSpringBoot简介 SpringBoot设计目的是用来简化Spring应用的初始搭建以及开发过程 原始 Spring 环境搭建和开发存在以下问题： 配置繁琐 依赖设置繁琐 SpringBoot 程序优点恰巧就是针对 Spring 的缺点 自动配置。这个是用来解决 Spring 程序配置繁琐的问题 起步依赖。这个是用来解决 Spring 程序依赖设置繁琐的问题 辅助功能（内置服务器,…）。我们在启动 SpringBoot 程序时既没有使用本地的 tomcat 也没有使用 tomcat 插件，而是使用 SpringBoot 内置的服务器。 创建SpringBoot项目流程 创建新模块 点击 + 选择 New Module 创建新模块 选择 Spring Initializr ，用来创建 SpringBoot 工程 以前我们选择的是 Maven ，今天选择 Spring Initializr 来快速构建 SpringBoot 工程。而在 Module SDK 这一项选择我们安装的 JDK 版本。 对 SpringBoot 工程进行相关的设置 我们使用这种方式构建的 SpringBoot 工程其实也是 Maven 工程，而该方式只是一种快速构建的方式而已。 &#x3D;&#x3D;注意：打包方式这里需要设置为 Jar&#x3D;&#x3D; 选中 Web，然后勾选 Spring Web 由于我们需要开发一个 web 程序，使用到了 SpringMVC 技术，所以按照下图红框进行勾选 下图界面不需要任何修改，直接点击 Finish 完成 SpringBoot 工程的构建 创建 Controller 启动服务器 运行Application类 进行测试 用Postman发送请求 也可以选择去官网创建项目 Spirng项目快速启动1.所以我们只需要使用 Maven 的 package 指令打包就会在 target 目录下生成对应的 Jar 包。 2.进入 jar 包所在位置，在 命令提示符 中输入如下命令 切换web服务器我们启动工程默认是tomcat服务器，那能不能不使用 tomcat 而使用 jetty 服务器?而要切换 web 服务器就需要将默认的 tomcat 服务器给排除掉，怎么排除呢？使用 exclusion 标签 添加jetty服务器 基础配置配置文件格式 SpringBoot提供了多种属性配置方式 application.properties application.yml application.yaml SpringBoot配置文件加载顺序 application.properties &gt; application.yml &gt; application.yaml yaml YAML 一种数据序列化格式 优点： 容易阅读 容易与脚本语言交互 以数据为核心，重数据轻格式 YAML文件扩展名 .yml(主流) .yaml yaml语法规则 书写yaml文件应该严格遵守yaml语法规则，不然文件将不会被识别导致问题 大小写敏感 属性层级关系使用多行描述，每行结尾使用冒号结束 使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用Tab建） 属性值前面添加空格（属性名与属性值之间使用冒号+空格作为分隔） # 表示注释 yaml数据读取方式 在进行自定义对象封装数据被警告时，将依赖加入pom文件中 多环境配置yml 和 yamlapplication.yml 配置文件内容如下 &#x3D;&#x3D;注意：&#x3D;&#x3D; 在上面配置中给不同配置起名字的 spring.profiles 配置项已经过时。最新用来起名字的配置项是 properties文件properties 类型的配置文件配置多环境需要定义不同的配置文件 application-dev.properties 是开发环境的配置文件。我们在该文件中配置端口号为 80 application-test.properties 是测试环境的配置文件。我们在该文件中配置端口号为 81 application-pro.properties 是生产环境的配置文件。我们在该文件中配置端口号为 82 SpringBoot 只会默认加载名为 application.properties 的配置文件，所以需要在 application.properties 配置文件中设置启用哪个配置文件，配置如下: 命令行启动参数设置使用 SpringBoot 开发的程序以后都是打成 jar 包，通过 java -jar xxx.jar 的方式启动服务的。那么就存在一个问题，如何切换环境呢？因为配置文件打到的jar包中了。 我们知道 jar 包其实就是一个压缩包，可以解压缩，然后修改配置，最后再打成jar包就可以了。这种方式显然有点麻烦，而 SpringBoot 提供了在运行 jar 时设置开启指定的环境的方式，如下 那么这种方式能不能临时修改端口号呢？也是可以的，可以通过如下方式 当然也可以同时设置多个配置，比如即指定启用哪个环境配置，又临时指定端口，如下 大家进行测试后就会发现命令行设置的端口号优先级高（也就是使用的是命令行设置的端口号），配置的优先级其实 SpringBoot 官网已经进行了说明，参见 : 配置文件分类有这样的场景，我们开发完毕后需要测试人员进行测试，由于测试环境和开发环境的很多配置都不相同，所以测试人员在运行我们的工程时需要临时修改很多配置，如下 针对这种情况，SpringBoot 定义了配置文件不同的放置的位置；而放在不同位置的优先级时不同的。 SpringBoot 中4级配置文件放置位置： 1级：classpath：application.yml 2级：classpath：config&#x2F;application.yml 3级：file ：application.yml 4级：file ：config&#x2F;application.yml 作用： 1级与2级留作系统打包后设置通用属性 3级与4级用于系统开发阶段设置通用属性 SpringBoot整合junit回顾 Spring 整合 junit 使用 @RunWith 注解指定运行器，使用 @ContextConfiguration 注解来指定配置类或者配置文件。而 SpringBoot 整合 junit 特别简单，分为以下三步完成 在测试类上添加 SpringBootTest 注解 使用 @Autowired 注入要测试的资源 定义测试方法进行测试 SpringBoot整合junit &#x3D;&#x3D;注意：&#x3D;&#x3D;这里的引导类所在包必须是测试类所在包及其子包。 SpringBoot整合Mybatis回顾Spring整合MybatisSpring 整合 Mybatis 需要定义很多配置类 SpringConfig 配置类 导入 JdbcConfig 配置类 导入 MybatisConfig 配置类 JdbcConfig 配置类 定义数据源（加载properties配置项：driver、url、username、password） MybatisConfig 配置类 定义 SqlSessionFactoryBean 定义映射配置 SpringBoot整合Mybatis 创建新模块，选择Spirng初始化，并配置模块相关基础信息 选择当前模块需要使用的技术集(MyBatis Mysql) 在配置文件中（application.yaml）设置数据源参数 注意事项 定义数据层接口与映射配置 测试类中注入dao接口，测试功能 SpringBoot整合ssm pom.xml 配置起步依赖，必要的资源坐标 aplication.yml 设置数据源，端口 配置类 全部删除 dao 设置@Mapper 测试类 页面 放置在resources目录下的static目录中 MyBatis PlusMyBatisPlus入门案例与简介入门案例 创建新模块，选择Spring初始化，并配置模块相关基础信息 选择当前模块需要使用的技术集（仅保留JDBC） 手动添加MyBatisPlus起步依赖 由于MyBatisPlus并未被收录到idea的系统内置配置，无法直接选择加入 设置Jdbc参数(application.yml) 使用druid数据源，需要导入对应坐标 制作实体类与表结构（类名与表名对应，属性名与字段名对应） 如类名与表名不对应 可在实体类上方添加注释@TableName(&quot;表名&quot;) 定义数据接口，继承BaseMapper&lt;实体类类名&gt; 测试类中注入dao接口，测试功能 Mybatis简介 MP是基于Mybatis框架基础上开发的增强型工具，旨在简化开发，提升效率 开发方式 基于MyBatis使用MyBatisPlus 基于Spring使用MyBatisPlus 基于SpringBoot使用MyBatisPlus MyBatisPlus的官网为: MyBatisPlus的特性: 无侵入：只做增强不做改变，不会对现有工程产生影响 强大的 CRUD 操作：内置通用 Mapper，少量配置即可实现单表CRUD 操作 支持 Lambda：编写查询条件无需担心字段写错 支持主键自动生成 内置分页插件 …… 标准数据层开发标准CRUD使用 新增在进行新增之前，我们可以分析下新增的方法: T:泛型，新增用来保存新增数据 int:返回值，新增成功后返回1，没有新增成功返回的是0 在测试类中进行新增操作: 删除 Serializable：参数类型 思考:参数类型为什么是一个序列化类? 从这张图可以看出， String和Number是Serializable的子类， Number又是Float,Double,Integer等类的父类， 能作为主键的数据类型都已经是Serializable的子类， MP使用Serializable作为参数类型，就好比我们可以用Object接收任何数据类型一样。 int:返回值类型，数据删除成功返回1，未删除数据返回0。 在测试类中进行新增操作: 修改 T:泛型，需要修改的数据内容，注意因为是根据ID进行修改，所以传入的对象中需要有ID属性值 int:返回值，修改成功后返回1，未修改数据返回0 在测试类中进行新增操作: **说明:**修改的时候，只修改实体对象中有值的字段。 根据ID查询 Serializable：参数类型,主键ID的值 T:根据ID查询只会返回一条数据 在测试类中进行新增操作: 查询所有在进行查询所有之前，我们可以分析下查询所有的方法: Wrapper：用来构建条件查询的条件，目前我们没有可直接传为Null List:因为查询的是所有，所以返回的数据是一个集合 在测试类中进行新增操作: Lombok概念 Lombok，一个Java类库，提供了一组注解，简化POJO实体类开发。 使用步骤步骤1:添加lombok依赖 注意：版本可以不用写，因为SpringBoot中已经管理了lombok的版本。 步骤2:安装Lombok的插件&#x3D;&#x3D;新版本IDEA已经内置了该插件，如果删除setter和getter方法程序有报红，则需要安装插件&#x3D;&#x3D; 如果在IDEA中找不到lombok插件，可以访问如下网站  根据自己IDEA的版本下载对应的lombok插件，下载成功后，在IDEA中采用离线安装的方式进行安装。 步骤3:模型类上添加注解Lombok常见的注解有: @Setter:为模型类的属性提供setter方法 @Getter:为模型类的属性提供getter方法 @ToString:为模型类的属性提供toString方法 @EqualsAndHashCode:为模型类的属性提供equals和hashcode方法 &#x3D;&#x3D;@Data:是个组合注解，包含上面的注解的功能&#x3D;&#x3D; &#x3D;&#x3D;@NoArgsConstructor:提供一个无参构造函数&#x3D;&#x3D; &#x3D;&#x3D;@AllArgsConstructor:提供一个包含所有参数的构造函数&#x3D;&#x3D; Lombok的注解还有很多，上面标红的三个是比较常用的，其他的大家后期用到了，再去补充学习。 说明: Lombok只是简化模型类的编写，我们之前的方法也能用，比如有人会问:我如果只想要有name和password的构造函数，该如何编写? 这种方式是被允许的。 分页功能 IPage:用来构建分页查询条件 Wrapper：用来构建条件查询的条件，目前我们没有可直接为Null IPage:返回值，你会发现构建分页条件和方法的返回值都是IPage IPage是一个接口，我们需要找到它的实现类来构建它，具体的实现类，可以进入到IPage类中按ctrl+h,会找到其有一个实现类为Page。 步骤1:调用方法传入参数获取返回值 步骤2:设置分页拦截器这个拦截器MP已经为我们提供好了，我们只需要将其配置成Spring管理的bean对象即可。 **说明:**上面的代码记不住咋办呢? 这些内容在MP的官方文档中有详细的说明，我们可以查看官方文档类配置 步骤3:运行测试程序如果想查看MP执行的SQL语句，可以修改application.yml配置文件， 打开日志后，就可以在控制台打印出对应的SQL语句，开启日志功能性能就会受到影响，调试完后记得关闭。 DQL编程控制条件查询多条件查询格式需要： 查询年龄大于等于18，小于65岁的用户 格式一：常规格式 格式二：链式编程格式 格式三：lambda格式(推荐) 格式四：lambda格式(推荐) 并且(and) 或者(or) 关于null的判定如果传入的某一个查询条件为空，则查询会失败。 我们选择lt(boolean condition, R column, Object val)方法 true，则添加条件，返回false则不添加条件 因此，如果某一查询条件为空时，我们返回false。 查询投影 查询结果包含模型类中的部分属性 查询条件 更多查询条件设置参看 映射匹配兼容性 DML编程控制id生成策略控制不同的表应用不同的id生成策略 日志：自增（1,2,3,4，……） 购物订单：特殊规则（FQ23948AK3843） 外卖单：关联地区日期等信息（10 04 20200314 34 91） 关系表：可省略id …… 名称 @TableId 类型 &#x3D;&#x3D;属性注解&#x3D;&#x3D; 位置 模型类中用于表示主键的属性定义上方 作用 设置当前类中主键属性的生成策略 相关属性 value(默认)：设置数据库表主键名称type:设置主键属性的生成策略，值查照IdType的枚举值 能不能在某一处进行配置，就能让所有的模型类都可以使用该主键ID策略呢? 答案是肯定有，我们只需要在配置文件中添加如下内容: 配置完成后，每个模型类的主键ID策略都将成为assign_id. 数据库表与模型类的映射关系MP会默认将模型类的类名名首字母小写作为表名使用，假如数据库表的名称都以tbl_开头，那么我们就需要将所有的模型类上添加@TableName 配置起来还是比较繁琐，简化方式为在配置文件中配置如下内容: 设置表的前缀内容，这样MP就会拿 tbl_加上模型类的首字母小写，就刚好组装成数据库的表名。 多记录操作具体该如何实现多条删除，我们找找对应的API方法 除了按照id集合进行批量删除，也可以按照id集合进行批量查询，还是先来看下API 逻辑删除 删除操作业务问题：业务数据从数据库中丢弃 逻辑删除：为数据设置是否可用状态字段，删除时设置状态字段为不可用状态，数据保留在数据库中 修改数据库表添加deleted列字段名可以任意，内容也可以自定义，比如0代表正常，1代表删除，可以在添加列的同时设置其默认值为0正常。 实体类添加属性(1)添加与数据库表的列对应的一个属性名，名称可以任意，如果和数据表列名对不上，可以使用@TableField进行关系映射，如果一致，则会自动对应。 (2)标识新增的字段为逻辑删除字段，使用@TableLogic 运行删除方法 MP的逻辑删除会将所有的查询都添加一个未被删除的条件，也就是已经被删除的数据是不应该被查询出来的。 如果每个表都要有逻辑删除，那么就需要在每个模型类的属性上添加@TableLogic注解，如何优化? 在配置文件中添加全局配置，如下: 逻辑删除本质逻辑删除的本质其实是修改操作。如果加了逻辑删除字段，查询数据时也会自动带上逻辑删除字段。 执行的SQL语句为: UPDATE tbl_user SET &#x3D;&#x3D;deleted&#x3D;&#x3D;&#x3D;1 where id &#x3D; ? AND &#x3D;&#x3D;deleted&#x3D;&#x3D;&#x3D;0 乐观锁 业务并发现象带来的问题：秒杀 步骤1:数据库表添加列列名可以任意，比如使用version,给列设置默认值为1 步骤2:在模型类中添加对应的属性根据添加的字段列名，在模型类中添加对应的属性值 步骤3:添加乐观锁的拦截器 步骤4:执行更新操作 代码生成器 模板: MyBatisPlus提供，可以自己提供，但是麻烦，不建议 数据库相关配置:读取数据库获取表和字段信息 开发者自定义配置:手工配置，比如ID生成策略 步骤： 添加依赖 创建代码生成类 对于代码生成器中的代码内容，我们可以直接从官方文档中获取代码进行修改 "},{"title":"Web核心","date":"2022-07-06T06:27:05.000Z","url":"/post/Web%E6%A0%B8%E5%BF%83.html","tags":[["JavaWeb","/tags/JavaWeb/"]],"categories":[["undefined",""]],"content":"Web概述JavaWeb技术栈 B&#x2F;S架构：Browser&#x2F;Server，浏览器&#x2F;服务器 架构模式，它的特点是，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web资源，服务器把Web资源发送给浏览器即可 好处：易于维护升级：服务器升级苟，客户端无需任何不输就可以使用到新的版本 静态资源：HTML CSS JavaScript 图片等。 负责页面展现 动态资源：Servlet Jsp等。 负责逻辑处理 数据库：负责存储数据 HTTP 概念：HyperText Transfer Protocol， 超文本传输协议，规定了浏览器和服务器之间数据传输的规则 HTTP协议特点： 1.基于TCP协议：面向连接，安全 2.基于请求-响应模型：一次请求对应一次响应 3.HTTP协议是无状态的协议：对于事务处理没有记忆能力。每次请求-响应都是独立的 缺点：多次请求间不能共享数据 Java中使用会话技术（Cookie、Session）来解决 有点：速度快 请求数据格式 请求数据分为三部分： 1.请求行：请求数据的第一行。其中GET表示请求方式，&#x2F;表示请求资源路径，HTTP&#x2F;1.1表示协议版本 2.请求头：第二行开始，格式为key：value形式，常见的HTTP请求头有: 3.请求体：POST请求的最后一部分，存放请求参数 响应数据格式 1.响应行：响应数据的第一行。其中HTTP&#x2F;1.1表示协议版本，200表示响应状态码，OK表示状态码描述 2.响应头：第二行开始，格式为key：value形式，常见的HTTP响应头有: 3.响应体：最后一部分。存放相应数据 一、状态码大类 状态码分类 说明 1xx 响应中——临时状态码，表示请求已经接受，告诉客户端应该继续请求或者如果它已经完成则忽略它 2xx 成功——表示请求已经被成功接收，处理已完成 3xx 重定向——重定向到其它地方：它让客户端再发起一个请求以完成整个处理。 4xx 客户端错误——处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等 5xx 服务器端错误——处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等 状态码大全： 二、常见的响应状态码 状态码 英文描述 解释 200 OK 客户端请求成功，即处理成功，这是我们最想看到的状态码 302 Found 指示所请求的资源已移动到由Location响应头给定的 URL，浏览器会自动重新访问到这个页面 304 Not Modified 告诉客户端，你请求的资源至上次取得后，服务端并未更改，你直接用你本地缓存吧。隐式重定向 400 Bad Request 客户端请求有语法错误，不能被服务器所理解 403 Forbidden 服务器收到请求，但是拒绝提供服务，比如：没有权限访问相关资源 404 Not Found 请求资源不存在，一般是URL输入有误，或者网站资源被删除了 428 Precondition Required 服务器要求有条件的请求，告诉客户端要想访问该资源，必须携带特定的请求头 429 Too Many Requests 太多请求，可以限制客户端请求某个资源的数量，配合 Retry-After(多长时间后可以请求)响应头一起使用 431 Request Header Fields Too Large 请求头太大，服务器不愿意处理请求，因为它的头部字段太大。请求可以在减少请求头域的大小后重新提交。 405 Method Not Allowed 请求方式有误，比如应该用GET请求方式的资源，用了POST 500 Internal Server Error 服务器发生不可预期的错误。服务器出异常了，赶紧看日志去吧 503 Service Unavailable 服务器尚未准备好处理请求，服务器刚刚启动，还未初始化好 511 Network Authentication Required 客户端需要进行身份验证才能获得网络访问权限 TomcatWeb服务器是一个应用程序（软件），对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作，让开发更加便捷，主要功能是提供网上信息浏览服务 作用： 封装HTTP协议操作，简化开发 可以将web项目部署到服务器中，对外提供网上浏览服务 Tomcat是一个轻量级的Web服务器，支持Servlet&#x2F;JSP少量JavaEE规范，也称为Web服务器，Servlet容器 基本使用 部署项目 IDEA中创建Maven Web项目项目结构： 创建方法1、 2、 IDEA集成本地Tomcat IDEA中使用Tomcat - Tomcat Maven插件1.pom.xml添加Tomcat插件 2.使用Maven Helper 插件快速启动项目，选中项目，右键 Run Maven –&gt; tomcat7:run Servlet Servlet是java提供的一门动态Web资源开发技术 Servlet是javaEE规范之一，其实就是一个接口，将来我们要定义Servlet类来访问Servlet接口，并由web服务器运行Servlet Servlet快速入门1.创建一个项目，导入Servlet依赖坐标 2.创建：定义一个类，实现Servlet接口，并重写接口中的所有方法，并在service方法中输入一句话 3.配置: 在类上使用@WebServlet注解，配置该Servlet的访问路径 4.访问:启动Tomcat，浏览器输入URL访问该Servlet Servlet执行流程Servlet生命周期 对象的生命周期指一个对象从被创建到被销毁的整个过程 Servlet运行在Servlet容器（Web服务器）中，其生命周期由容器来管理，分为4个阶段 1.加载和实例化：默认情况下，当Servlet第一次被访问时，其容器创建Servlet对象 2.初始化：在Servlet实例化之后，容器将调用Servlet的init()方法来初始化这个对象，完成一些如加载配置文件、创建连接等初始化的工作。该方法只调用一次 3.请求处理：每次请求Servlet时，Servlet容器都会调用Servlet的service()方法对请求进行处理 4.服务终止：当需要释放内存或容器关闭时，容器就会调用Servlet实例的destory()方法完成资源的释放。在destory()方法调用之后，容器会释放这个Servlet实例，该实例随后会被java的垃圾收集器所回收 Servlet方法介绍 初始化方法，在Servlet被创建时执行，只执行一次 提供服务方法， 每次Servlet被访问，都会调用该方法 销毁方法，当Servlet被销毁时，调用该方法。在内存释放或服务器关闭时销毁Servlet 剩下的两个方法是: 获取Servlet信息 获取ServletConfig对象 Servlet体系结构 我们将来开发B&#x2F;S架构的web项目，都是针对HTTP协议，所以我们自定义Servlet，会继承HttpServlet HttpServlet使用步骤 继承HttpServlet 重写doGet和doPost方法 HttpServlet原理 获取请求方式，并根据不同的请求方式，调用不同的doXxx方法。 Servlet urlPattern配置 优先级：1&gt;2&gt;3&gt;&#x2F;*&gt;&#x2F; XML配置Servlet前面对应Servlet的配置，我们都使用的是@WebServlet,这个是Servlet从3.0版本后开始支持注解配置，3.0版本前只支持XML配置文件的配置方法。 对于XML的配置步骤有两步: 编写Servlet类 在web.xml中配置该Servlet 代码如下： RequestRequest继承体系 Request获取数据请求参数HTTP请求数据总共分为三部分内容，分别是 请求行、请求头、请求体 Request获取请求行数据请求行包含三块内容，分别是请求方式、请求资源路径、HTTP协议及版本 对于这三部分内容，request对象都提供了对应的API方法来获取，具体如下: 获取请求方式GET 获取虚拟目录（项目访问路径）/request-demo 获取URL（统一资源定位符） 获取URI(统一资源标识符)request-demo/req1 获取请求参数(GET方式)username=zhangsan&amp;password=123 例： 获取请求头数据对于请求头的数据，格式为key: value如下： 所以根据请求头名称获取对应值的方法为: 获取请求体数据浏览器在发送GET请求的时候是没有请求体的，所以需要把请求方式变更为POST，请求体中的数据格式如下: 获取字节输入流，如果前端发送的是字节数据，比如传递的是文件数据，则使用该方法 获取字符输入流，如果前端发送的是纯文本数据，则使用该方法 具体实现的步骤如下: 1.准备一个页面，在页面中添加form表单,用来发送post请求 2.在Servlet的doPost方法中获取请求体数据 3.在doPost方法中使用request的getReader()或者getInputStream()来获取 4.访问测试 获取请求参数的通用方式 获取所有参数Map集合 根据名称获取参数值（数组） 根据名称获取参数值(单个值) 请求参数中文乱码处理 请求参数如果存在中文数据，则会乱码 解决方案： POST:设置输入流的编码 通用方式（GET&#x2F;POST）：先编码，再解码 Request请求转发 请求转发：一种在服务器的内部资源跳转方式 实现方式： 请求转发资源间共享数据:使用Request对象 void setAttribute(String name, Object o)：存储数据到request域中 Object getAttribute(String name)：根据key，获取值 void removAttribute(String name)：根据key，删除该键值对 请求转发特点： 浏览器地址栏领不发生变化 只能转发到当前服务器的内部资源 一次请求，可以在转发的资源间使用requset共享数据 ResponseResponse设置响应数据功能介绍 响应数据分为3部分： 响应行： void setStatus(int sc): 设置响应状态码 响应头： void setHeader(String name, String value):设置响应头键值对 响应体： printWriter getWriter(): 获取字符输出流 ServletOutputStream getOutputStream():获取字节输出流 Response完成重定向 重定向：一种资源跳转方式 ​ 资源路径问题 建议动态获取虚拟目录：String contextPath &#x3D; request.getContextPath(); 重定向：response.sendRedirect(contextPath + “&#x2F;resp2”); Response响应字符数据 使用： 1.通过Response对象获取字符输入流 2.写数据 注意： 该流不需要关闭，随着响应结束，Response对象销毁，由服务器关闭 中文数据乱码：原因通过获取的字符输出流默认编码：ISO-8859-1 Response响应字节数据 使用： 1.通过Response对象获取字符输入流 2.写数据 IOUtils工具类使用 1.导入坐标 2.使用 SqlSessionFactory代码优化 问题： ​ 1.代码重复： 解决（工具类) ​ 2.SqlSessionFactory工厂只创建一次，不要重复创建： 解决（静态代码块） 我创建的工具类： JSP Java Server Pages ，Java服务端页面 一种动态的网页技术，其中既可以定义HTML,JS,CSS等静态内容，还可以定义Java代码的动态内容 JSP &#x3D; HTML + Java 作用：简化开发，避免了在Servlet中直接输出HTML标签 快速入门 缺点 EL表达式 用于简化JSP页面内的Java代码 主要功能：获取数据 语法：${expression} 获取域中存储key为brands的数据 JavaWeb中的四大域对象： page:当前页面有效 request:当前请求有效 session:当前会话有效 application:当前应用有效 *el表达式获取数据，会依次从这4个域中寻找，直到找到为止 JSTL标签 JSP标签库（Jsp Standarded Tag Library），使用标签取代JSP页面上的Java代码 MVC模式和三层架构MVC MVC是一种分层开发模式，其中： M:Model，业务模型，处理业务 V:View，视图，页面展示 C：Controller，控制器，处理请求，调用模型和视图 MVC好处 职责单一，互不影响 有利于分工协作 有利于组件重用 三层架构 案例 会话跟踪技术 会话：用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应 会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自同一浏览器，以便在同义词绘画的多次请求间共享数据 HTTP协议是无状态的，每次浏览器向服务器请求时，服务器都会将该请求视为新的请求，因此我们需要会话跟踪技术来实现会话内数据共享 实现方式： 客户端会话跟踪技术：Cookie 服务端会话跟踪技术：Session CookieCookie:客户端会话技术，将数据保存到客户端，以后每次请求都携带Cookie数据进行访问 Cookie基本使用发送Cookie1.创建Cookie对象，设置数据 2.发送Cookie到客户端：使用response对象 获取Cookie3.获取客户端携带的所有Cookie，使用request对象 4.遍历数组，获取每一个Cookie对象：for 5.使用Cookie对象方法获取数据 Cookie原理 Cookie使用细节 Cookie存活时间： ​ -默认情况下，Cookie存储爱浏览器内存中，当浏览器关闭，内存释放，则Cookie被销毁 ​ setMaxAge（int seconds）：设置Cookie存活时间 ​ 1.正数：将Cookie写入浏览器所爱电脑的硬盘，持久化存储，到时见自动删除 ​ 2.负数：默认值，Cookie在当前浏览器内存中，当浏览器关闭，则Cookie被销毁 ​ 2.零：删除对应Cookie Cookie存储中文 Cookie不能直接存储中文 如需要存储，则需要进行转码：URL编码，使用时再解码 SessionSession：服务端会话跟踪技术，将数据保存到服务端 JavaEE提供HttpSession接口，来实现一次会话的多次请求间数据共享功能 Session基本使用1.获取Session对象： 2.Session对象功能： (1) void setAttribute(String name, Object o): 存储数据到session域中 (2)Object getAttribute(String name):根据key，获取值 (3)void removeAttribute(String name):根据key，删除该键值对 Session原理 Session是基于Cookie实现的 在一次会话的多次请求之间获取的session对象是同一个 Session使用细节 Session钝化，活化： 钝化：在服务器正常关闭后，Tomcat会自动将Session数据写入硬盘的文件 活化：再次启动服务器后，从文件中加载到Session中 Session销毁： 默认情况下，无操作，30分钟自动销毁 调用Session对象的invalidate()方法 小结 Cookie和Session都是来完成一次会话内多次请求建数据共享的 区别： 存储位置：Cookie是将数据存储在客户端，Session将数据存储在服务端 安全性：Cookie不安全，Session安全 数据大小：Cookie最大3KB，Session无大小限制 存储时间：Cookie可以长期存储，Session默认30分钟 服务器性能：Cookie不占服务器资源，Session占用服务器资源 Filter 概念：Filter表示过滤器，是Javaweb三大组件（Servlet，Filter，Listener）之一 过滤器可以把对资源的请求拦截下来，从未实现一些特殊的功能 过滤器一般完成一些通用的操作，比如：权限控制，统一编码处理，敏感字符处理等等…… 快速入门 执行流程 使用细节拦截路径配置 Filter可以根据需求，配置不同的拦截资源路径 @WebFilter(“&#x2F;*”) public class FilterDemo 拦截具体的资源：&#x2F;index.jsp: 只有访问index.jsp时才会被拦截 目录拦截：&#x2F;user&#x2F;*:访问&#x2F;user下的所有资源，都会被拦截 后缀名拦截：*.jsp：访问后缀名为jsp的资源，都会被拦截 拦截所有：&#x2F;*：访问所有的资源，都会被拦截 过滤器链 一个Web应用，可以配置多个过滤器，这多个过滤器称为过滤器链 注解配置的Filter，优先级按照过滤器类名（字符串）的自然排序 Listener 概念：Listener是监听器，是JavaWeb三大组件(Servlet,Filter,Listener)之一 监听器可以监听就是在application，session，request三个对象创建，销毁或者往其中添加修改删除属性时自动执行代码的功能组件 Listener分类：JavaWeb提供了8个监听器 AJAX 概念：异步的Javascript和XML AJAX作用： 1.与服务器进行数据交换：通过AJAX可以给服务器发送请求，并获取服务器响应的数据 使用了AJAX和服务器进行通信，就可以使用HTML+AJAX来替换JSP页面了 2.异步交互：可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术，如：搜索联想，用户名是否可用校验，等等…… 异步和同步 AJAX快速入门 Axios异步框架 Axios对原生的AJAX进行封装，简化书写 官网： 将js文件 &#x2F;放到项目的webapp目录下 引入 axios 的 js 文件 使用axios 发送请求，并获取响应结果 发送 get 请求 发送 post 请求 整体页面代码如下： 请求别名方式入门案例中的 get 请求代码可以改为如下： 入门案例中的 post 请求代码可以改为如下： JSON JavaScript Object Notation。 JavaScript对象表示法 由于其语法简单，层次结构鲜明，现多用于作为数据载体，在网络中进行数据传输 JSON基础语法 JSON数据和JAVA对象的转换 Fastjson 是阿里巴巴提供的一个Java语言编写的高性能功能完善的 JSON 库，是目前Java语言中最快的 JSON 库，可以实现 Java 对象和 JSON 字符串的相互转换。 导入坐标 Java对象转JSON 将 Java 对象转换为 JSON 串，只需要使用 Fastjson 提供的 JSON 类中的 toJSONString() 静态方法即可。 JSON字符串转Java对象 将 json 转换为 Java 对象，只需要使用 Fastjson 提供的 JSON 类中的 parseObject() 静态方法即可。 VUE 免除原生JavaScript中的DOM操作，简化书写 基于MVVM(Model-View-ViewModel)思想，实现数据的双向绑定，将编程的关注点放在数据上 官网：https：&#x2F;&#x2F;cn.vuejs.org Vue快速入门1.新建HTML页面，引入Vue.js文件 2.在JS代码区域，创建Vue和新对象，进行数据绑定 3.编写视图 Vue常用指令 指令 作用 v-bind 为HTML标签绑定属性值，如设置 href , css样式等 v-model 在表单元素上创建双向数据绑定 v-on 为HTML标签绑定事件 v-if 条件性的渲染某元素，判定为true时渲染,否则不渲染 v-else v-else-if v-show 根据条件展示某元素，区别在于切换的是display属性的值 v-for 列表渲染，遍历容器的元素或者对象的属性 v-show 不展示的原理是给对应的标签添加 display css属性，并将该属性值设置为 none ，这样就达到了隐藏的效果。而 v-if 指令是条件不满足时根本就不会渲染。 Vue生命周期 Element Element：是饿了么公司前端开发团队提供的一套基于Vue的网站组件库，用于快速构建网页 组件：组成网页的部件，例如超链接，按钮，图片，表格等等 Element快速入门 引入Element的css，js文件和vue.js 创建Vue核心对象 官网复制Element组件代码 Element布局"},{"title":"java的值传递和引用传递","date":"2022-07-05T08:53:49.000Z","url":"/post/java%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92.html","tags":[["java基础知识","/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"]],"categories":[["undefined",""]],"content":"一、基本类型和引用类型的理解Java中的数据类型分为两种为基本类型和引用类型。 1、基本类型的变量保存原始值，所以变量就是数据本身。 常见的基本类型：byte,short,int,long,char,float,double,Boolean,returnAddress。 2、引用类型的变量保存引用值，所谓的引用值就是对象所在内存空间的“首地址值”，通过对这个引用值来操作对象。 常见的引用类型：类类型，接口类型和数组。 二、值传递和引用传递的理解1、值传递 在方法的调用过程中，实参把它的实际值传递给形参，此传递过程就是将实参的值复制一份传递到函数中，这样如果在函数中对该值（形参的值）进行了操作将不会影响实参的值。因为是直接复制，所以这种方式在传递大量数据时，运行效率会特别低下。 2、引用传递 引用传递弥补了值传递的不足，如果传递的数据量很大，直接复过去的话，会占用大量的内存空间，而引用传递就是将对象的地址值传递过去，函数接收的是原始值的首地址值。在方法的执行过程中，形参和实参的内容相同，指向同一块内存地址，也就是说操作的其实都是源数据，所以方法的执行将会影响到实际对象。 举例说明： 过程分析： 1、为对象分配空间 2、执行change()方法 执行前实参（黑色）和形参（红色）的指向如下： 因为String是不可变类且为值传递，而ch[]是引用传递，所以方法中的str &#x3D; “ok”,相当于重新创建一个对象并没有改变实参str的值，数组是引用传递，直接改变，所以执行完方法后，指向关系如下： 3.结论通过上面的分析我们可以得出以下结论： 基本数据类型传值，对形参的修改不会影响实参；引用类型传引用，形参和实参指向同一个内存地址（同一个对象），所以对参数的修改会影响到实际的对象。String, Integer, Double等immutable的类型特殊处理，可以理解为传值，最后的操作不会修改实参对象。 哈希表中的特殊情况只要是哈希表中的原生类型，如Integer，String，尽管他们平时是引用传递，但在哈希表中是按值传递！！！ 非原生类型，按值传递，如自己定义的类型。"},{"title":"Leetcode高频题总结","date":"2022-07-05T03:05:06.000Z","url":"/post/Leetcode%E9%AB%98%E9%A2%91%E9%A2%98%E6%80%BB%E7%BB%93.html","tags":[["算法与数据结构","/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["undefined",""]],"content":"剑指Offer06 从尾到头打印链表 15 二进制中1的个数 位移法 时间复杂度O(N) N为二进制数的位数 “与”操作法 【最优解法】时间复杂度O(K) K为二进制数中1的个数 18 删除链表的节点 24 反转链表 35 复杂链表的复制 65 不用加减乘除做加法"},{"title":"数据结构与算法学习","date":"2022-07-02T01:51:23.000Z","url":"/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0.html","tags":[["算法与数据结构","/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["undefined",""]],"content":"学习路线 搞定1,2,3差不多达到面试水平 杂记子问题规模一样的递归可以用Master公式求时间复杂度 T(N) &#x3D; a * T(N&#x2F;b) + O(N ^ d); a:会有几次调用代码 b:每次调用规模的大小 如果 log（b , a) &lt; d 时间复杂度为： O(N^d) 如果log (b , a) &gt; d 时间复杂度为 ： O(N^(log(b,a))) 如果log（b , a）&#x3D;&#x3D; d 时间复杂度为：O(N^d * log(2,n)))注：log(b,a) 指以b为地a为指数 基础的数据结构实现栈和队列用数组实现队列 数组实现一个特殊的栈，可实时返回栈中最小值 如何用栈实现队列 如何用队列实现栈 堆 排序选择排序0~N-1上找到最小值与下标为0的值交换 1~N-1上找到最小值与下标为1的值交换 2~N-1上找到最小值与下标为2的值交换 ······ 冒泡排序 插入排序 归并排序 变形1：给定一个数组，求出每个元素左边比他小的元素之和，再求每个元素左边比他小的元素之和的累加和，要求小于O（N^2） 变形2：求逆序对的数量 给定一个序列有n个数，求n个数中逆序对的个数，逆序对的定义：i &lt; j &amp;&amp; a[i] &gt; a[j]。 变形3：翻转对 堆排序 位运算 二叉树"},{"title":"前端三件套","date":"2022-06-30T02:44:09.000Z","url":"/post/%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8.html","tags":[["前端","/tags/%E5%89%8D%E7%AB%AF/"]],"categories":[["undefined",""]],"content":"HTMLHTML：超文本标记语言超文本：超越了文本的的限制，比普通文本更强大，除了文字信息，还可以定义图片，音频，视频等内容。标记语言：由标签构成的语言 HTML运行在浏览器上，HTML标签由浏览器来解析 HTML标签都是预定义好的。例如：使用&lt;img&gt;展示图片 W3C标准：网页主要由三部分组成 结构：HTML 表现：CSS 行为：JavaScript HTML结构： CSS导入方式： 1、使用“”引入css样式； 2、在style标签里写css样式； 3、在元素标签里使用style属性写css样式。 具体使用查W3cschool js导入方式： 1、直接引入 &lt;script&gt;alert(&quot;这是js的内部引入&quot;);&lt;&#x2F;script&gt; 2、 定义外部js文件 &lt;script type&#x3D;”text&#x2F;javascript” src&#x3D;”demo.js”&gt; 基本语法结尾 ; 可有可无 使用window.alert()写入警告框 使用document.write()写入html输出 使用console.log()写入浏览器控制台 用var声明变量 Javascript是一门弱类型语言，变量可以存放不同类型的值 变量名命名规则： 组成字符可以是任何字母，数组，下划线(_)或美元符号($) 数字不能开头 建议使用驼峰命名 ECMAScript6新增了let关键字来定义变量，它的用法类似于var，但是所声明的变量，只在let关键字所在的代码块内有效，且不允许重复声明 ECMAScript6新增了const关键字，用来声明一个只读的常量。一旦声明，常量的值就不能改变了 运算符 &#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 类型转换：其他类型转为number： string: 按照字符串的字面值，转为数字.如果字面值不是数字，则转为NaN。一般使用parseInt boolean: true 转为1，false转为0 其他类型转为boolean： number:0和NaN转为false，其他的数字转为true string:空字符串转为false，其他的字符串转为true null:false undefined:false 对象Array String 自定义对象 BOMBOM：Browser Object Model 浏览器对象模型。也就是 JavaScript 将浏览器的各个组成部分封装为对象。 我们要操作浏览器的各个组成部分就可以通过操作 BOM 中的对象来实现。比如：我现在想将浏览器地址栏的地址改为  就可以通过使用 BOM 中定义的 Location 对象的 href 属性，代码： location.href = &quot;;; BOM 中包含了如下对象： Window：浏览器窗口对象 Navigator：浏览器对象 Screen：屏幕对象 History：历史记录对象 Location：地址栏对象 下图是 BOM 中的各个对象和浏览器的各个组成部分的对应关系 window对象 history对象 loaction对象 DOMDOM：Document Object Model 文档对象模型。也就是 JavaScript 将 HTML 文档的各个组成部分封装为对象。 DOM 其实我们并不陌生，之前在学习 XML 就接触过，只不过 XML 文档中的标签需要我们写代码解析，而 HTML 文档是浏览器解析。封装的对象分为 Document：整个文档对象 Element：元素对象 Attribute：属性对象 Text：文本对象 Comment：注释对象 如下图，左边是 HTML 文档内容，右边是 DOM 树 作用： JavaScript 通过 DOM， 就能够对 HTML进行操作了 改变 HTML 元素的内容 改变 HTML 元素的样式（CSS） 对 HTML DOM 事件作出反应 添加和删除 HTML 元素 DOM相关概念： DOM 是 W3C（万维网联盟）定义了访问 HTML 和 XML 文档的标准。该标准被分为 3 个不同的部分： 核心 DOM：针对任何结构化文档的标准模型。 XML 和 HTML 通用的标准 Document：整个文档对象 Element：元素对象 Attribute：属性对象 Text：文本对象 Comment：注释对象 XML DOM： 针对 XML 文档的标准模型 HTML DOM： 针对 HTML 文档的标准模型 该标准是在核心 DOM 基础上，对 HTML 中的每个标签都封装成了不同的对象 例如：&lt;img&gt; 标签在浏览器加载到内存中时会被封装成 Image 对象，同时该对象也是 Element 对象。 例如：&lt;input type=&#39;button&#39;&gt; 标签在浏览器加载到内存中时会被封装成 Button 对象，同时该对象也是 Element 对象。 获取Element对象HTML 中的 Element 对象可以通过 Document 对象获取，而 Document 对象是通过 window 对象获取。 Document 对象中提供了以下获取 Element 元素对象的函数 getElementById()：根据id属性值获取，返回单个Element对象 getElementsByTagName()：根据标签名称获取，返回Element对象数组 getElementsByName()：根据name属性值获取，返回Element对象数组 getElementsByClassName()：根据class属性值获取，返回Element对象数组 事件监听 事件：HTML事件是发生在HTML元素身上的“事情”。比如： 按钮被点击 鼠标移动到元素之上 按下键盘按键 事件监听：Javascript可以在事件被侦测到时执行代码 事件绑定方式一：通过 HTML标签中的事件属性进行绑定 onclick 是 单击事件 的事件属性 方式二：通过 DOM 元素属性绑定 为保证单一职责，建议使用方式二 常见事件 正则表达式正则对象有两种创建方式： 直接量方式：注意不要加引号 创建 RegExp 对象 test(str) ：判断指定字符串是否符合规则，返回 true或 false 从上面创建正则对象的格式中可以看出不管哪种方式都需要正则表达式，那么什么是正则表达式呢？ 正则表达式定义了字符串组成的规则。也就是判断指定的字符串是否符合指定的规则，如果符合返回true，如果不符合返回false。 正则表达式是和语言无关的。很多语言都支持正则表达式，Java语言也支持，只不过正则表达式在不同的语言中的使用方式不同，js 中需要使用正则对象来使用正则表达式。 正则表达式常用的规则如下： ^：表示开始 $：表示结束 [ ]：代表某个范围内的单个字符，比如： [0-9] 单个数字字符 .：代表任意单个字符，除了换行和行结束符 \\w：代表单词字符：字母、数字、下划线()，相当于 [A-Za-z0-9] \\d：代表数字字符： 相当于 [0-9] 量词： +：至少一个 *：零个或多个 ？：零个或一个 {x}：x个 {m,}：至少m个 {m,n}：至少m个，最多n个 "},{"title":"Mybatis","date":"2022-06-07T08:06:27.000Z","url":"/post/Mybatis.html","categories":[["undefined",""]],"content":"入门_MyBatis中文网(Mybatis.pdf)什么是Mybatis？ Mybatis是一款优秀的持久层框架，用于简化JDBC开发 官网： 持久层： 负责将数据保存到数据库的那一层代码 JavaEE三层架构：表现层，业务层，持久层 框架： 框架就是一个半成品软件，是一套可重用的、通用的、软件基础代码模型 在框架的基础之上构建软件编写更加高效、规范、通用、可扩展 快速入门 JDBC写的是硬编码，后期维护很麻烦，无论是增删改查语句的修改，或者是用户名密码的改变， MyBatis虽然麻烦，不过很多步骤只做一次，后期维护非常的方便 解决SQL映射文件的警告提示产生原因：IDEA和数据库没有建立连接，不识别表信息 解决方法：在IDEA中配置MySQL数据库连接 Mapper代理开发 目的 1.解决原生方式中的硬编码 2.简化后期执行SQL 步骤 1.定义与SQL映射文件同名的Mapper接口，并且将Mapper接口和SQL映射文件放置在同一目录下 2.设置SQL映射文件的namespace属性为Mapper接口全限定名 3.在Mapper接口中定义方法，方法名就是SQL映射文件中sql语句的id，并保持参数类型和返回值类型一致 4.编码 通过SqlSession的getMapper方法获取Mapper接口的代理对象 调用对应方法完成sql的执行 细节 如果Mapper接口名称和SQL映射文件名称相同，并在同一目录下，则可以使用包扫描的方式简化SQL映射文件的加载 Mybatis核心配置文件详解 注解完成增删改查 注解即在接口方法上直接写SQL语句，不用在xml文件中再配置 配置文件完成增删改查起别名 定义&lt;sql&gt;片段 定义&lt;resultMap&gt;片段 注意事项 参数占位符 ​ #{}: 执行SQL时，会将#{}占位符替换为?，将来自动设置参数值 ​ ${}: 拼SQL。会存在SQL注入问题 ​ 使用时机： ​ 参数传递，都是用#{} ​ 如果要对表名，列名进行动态设置，只能使用${}进行sql拼接 2.parameterType ​ 用于设置参数类型，该参数可以省略 3.SQL语句中特殊字符处理 ​ 转义字符 &lt;![CDATA[内容]]&gt; 动态SQLif标签：用于判断参数是否有值，使用test属性进行条件判断 存在的问题：第一个条件不需要逻辑运算符 解决方案： 使用恒等式让所有条件格式都一样 &lt;where&gt;标签替换where关键字 事务提交自动提交 手动提交 返回添加数据的主键 上图（批量删除） 如果接口方法未加param注解，collection属性的值应该为array 参数传递 参数封装 使用中出现的问题（注意） 不加@Param注解，取值的时候直接写属性 加了@Param注解，取值必须使用对象.属性的方式 "},{"title":"Maven","date":"2022-05-18T08:50:49.000Z","url":"/post/Maven.html","categories":[["undefined",""]],"content":" Maven是专门用于管理和构建java项目的工具Maven基础Maven的功能 1、提供了一套标准化的项目结构 2、提供了一套标准化的构建流程（编译，测试，打包，发布……） 3、提供了一套依赖管理机制 模型 常见命令 compile 编译 clean 清理 test 测试 package 打包 install 安装 IDEA配置Maven Maven坐标详解 什么是坐标： Maven中的坐标是资源的唯一标识 使用坐标来定义项目或引入项目中需要的依赖 Maven坐标的主要组成 groupld：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima） artifactld：定义当前Maven项目名称（通常是模块名称） version：定义当前项目版本号 IDEA创建Maven项目 依赖管理使用坐标导入jar包1.在pom.xml中编写&lt;dependencies&gt;标签 2.在&lt;dependencies&gt;标签中 使用&lt;dependency&gt;引入坐标 3.定义坐标的groupid，artifactld，version 4.点击刷新按钮，使坐标生效(建议配置自动生效，无需刷新) 依赖范围 Maven进阶分模块开发与设计 将原始模块按照功能拆分成若干个子模块，方便模块间的相互调用，接口共享 步骤： 1.创建Maven模块 2.书写模块代码 3.通过maven指令安装模块到本地仓库（install指令） 依赖管理 依赖具有传递性 直接依赖：在当前项目中通过依赖配置建立的依赖关系 间接依赖：被依赖的资源如果依赖其他资源，当前项目间接依赖其他资源 依赖传递冲突问题 路径优先：当依赖中出现相同的资源时，层级越深，优先级越低，层级越浅，优先级越高 声明优先：当资源在相同层级被依赖时，配置顺序靠前的覆盖配置顺序靠后的 特殊优先：当同级配置了相同资源的不同版本，后配置的覆盖先配置的 可选依赖 排除依赖 简单来梳理下，就是 A依赖B,B依赖C,C通过依赖传递会被A使用到，现在要想办法让A不去依赖C 可选依赖是在B上设置&lt;optional&gt;,A不知道有C的存在， 排除依赖是在A上设置&lt;exclusions&gt;,A知道有C的存在，主动将其排除掉。 聚合 与 继承聚合 聚合项目的打包方式为POM，并添加所要管理的项目 jar:默认情况，说明该项目为java项目 war:说明该项目为web项目 pom:说明该项目为聚合或继承(后面会讲)项目 使用聚合统一管理项目 测试发现，当maven_01_parent的compile被点击后，所有被其管理的项目都会被执行编译操作。这就是聚合工程的作用。 说明：聚合工程管理的项目在进行运行的时候，会按照项目与项目之间的依赖关系来自动决定执行的顺序和配置的顺序无关。 继承 所谓继承:描述的是两个工程间的关系，与java中的继承相似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承。 作用： 简化配置 减少版本冲突 步骤 创建maven模块，设置打包方式为pom 在父工程的pom文件中配置依赖关系(子工程将沿用父工程中的依赖关系) 配置子工程中可选的依赖关系 在子工程中配置当前工程所继承的父工程 在子工程中配置父工程中可选依赖的坐标 注意事项: 1.子工程中使用父工程中的可选依赖时，仅需要提供群组id和项目id，无需提供版本，版本由父工程统一提供，避免版本冲突 2.子工程中还可以定义父工程中没有定义的依赖关系,只不过不能被父工程进行版本统一管理。 聚合和继承的区别 作用： 聚合用于快速构建项目 继承用于快速配置 相同点： 聚合与继承的pom.xml文件打包方式均为pom，可以将两种关系制作到同一个pom文件中 聚合和继承均属于设计型模块，并无实际的内容模块 不同点： 聚合是在当前模块中配置关系，聚合可以感知到参与聚合的模块有哪些 继承是在子模块中配置关系，父模块无法感知哪些子模块继承了自己 属性如果我们现在想更新Spring的版本 如何保证多个jar包版本的统一？ 步骤1:父工程的pom.xml中定义属性 步骤2:修改依赖的version 此时，我们只需要更新父工程中properties标签中所维护的jar包版本，所有子项目中的版本也就跟着更新。 配置文件加载属性步骤步骤1:父工程定义属性 步骤2:jdbc.properties文件中引用属性在jdbc.properties，将jdbc.url的值直接获取Maven配置的属性 步骤3:设置maven过滤文件范围Maven在默认情况下是从当前项目的src\\main\\resources下读取文件进行打包。现在我们需要打包的资源文件是在maven_02_ssm下,需要我们通过配置来指定下具体的资源目录。 **说明:**directory路径前要添加../的原因是maven_02_ssm相对于父工程的pom.xml路径是在其上一层的目录中，所以需要添加。 修改完后，注意maven_02_ssm项目的resources目录就多了些东西，如下: 步骤4:测试是否生效测试的时候，只需要将maven_02_ssm项目进行打包，然后观察打包结果中最终生成的内容是否为Maven中配置的内容。 上面的属性管理就已经完成，但是有一个问题没有解决，因为不只是maven_02_ssm项目需要有属性被父工程管理，如果有多个项目需要配置，该如何实现呢? 方式一: 可以配，但是如果项目够多的话，这个配置也是比较繁琐 方式二: **说明:**打包的过程中如果报如下错误: 原因就是Maven发现你的项目为web项目，就会去找web项目的入口web.xml[配置文件配置的方式]，发现没有找到，就会报错。 解决方案1：在maven_02_ssm项目的src\\main\\webapp\\WEB-INF\\添加一个web.xml文件 上面我们所使用的都是Maven的自定义属性，除了${project.basedir},它属于Maven的内置系统属性。 在Maven中的属性分为: 自定义属性（常用） 内置属性 Setting属性 Java系统属性 环境变量属性 具体如何查看这些属性: 在cmd命令行中输入mvn help:system 具体使用，就是使用 $&#123;key&#125;来获取，key为等号左边的，值为等号右边的，比如获取红线的值，对应的写法为 $&#123;java.runtime.name&#125;。 版本管理在我们jar包的版本定义中，有两个工程版本用的比较多: SNAPSHOT（快照版本） 项目开发过程中临时输出的版本，称为快照版本 快照版本会随着开发的进展不断更新 RELEASE（发布版本） 项目开发到一定阶段里程碑后，向团队外部发布较为稳定的版本，这种版本所对应的构件文件是稳定的 即便进行功能的后续开发，也不会改变当前发布版本内容，这种版本称为发布版本 除了上面的工程版本，我们还经常能看到一些发布版本: alpha版:内测版，bug多不稳定内部版本不断添加新功能 beta版:公测版，不稳定(比alpha稳定些)，bug相对较多不断添加新功能 纯数字版 多环境配置与应用多环境开发 我们平常都是在自己的开发环境进行开发， 当开发完成后，需要把开发的功能部署到测试环境供测试人员进行测试使用， 等测试人员测试通过后，我们会将项目部署到生成环境上线使用。 这个时候就有一个问题是，不同环境的配置是不相同的，如不可能让三个环境都用一个数据库，所以就会有三个数据库的url配置， 我们在项目中如何配置? 要想实现不同环境之间的配置切换又该如何来实现呢? maven提供配置多种环境的设定，帮助开发者在使用过程中快速切换环境。具体实现步骤: 步骤1:父工程配置多个环境,并指定默认激活环境 所以总结来说，对于多环境切换只需要两步即可: 父工程中定义多环境 使用多环境(构建过程) 跳过测试 应用场景 功能更新中并且没有开发完毕 快速打包 …… 前面在执行install指令的时候，Maven都会按照顺序从上往下依次执行，每次都会执行test, 对于test来说有它存在的意义， 可以确保每次打包或者安装的时候，程序的正确性，假如测试已经通过在我们没有修改程序的前提下再次执行打包或安装命令，由于顺序执行，测试会被再次执行，就有点耗费时间了。 功能开发过程中有部分模块还没有开发完毕，测试无法通过，但是想要把其中某一部分进行快速打包，此时由于测试环境失败就会导致打包失败。 遇到上面这些情况的时候，我们就想跳过测试执行下面的构建命令，具体实现方式有很多： 方式一:IDEA工具实现跳过测试 图中的按钮为Toggle &#39;Skip Tests&#39; Mode, Toggle翻译为切换的意思，也就是说在测试与不测试之间进行切换。 点击一下，出现测试画横线的图片，如下: 说明测试已经被关闭，再次点击就会恢复。 这种方式最简单，但是有点”暴力”，会把所有的测试都跳过，如果我们想更精细的控制哪些跳过哪些不跳过，就需要使用配置插件的方式。 方式二:配置插件实现跳过测试在父工程中的pom.xml中添加测试插件配置 skipTests:如果为true，则跳过所有测试，如果为false，则不跳过测试 excludes：哪些测试类不参与测试，即排除，针对skipTests为false来设置的 includes: 哪些测试类要参与测试，即包含,针对skipTests为true来设置的 方式三:命令行跳过测试 使用Maven的命令行，mvn 指令 -D skipTests 注意事项: 执行的项目构建指令必须包含测试生命周期，否则无效果。例如执行compile生命周期，不经过test生命周期。 该命令可以不借助IDEA，直接使用cmd命令行进行跳过测试，需要注意的是cmd要在pom.xml所在目录下进行执行。 私服私服简介及使用 私服是一台独立的服务器，用于解决团队内部的资源共享与资源同步问题 搭建Maven私服的方式有很多，我们来介绍其中一种使用量比较大的实现方式: Nexus Sonatype公司的一款maven私服产品 下载地址： 使用cmd进入到解压目录下的nexus-3.30.1-01\\bin,执行如下命令: 至此私服就已经安装成功。如果要想修改一些基础配置信息，可以使用: 修改基础配置信息 安装路径下etc目录中nexus-default.properties文件保存有nexus基础配置信息，例如默认访问端口。 修改服务器运行配置信息 安装路径下bin目录中nexus.vmoptions文件保存有nexus服务器启动对应的配置信息，例如默认占用内存空间。 私服仓库分类 本地仓库访问私服配置步骤1:私服上配置仓库 步骤2:配置本地Maven对私服的访问权限 步骤3:配置私服的访问路径 为了避免阿里云Maven私服地址的影响，建议先将之前配置的阿里云Maven私服镜像地址注释掉，等练习完后，再将其恢复。 资源上传与下载本地仓库与私服已经建立了连接，接下来我们就需要往私服上上传资源和下载资源，具体的实现步骤为: 步骤1:配置工程上传私服的具体位置 步骤2:发布资源到私服 或者执行Maven命令 注意: 要发布的项目都需要配置distributionManagement标签，要么在自己的pom.xml中配置，要么在其父项目中配置，然后子项目中继承父项目即可。 "},{"title":"JDBC总结","date":"2022-05-07T02:47:07.000Z","url":"/post/JDBC%E6%80%BB%E7%BB%93.html","categories":[["undefined",""]],"content":"JDBC快速入门 (JDBC.pdf)1、编写代码步骤1、创建工程,导入驱动jar包 jar包 2、注册驱动 3、获取连接 4、定义SQL语句 5、获取执行SQL的对象 6、执行SQL语句 7、处理返回结果8、释放资源 例 API详解1、DriverManager1、注册驱动*** MYSQL 5之后的驱动包，可以省略注册驱动的步骤*** 这个方法可以完成驱动的注册，但是实际开发中一般不会使用这个方法完成驱动的注册 原因： 如果需要注册驱动，就会使用，DriverManager.registerDriver(new Driver()); ,但是查看源代码发现，在代码中一段静态代码块，静态代码块已经调用了注册驱动的方法。 如果再手动调用该方法注册驱动，就会导致驱动被注册两次。实际开发中一般户次爱用; 2、获得与数据库的连接 这个方法就是用来获得与数据库连接的方法，这个方法中的三个参数为 与数据库连接的路径(url)，与数据库连接的用户名(user)，与数据库连接的密码(password)。 主要是url的写法： localhost :连接的MySQL数据库服务器的主机ip地址。（连接是本机就可以写成localhost），如果连接不是本机的，就需要写上连接主机的IP地址。 url如果连接的是本机的路径，可以简化为如下格式： jdbc:mysql:&#x2F;&#x2F;&#x2F;db1 配置useSSL &#x3D; false 参数，禁用安全连接方式，解决警告提示 2、Connection1、获取执行SQL对象普通执行SQL对象 预编译SQL的执行SQL对象；防止SQL注入 执行存储过程的对象 2、事务管理MYSQL事务管理 JDBC事务管理Connection接口中定义了3个对应的方法 例： 3、Statement1、执行SQL语句 4、ResultSet封装了DQL查询语句的结果 获取查询结果 使用步骤1、游标向下移动一行，并判断该行是否有数据：next() 2 、获取数据：getXxx(参数) 5、PreparedStatement作用：预编译SQL语句并执行，防止SQL注入问题如：用户名随便写，密码写成’ or ‘ 1 ‘ &#x3D; ‘1 用法：1、获取PreparedStatement对象 2、设置参数值 3、执行SQL 例 好处：1、预编译SQL，性能更高 2、防止SQL注入，将敏感字符进行转义 PreparedStatement预编译功能开启：useServerPrepStmts&#x3D;true （参数键值对）应加在URL最后 配置MySQL执行日志（重启mysql服务后生效） 原理：1、在获取PreparedStatement对象时，将sql语句发送给mysql服务器进行检查，编译（这些步骤很耗时） 2、执行时就不用再进行这些步骤了，速度更快 3、如果sql模板一样，则只需要进行一次检查编译 数据库连接池简介 数据库连接池是个容器，负责分配，，管理数据库连接 它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个 释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏 好处： 资源重用 提升系统响应速度 避免数据库连接遗漏 数据库连接池实现标准接口 官方（SUN）提供的数据库连接池标准接口，由第三方组织实现此接口。 功能：获取连接 常见的数据库连接池： DBCP C3P0 Druid Druid（德鲁伊） Druid连接池是阿里巴巴开源的数据库连接池项目 功能强大，性能优秀，是Java语言最好的数据库连接池之一 "},{"title":"SQL总结","date":"2022-04-30T08:59:10.000Z","url":"/post/SQL%E6%80%BB%E7%BB%93.html","categories":[["undefined",""]],"content":"SQL通用语法1.SQL语句可以单行或多行书写，以分号结尾。 2.MYSQL数据库的SQL语句不区分大小写，关键字建议适用大写。 3.注释 （1） 单行注释：– 注释内容（两个横杠一个空格+注释内容） 或 #注释内容（MYSQL特有) （2） 多行注释： &#x2F;* 注释 *&#x2F; 对 MYSQL 的 windows命令1、启动mysql服务 2、进入mysql，输入密码： 对数据库的操作1、查看所有数据库 2、创建数据库 3、删除数据库 4、使用数据库 5、查看当前使用的数据库 对表的操作· 创建（create） ·查询（retrieve） ·修改（update） ·删除（delete） 1、创建（create）创建表 最后一行末尾不能加逗号 2、查询（retrieve）查询当前数据库下所有表名称 查询表结构 3、修改（update）修改表名 添加一列 修改数据类型 修改列名和数据类型 删除列 4、删除（delete）删除表 对数据的操作添加数据1、给指定列添加数据 2、给全部列添加数据 3、批量添加数据 修改数据1、修改表数据 修改语句如果不加条件，则所有数据都将被修改! 删除数据1、删除数据 删除语句如果不加条件，则所有数据都将被删除 查询数据 约束 外键约束 数据库设计 多表查询内连接 内连接相当于查询A B 交集数据 外连接 左外连接 ：相当于查询A表所有数据和交集部分数据 右外连接 ：相当于查询B表所有数据和交集部分数据 子查询子查询根据查询结果不同，作用不同;1、单行单列:作为条件值，使用&#x3D;,!&#x3D;,&gt;,&lt;等进行条件判断 2、多行单列:作为条件值，使用in等关键字进行条件判断 3、多行duolie:作为虚拟表 事物1、开启事务 2、提交事务 3、回滚事务 4、事务的特性 5.事务提交mysql事务默认自动提交 "},{"title":"java核心技术卷总结","date":"2022-04-25T11:48:12.000Z","url":"/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E6%80%BB%E7%BB%93.html","categories":[["undefined",""]],"content":"1.&amp;&amp;和|| 运算符是按照“短路”方式来求值的：如果第一个操作数已经能够确定表达式的值，第二个操作数就不必计算了。2.位移运算符的右操作数要完成模32的运算（除非左操作数是long类型，在这种情况下需要对右操作数模64）。例如，1&lt;&lt;35的值等同于1&lt;&lt;3或8。3.同一个级别的运算符按照从左到右的次序进行计算（但右结合运算符除外）&amp;&amp; 优先级大于 | | 。4.String类的substring方法可以从一个较大的字符串提取出一个子串。例如： String greeting &#x3D; “Hello”; String a &#x3D; greeting.substring(0,3); 打印 a 会输出 Hel。 即输出[a,b)。5.检测字符串是否相等string a &#x3D; “ok”;string b &#x3D; “ok”;a.equals(b)；“ok”.equals(“ok”);“ok”.equals(“b”);想要检测两个字符串是否相等，而不区分大小写，可用equalsIgnoreCase方法。“Hello”. equalsIgnoreCase(“hello”);6.一定不要使用&#x3D;&#x3D;来检测两个字符串是否相等!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! &#x3D;&#x3D;只能够确定两个字符串是否存放在同一位置上。当然，如果存放在同一位置上，它们必然相等。但是，完全有可能将内容相同的多个字符串副本放置在不同位置上。如果虚拟机始终将相同的字符串共享，就可以使用&#x3D;&#x3D;运算符检测是否相等。但实际上只有字符串字面量是共享的，而+或substring等操作得到的字符串并不共享。因此，千万不要视同&#x3D;&#x3D;运算符测试字符串的相等性！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！7.检查一个字符串既不是null也不是空串 if(str!&#x3D;null &amp;&amp; str.length()!&#x3D;0)。"}]