[{"id":"9d6afd20d8190b4b550aed150e5e2779","title":"Redis入门","content":"NOSQL优点1.解决CPU及内存压力\n\n2.解决IO压力\n\n概述NoSQL(NoSQL &#x3D; Not Only SQL )，意即“不仅仅是SQL”，泛指非关系型的数据库。 \nNoSQL 不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。\n1.不遵循SQL标准。\n2.不支持ACID。\n3.远超于SQL的性能。\nNoSQL适用场景 \n1.对数据高并发的读写\n2.海量数据的读写\n3.对数据高可扩展性的\nNoSQL不适用场景\n1.需要事务支持\n2.基于sql的结构化查询存储，处理复杂的关系,需要即席查询。\n3.（用不着sql的和用了sql也不行的情况，请考虑用NoSq）\n常用五大数据类型Redis键keys *查看当前库所有key  (匹配：keys *1)\nexists key 判断某个key是否存在\ntype key 查看你的key是什么类型\ndel key    删除指定的key数据\nunlink key  根据value选择非阻塞删除\n仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。\nexpire key 10  10秒钟：为给定的key设置过期时间\nttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期\nselect 命令切换数据库\ndbsize 查看当前数据库的key的数量\nflushdb 清空当前库\nflushall 通杀全部库\nRedis字符串(String)简介String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。\nString类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。\nString类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M\n常用命令set  添加键值对\n*NX：当数据库中key不存在时，可以将key-value添加数据库\n*XX：当数据库中key存在时，可以将key-value添加数据库，与NX参数互斥\n*EX：key的超时秒数\n*PX：key的超时毫秒数，与EX互斥\nget  查询对应键值\nappend 将给定的 追加到原值的末尾\nstrlen 获得值的长度\nsetnx 只有在 key 不存在时  设置 key 的值\nincr \n将 key 中储存的数字值增1\n只能对数字值操作，如果为空，新增值为1\ndecr \n将 key 中储存的数字值减1\n只能对数字值操作，如果为空，新增值为-1\nincrby &#x2F; decrby &lt;步长&gt;将 key 中储存的数字值增减。自定义步长。\nmset  ….. \n同时设置一个或多个 key-value对 \nmget  …..\n同时获取一个或多个 value \nmsetnx  ….. \n同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。\n由于原子性，有一个失败则都失败\ngetrange &lt;起始位置&gt;&lt;结束位置&gt;\n获得值的范围，类似java中的substring，前包，后包\nsetrange &lt;起始位置&gt;\n用  覆写所储存的字符串值，从&lt;起始位置&gt;开始(索引从0开始)。\nsetex &lt;过期时间&gt;\n设置键值的同时，设置过期时间，单位秒。\ngetset \n以新换旧，设置了新值同时获得旧值。\nJava 中的 i++ 是原子操作吗？不是原子操作\n所谓原子操作是指不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）\n在单线程中， 能够在单条指令中完成的操作都可以认为是”原子操作”，因为中断只能发生于指令之间在多线程中，不能被其它进程（线程）打断的操作就叫原子操作\nRedis 单命令的原子性主要得益于 Redis 的单线程\n给定 i &#x3D; 0，两个线程分别执行 i++ 100次，值是多少？2~200\n数据结构String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配.\n内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。\nRedis列表(List)简介单键多值\nRedis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。\n它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。\n常用命令lpush&#x2F;rpush  …. 从左边&#x2F;右边插入一个或多个值。\nlpop&#x2F;rpop 从左边&#x2F;右边吐出一个值。值在键在，值光键亡。\nrpop|push 从列表右边吐出一个值，插到列表左边。\nlrange \n按照索引下标获得元素(从左到右)\nlrange mylist 0 -1  0左边第一个，-1右边第一个，（0-1表示获取所有）\nlindex 按照索引下标获得元素(从左到右)\nllen 获得列表长度 \nlinsert  before 在的后面插入插入值\nlrem 从左边删除n个value(从左到右)\nlset将列表key下标为index的值替换成value\n数据结构List的数据结构为快速链表quickList。\n首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。\n它将所有的元素紧挨着一起存储，分配的是一块连续的内存。\n当数据量比较多的时候才会改成quicklist。\n因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。\nRedis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。\n","slug":"Redis入门","date":"2023-01-09T02:59:24.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"de47803b5d69541ea546c3889eeeba14","title":"Java集合框架","content":"集合概述\n概念：对象的容器，定义了对多个对象进项操作的的常用方法。可实现数组的功能。\n和数组的区别：\n\n\n数组长度固定，集合长度不固定。\n数组可以存储基本类型和引用类型，集合只能存储引用类型。\n\n\n位置： java.util.*;\n\nCollection\nCollection父接口\n特点：代表一组任意类型的对象，无序，无下标，不能重复。\n\n方法：\n\nboolean add(Object obj) //添加一个对象。\nboolean addAll(Collection c) //讲一个集合中的所有对象添加到此集合中。\nvoid clear() //清空此集合中的所有对象。\nboolean contains(Object o) //检查此集合中是否包含o对象。\nboolean equals(Object o) //比较此集合是否与指定对象相等。\nboolean isEmpty() //判断此集合是否为空。\nboolean remove(Object o) //在此集合中移除o对象。\nint size() //返回此集合中的元素个数。\nObject[] toArray() //姜此集合转换成数组。\n\n\n\nCollection子接口","slug":"Java集合框架","date":"2022-11-20T08:41:47.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"81ee9368cecd59974c7ff981e1f45f53","title":"面试精选问题","content":"JAVA1.一道关于Integer的面试题1，来，先来一道考题，你看做对了吗？\nInteger i1 &#x3D; new Integer(66);\nInteger i2 &#x3D; new Integer(66);\nSystem.out.println(i1 &#x3D;&#x3D; i2);\nInteger i3 &#x3D; 66;\nInteger i4 &#x3D; 66;\nint i5 &#x3D; 66;\nSystem.out.println(i3 &#x3D;&#x3D; i4);\nSystem.out.println(i3 &#x3D;&#x3D; i5);\n\nInteger i6 &#x3D; 128;\nInteger i7 &#x3D; 128;\nint i8 &#x3D; 128;\nSystem.out.println(i6 &#x3D;&#x3D; i7);\nSystem.out.println(i6 &#x3D;&#x3D; i8);\n大家可以猜测下结果，然后将程序运行起来，验证自己的答案是否正确\n这道题主要考查大家对Integer实现原理的掌握程度\n下面，我给大家对这里的关键原理做解读，相信理解之后，你心中自然有答案了\n答案揭晓\n分情况来比较\n\n都定义为Integer的比较：\n\nnew：一旦new，就是开辟一块新内存，结果肯定是false不new：看范围Integer做了缓存，-128至127，当你取值在这个范围的时候，会采用缓存的对象，所以会相等当不在这个范围，内部创建新的对象，此时不相等\n\nInteger和int的比较：\n\n实际比较的是数值，Integer会做拆箱的动作，来跟基本数据类型做比较此时跟是否在缓存范围内或是否new都没关系\n\n源码分析：\n当我们写Integer i &#x3D; 126,实际上做了自动装箱：Integer i &#x3D; Integer.valueOf(126);分析这段源码\npublic static Integer valueOf(int i) &#123;\n    if (i &gt;&#x3D; IntegerCache.low &amp;&amp; i &lt;&#x3D; IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n&#125;\n&#x2F;&#x2F;IntegerCache是Integer的内部类\nprivate static class IntegerCache &#123;\n    static final int low &#x3D; -128;\n    static final int high;\n    static final Integer cache[];\n    static &#123;\n        &#x2F;&#x2F; high value may be configured by property\n        int h &#x3D; 127;\n    &#x2F;&#x2F;...\n&#125;\n\n2.StringBuffer，StringBuilder开发中如何做选择？\nString是final类型，每次声明的都是不可变的对象，\n所以每次操作都会产生新的String对象，然后将指针指向新的String对象。\nStringBuffer，StringBuilder都是在原有对象上进行操作\n\n所以，如果需要经常改变字符串内容，则建议采用StringBuffer 和 StringBuilder\nStringBuffer是线程安全的，StringBuilder是线程不安全的。线程不安全的StringBuilder性能更高，所以在开发中，优先采用StringBuilder.StringBuilder &gt; StringBuffer &gt; String注意：\n我们在开发中为什么会选择StringBuilder？\n这个要看场景，有同学说可以为了性能放弃安全，这是不对的。\n大家想想，什么情况下需要考虑线程安全的问题？\n\n有一个前提条件就是：多线程访问同一个资源，且有更新操作\n\n所以，只要不是这样的场景，我们就可以放心使用StringBuilder\n而我们在开发中，通常使用StringBuilder在方法内来创建对象和拼接信息，而这种情况是一个线程对应一个StringBuilder对象\n","slug":"面试精选问题","date":"2022-09-26T08:13:25.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"0b1381c4a63c09e41167c5168339035a","title":"JVM","content":"定义： Java Virtual Machine - java程序的运行环境 (java二进制字节码的运行环境)\n好处：\n\n一次编写，到处运行\n自动内存管理，垃圾回收功能\n数据下标越界检查\n多态\n\n比较：\n​\tJRE: Java Runtime Enviroment（）\n\n常见的JVM:\n\n学习路线：\n\n内存结构程序计数器\nProgram Counter Register 程序计数器（寄存器）\n\n作用：​\t用于保存下一条JVM指令的执行地址地址\n特点：​\t1.是线程私有的:\n\nCPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码\n\n程序计数器是每个线程所私有的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令\n\n\n​\t2.不会存在内存溢出\n虚拟机栈定义：\n每个线程运行时所需要的内存，称为虚拟机栈\n每个栈由多个栈帧组成，对应着每次方法调用时所占用的内存\n每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法\n\n 问题辨析：\n1.垃圾回收是否涉及栈内存？\n\n不涉及，因为虚拟机栈是有一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。\n\n2.栈内存的分配越大越好吗？\n\n不是，因为物理内存是一定的，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越来越少\n\n3.方法内的局部变量是否是线程安全的？\n\n如果方法内局部变量没有逃离方法的作用范围，则是线程安全的\n如果局部变量引用了对象，并逃离了方法的作用范围，则需要考虑线程安全问题\n\n栈内存溢出Java.lang.stackOverflowError 栈内存溢出\n\n栈帧过多导致栈内存溢出（无限递归）\n栈帧过大导致内存溢出\n\n线程运行诊断CPU占用过高\n\nLinux环境下运行某些程序的时候，可能导致CPU的占用过高，这是需要定位占用CPU过高的线程\nps H -en pid, tid, %cpu | grep 刚才通过top查到的进程号 通过ps命令进一步查看是哪个线程占用CPU过高\njstack 进程id 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来对比定位，注意jstack查找出的线程id是16禁止的，需要转换\n\n\n\n迟迟得不到结果\n\n可能发生了死锁\n\n本地方法栈一些带有native关键字的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法\n堆定义通过new关键字，创建的对象都会使用堆内存\n特点\n他是线程共享的，堆中对象都需要考虑线程安全的问题\n有垃圾回收机制\n\n堆内存溢出java.lang.OutofMemoryError ：java heap space\n堆内存诊断1.jps工具\n\n查看当前系统中有哪些java进程\n\n2.jmap工具\n\n查看堆内存占用情况\n\n3.jconsole工具\n\n图形界面的，多功能的监测工具，可以连续监测\n\n4.jvirsalvm\n方法区定义方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。\n\n方法区内存溢出\n1.8以前会导致永久代内存溢出\n1.8之后会导致元空间内存溢出\n\n通过反编译来查看类的信息\n获得对应类的.class文件\n\n在JDK对应的bin目录下运行cmd，也可以在IDEA控制台输入\n\n输入 javac 对应类的绝对路径\nF:\\JAVA\\JDK8.0\\bin&gt;javac F:\\Thread_study\\src\\com\\nyima\\JVM\\day01\\Main.javaCopy\n\n输入完成后，对应的目录下就会出现类的.class文件\n\n\n\n在控制台输入 javap -v 类的绝对路径\njavap -v F:\\Thread_study\\src\\com\\nyima\\JVM\\day01\\Main.classCopy\n\n然后能在控制台看到反编译以后类的信息了\n\n\n运行时常量池\n常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息\n运行时常量池，常量池是*.class文件中的，当该类被加载，他的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址\n\n","slug":"JVM","date":"2022-07-28T00:37:05.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"5bf9428aa95fdc2b26bf23a606aad789","title":"SSM","content":"spring官网\nSpring\nSpring Framework是Spring生态圈中最基础的项目，是其他项目的根基\n\n\n学习路线\n核心容器的核心概念\n代码书写现状\n\n代码耦合度高\n\n\n解决方案\n\n使用对象时，在程序中不要主动使用new产生对象，转换为由外部提供对象\n\n\nIoC(Inversion of Control) 控制反转\n\n对象的创建控制权由程序转移到外部，这种思想称为控制反转\n目标：解耦\n\n\nSpring技术对IoC思想进行了实现\n\nSpring提供了一个容器，称为IoC容器，用来充当IoC思想的外部\nIoC容器负责对象的创建、初始化等一系列工作，被创建或被管理的对象在IoC容器中统称为Bean\n\n\nDI(Dependency Injection)依赖注入\n\n在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入\n\n\n\n\n本节总结：\n\n目标：充分解耦\n在IoC容器中管理bean（IoC）\n在IoC容器内将有依赖关系的bean进行关系绑定（DI）\n\n\n最终效果\n使用对象时不仅可以直接从IoC容器中获取，并且获取的bean已经绑定了所有的依赖关系\n\n\n\nIoC入门案例思路分析 1.管理什么？(Service与Dao)\n2.如何将被管理的对象告知IoC容器？(配置)\n3.被管理的对象交给IoC容器，如何获取到IoC容器？(接口)\n4.IoC容器得到后，如何从容器中获取bean？(接口方法)\n5.使用Spring时怎么导入坐标(pom.xml)\n使用步骤：\n1.导jar包\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;5.2.10.RELEASE&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n2.定义spring管理的类（接口）\n3.创建Spirng配置文件，配置对应类作为Spring管理的bean\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;\n\n    &lt;bean id&#x3D;&quot;bookDaoBean&quot; class&#x3D;&quot;com.itheima.dao.impl.BookDaoImpl&quot;&#x2F;&gt;\n    &lt;bean id&#x3D;&quot;bookServiceBean&quot; class&#x3D;&quot;com.itheima.service.impl.BookServiceImpl&quot;&#x2F;&gt;\n&lt;&#x2F;beans&gt;\n\n注意事项：bean定义式id属性在同一个上下文中不能重复\n4.初始化IoC容器，通过容器获取bean\nApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);\n\n需要获取的对象的类型 bookDao &#x3D; (需要获取的对象类型)applicationContext.getBean(&quot;bookDaoBean&quot;);\n\napplicationContext.getBean(“”)获取的是一个Object类型的对象，应对其进行强制类型转换\nDI入门案例1.基于IoC管理bean\n2.Service中使用new形式创建的Dao对象是否保留？(否)\n3.Service中需要的Dao对象如何进入到Service中？(提供方法)\n4.Service与Dao间的关系如何描述？(配置)\n使用步骤：\n1.删除使用new的形式创建对象的代码\nprivate BookDao bookDao &#x3D; new BookDaoImpl();\npublic void save(){    System.out.println(“book service 。。。”);    bookDao.save();}\n2.提供依赖对象对应的setter方法\npublic class BookServiceImpl implements BookService &#123;\n\n    private BookDao bookDao;\n\n    public void save()&#123;\n        System.out.println(&quot;book service 。。。。。。&quot;);\n        bookDao.save();\n    &#125;\n\n    public void setBookDao(BookDao bookDao) &#123;\n        this.bookDao &#x3D; bookDao;\n    &#125;\n&#125;\n\n3.配置service与dao之间的关系\n&lt;bean id&#x3D;&quot;bookServiceBean&quot; class&#x3D;&quot;com.itheima.service.impl.BookServiceImpl&quot;&gt;\n        &lt;property name&#x3D;&quot;bookDao&quot; ref&#x3D;&quot;bookDaoBean&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n&#x2F;&#x2F; property 标签中 name是 id&#x3D;&quot;bookServiceBean&quot;对象里属性的名称   ref则是bean对象的名称\n\nbean基础配置别名配置姓名：name\n类型：属性\n所属：bean标签\n范例\n&lt;bean id&#x3D;&quot;bookServiceBean&quot; name&#x3D;&quot;FirstBean,SecondBean&quot; class&#x3D;&quot;com.itheima.service.impl.BookServiceImpl&quot;&gt;\n        &lt;property name&#x3D;&quot;bookDao&quot; ref&#x3D;&quot;bookDaoBean&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n\n注意事项\n获取bean无论是通过id还是name获取，如果无法获取到，将抛出异常NoSuchBeanDefinitionException\nNoSuchBeanDefinitionException: No bean named ‘bookServiceImpl’ available\nbean作用范围说明\n可见，Spring默认给我们创建的bean是一个单例模式，\n我们可以通过在 bean标签中设置属性 scope&#x3D;”prototype”来讲bean设置成非单例\n\n适合交给容器进行管理的bean\n表现层对象\n业务层对象\n数据层对象\n工具对象\n\n\n不适合交给容器进行管理的bean\n封装实体的域对象\n\n\n\n单例bean与原型bean的区别单例bean：如果一个bean被声明为单例的时候，在处理多次请求的时候在Spring容器里只实例化出一个bean，后续的请求都公用这个对象，这个对象会保存在一个map里面。当有请求来的时候会先从缓存(map)里查看有没有，有的话直接使用这个对象，没有的话才实例化一个新的对象，所以这是个单例的。（ThreadLocal ）创建完后，后面都会复用这个bean\n原型(prototype)bean来说当每次请求来的时候直接实例化新的bean，没有缓存以及从缓存查的过程。\n结论：\n单例的bean只有第一次创建新的bean 后面都会复用该bean，所以不会频繁创建对象。\n原型的bean每次都会新创建\n单例bean的优势由于不会每次都新创建新对象所以有一下几个性能上的优势：\n1.减少了新生成实例的消耗新生成实例消耗包括两方面，第一，Spring会通过反射或者cglib来生成bean实例这都是耗性能的操作，其次给对象分配内存也会涉及复杂算法。\n2.减少jvm垃圾回收由于不会给每个请求都新生成bean实例，所以自然回收的对象少了。\n3.可以快速获取到bean因为单例的获取bean操作除了第一次生成之外其余的都是从缓存里获取的所以很快。\n单例bean的劣势单例的bean一个很大的劣势就是他不能做到线程安全！！！尤其是高并发情况下。\n由于所有请求都共享一个bean实例，所以这个bean要是有状态的一个bean的话可能在并发场景下出现问题，而原型的bean则不会有这样问题（但也有例外，比如他被单例bean依赖），因为给每个请求都新创建实例。\nbean实例化的三种方式构造方法（常用）\nbean本质上就是对象，创建bean使用构造方法完成\n\npublic class BookDaoImpl implements BookDao &#123;\n\n&#x2F;&#x2F;    private BookDaoImpl()&#123;\n&#x2F;&#x2F;        System.out.println(&quot;book dao struct is running......&quot;);\n&#x2F;&#x2F;    &#125;\n    public void save() &#123;\n        System.out.println(&quot;BookDao 我他吗来啦&quot;);\n    &#125;\n&#125;\n\n\n\n\n提供可访问的构造方法\n\n&lt;bean id&#x3D;&quot;bookDaoBean&quot; class&#x3D;&quot;com.itheima.dao.impl.BookDaoImpl&quot;&#x2F;&gt;\n\n静态工厂（了解）\n实例工厂\nFactoryBean（实用）\nbean生命周期\n生命周期：从创建到销毁的完整过程\nbean生命周期控制：在bean创建后到销毁前做一些事情\n\n\n接口控制（了解）\n\nbean生命周期\n初始化容器\n1.创建对象（内存分配）\n2.执行构造方法\n3.执行属性注入（set操作）\n4.执行bean初始化方法\n\n使用bean\n1.执行业务操作\n\n关闭&#x2F;销毁容器\n1.执行bean销毁方法\n\n\nbean销毁时机\n容器关闭前触发bean的销毁\n\n关闭容器方式：\n\n手工关闭容器\nConfigurableApplicationContext接口close（）方法\n\n注册关闭钩子，在虚拟机退出前先关闭容器再退出虚拟机\nConfigurableApplicationContext接口registerShutdownHook（）操作\n\n\n\n\n依赖注入方式\n思考：向一个类中传递数据的方式有几种？\n\n普通方法（set方法）\n构造方法\n\n\n思考：依赖注入描述了在容器中简历bean与bean之间依赖关系的过程，如果bean运行需要的是数据或字符串呢？\n\nsetter注入\n\n简单类型\n\n\n引用类型\n\n\n\n\n构造器注入\n\n简单类型\n\n\n引用类型\n\n\n\n\n\n依赖注入方式选择1.强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现\n2.可选依赖使用setter注入进行，灵活性强\n3.Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨\n4.如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入\n5.实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入\n6.自己开发的模块推荐使用setter注入\n自动装配\nIoC容器根据bean所以来的资源在容器中自动查找并注入到bean中的过程称为自动装配\n\n自动装配方式\n\n按类型（常用）\n按名称\n按构造方法\n不启用自动装配\n\n\n配种中使用bean标签autowire\n\n\n\n\n自动装配用于引用类型依赖注入，不能对简单类型进行操作\n使用按类型装配时(byType)必须保障容器中想同类型的bean唯一，推荐使用\n使用按名称装配时(byName)必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用\n自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效\n\n集合注入数组，List，Set，Map,Properties\nbean所依赖的实现类\npublic class BookDaoImpl implements BookDao &#123;\n\n    private int[] array;\n\n    private List&lt;String&gt; list;\n\n    private Set&lt;String&gt; set;\n\n    private Map&lt;String,String&gt; map;\n\n    private Properties properties;\n\n\n\n\n    public void setArray(int[] array) &#123;\n        this.array &#x3D; array;\n    &#125;\n\n    public void setList(List&lt;String&gt; list) &#123;\n        this.list &#x3D; list;\n    &#125;\n\n    public void setSet(Set&lt;String&gt; set) &#123;\n        this.set &#x3D; set;\n    &#125;\n\n    public void setMap(Map&lt;String, String&gt; map) &#123;\n        this.map &#x3D; map;\n    &#125;\n\n    public void setProperties(Properties properties) &#123;\n        this.properties &#x3D; properties;\n    &#125;\n\n\n\n\n    public void save() &#123;\n        System.out.println(&quot;book dao save ...&quot;);\n\n        System.out.println(&quot;遍历数组:&quot; + Arrays.toString(array));\n\n        System.out.println(&quot;遍历List&quot; + list);\n\n        System.out.println(&quot;遍历Set&quot; + set);\n\n        System.out.println(&quot;遍历Map&quot; + map);\n\n        System.out.println(&quot;遍历Properties&quot; + properties);\n    &#125;\n&#125;\n\napplicationContext.xml\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;\n    &lt;bean id&#x3D;&quot;bookDao&quot; class&#x3D;&quot;com.itheima.dao.impl.BookDaoImpl&quot;&gt;\n        &lt;!--数组注入--&gt;\n        &lt;property name&#x3D;&quot;array&quot;&gt;\n            &lt;array&gt;\n                &lt;value&gt;100&lt;&#x2F;value&gt;\n                &lt;value&gt;200&lt;&#x2F;value&gt;\n                &lt;value&gt;300&lt;&#x2F;value&gt;\n            &lt;&#x2F;array&gt;\n        &lt;&#x2F;property&gt;\n        &lt;!--list集合注入--&gt;\n        &lt;property name&#x3D;&quot;list&quot;&gt;\n            &lt;list&gt;\n                &lt;value&gt;itcast&lt;&#x2F;value&gt;\n                &lt;value&gt;itheima&lt;&#x2F;value&gt;\n                &lt;value&gt;boxuegu&lt;&#x2F;value&gt;\n                &lt;value&gt;chuanzhihui&lt;&#x2F;value&gt;\n            &lt;&#x2F;list&gt;\n        &lt;&#x2F;property&gt;\n        &lt;!--set集合注入--&gt;\n        &lt;property name&#x3D;&quot;set&quot;&gt;\n            &lt;set&gt;\n                &lt;value&gt;itcast&lt;&#x2F;value&gt;\n                &lt;value&gt;itheima&lt;&#x2F;value&gt;\n                &lt;value&gt;boxuegu&lt;&#x2F;value&gt;\n                &lt;value&gt;boxuegu&lt;&#x2F;value&gt;\n            &lt;&#x2F;set&gt;\n        &lt;&#x2F;property&gt;\n        &lt;!--map集合注入--&gt;\n        &lt;property name&#x3D;&quot;map&quot;&gt;\n            &lt;map&gt;\n                &lt;entry key&#x3D;&quot;country&quot; value&#x3D;&quot;china&quot;&#x2F;&gt;\n                &lt;entry key&#x3D;&quot;province&quot; value&#x3D;&quot;henan&quot;&#x2F;&gt;\n                &lt;entry key&#x3D;&quot;city&quot; value&#x3D;&quot;kaifeng&quot;&#x2F;&gt;\n            &lt;&#x2F;map&gt;\n        &lt;&#x2F;property&gt;\n        &lt;!--Properties注入--&gt;\n        &lt;property name&#x3D;&quot;properties&quot;&gt;\n            &lt;props&gt;\n                &lt;prop key&#x3D;&quot;country&quot;&gt;china&lt;&#x2F;prop&gt;\n                &lt;prop key&#x3D;&quot;province&quot;&gt;henan&lt;&#x2F;prop&gt;\n                &lt;prop key&#x3D;&quot;city&quot;&gt;kaifeng&lt;&#x2F;prop&gt;\n            &lt;&#x2F;props&gt;\n        &lt;&#x2F;property&gt;\n    &lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;\n\n\n第三方资源配置管理\n导入druid坐标\n&lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;1.1.16&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n\n配置数据源对象作为spring管理的bean\n&lt;bean class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;\n        &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;spring_db&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n加载properties文件由于上次学习将数据库的用户名，密码，全配置在applicationContext.xml之中，非常的危险，故应该使用properties文件记录数据库信息\n1.开启context命名空间\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xsi:schemaLocation&#x3D;&quot;\n            http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n            http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n            http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context\n            http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd\n            &quot;&gt;\n    &lt;!--  将含有beans的代码复制一份并用context替换beans--&gt;\n\n\n\n2.使用context空间加载properties文件\n&lt;context:property-placeholder location&#x3D;&quot;classpath*:*.properties&quot; system-properties-mode&#x3D;&quot;NEVER&quot;&#x2F;&gt;\n\n\n\n\n使用属性占位符${}读取properties文件中的属性\n\n&lt;bean class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;\n        &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;$&#123;jdbc.Driver&#125;&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n4.自己配置的 jdbc.properties文件内容\njdbc.driver&#x3D;com.mysql.jdbc.Driver\njdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;spring_db\njdbc.username&#x3D;root\njdbc.password&#x3D;root\n\n\n容器创建容器\n获取bean\n容器类结构层次\nBeanFactory\n类路径加载配置文件\n\n\n核心容器总结\nBeanFactory是IoC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载\nApplicationContext接口是Spring容器的核心接口，初始化时bean立即加载\nApplicationContext接口提供基础的bean操作相关方法，通过其他接口扩展其功能\nApplicationContext接口常用初始化类\nClassPathXmlApplicationContext\nFileSystemXmlApplicationContext\n\n\n\nbean相关\n依赖注入相关\n注解开发注解开发定义bean\n\n同时这几个注解后面也可以添加一些参数，比如比较常用的一个是注解的括号中加value属性，来表示这个组件在容器中的ID，如果不设置value值时，默认的ID是类名的全称（第一个字母小写）。\n在这里有一点需要注意：事实上Spring并没有能力识别一个组件到底是不是它所标记的类型，即使将@Respository注解用在一个表述层控制器组件上面也不会产生任何错误，所以@Respository、@Service、@Controller这几个注解仅仅是为了让开发人员自己明确当前的组件扮演的角色。方便将组件加入到容器中去。\n纯注解开发\nSpring3.0升级了纯注解开发模式，使用java类替代配置文件，开启了Spring快速开发赛道\n\n读取Spring核心配置文件初始化容器对象切换为读取Java配置类初始化容器对象\n&#x2F;&#x2F;加载配置文件初始化容器\nApplicationContext ctx &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);\n&#x2F;&#x2F;加载配置类初始化容器    \nApplicationContext ctx &#x3D; new AnnotationConfigApplicationContext(SpringConfig.class);\n\n\n\n\n\n\n\nJava类替代Spring核心配置文件\n\n\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xsi:schemaLocation&#x3D;&quot;\n        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;\n\n    &lt;context:component-scan base-package&#x3D;&quot;com.itheima&quot;&#x2F;&gt;\n\n&lt;&#x2F;beans&gt;\n\n\n&#x2F;&#x2F;配置文件被替换为\n\n\n&#x2F;&#x2F;声明当前类为Spring配置类\n@Configuration\n&#x2F;&#x2F;设置bean扫描路径，多个路径书写为字符串数组格式\n@ComponentScan(&#123;&quot;com.itheima.service&quot;,&quot;com.itheima.dao&quot;&#125;)\npublic class SpringConfig &#123;\n&#125;\n\n\n\n@Configuration注解用于设定当前类为配置类\n\n@ComponentScan注解用于设定扫描路径，次注解只能添加一次，多个数据请用数组格式\n@ComponentScan(&#123;&quot;com.itheima.service&quot;,&quot;com.itheima.dao&quot;&#125;)\n\n注解开发小结1.定义bean\n\n@Component\n@Controller\n@Service\n@Repository\n\n\n&lt;context:component-scan&#x2F;&gt;\n\n2.纯注解开发\n\n@Configuration\n@ComponentScan\nAnnotationConfigApplicationContext\n\nbean作用范围与生命周期管理\n使用@Scope定义bean作用范围\n\n@Repository\n@Scope(&quot;singleton&quot;)\npublic class BookDaoImpl implements BookDao&#123;\n&#125;\n\n使用@PostConstruct、@PreDestroy定义bean生命周期\n@Repository\n@Scope(&quot;singleton&quot;)\npublic class BookDaoImpl implements BookDao&#123;\n\tpublic BookDaoImpl()&#123;\n\t\tSystem.out.println(&quot;book dao constructor ...&quot;);\n\t&#125;\n    @PostConstruct\n    public void init()&#123;\n        System.out.println(&quot;book init ...&quot;);\n    &#125;\n    @PreDestroy\n    public void destroy()&#123;\n        System.out.println(&quot;book destroy ...&quot;)\n    &#125;\n&#125;\n\n依赖注入\n使用@Autowired注解开发自动装配模式(按类型)\n\n@Service\npublic class bookServiceImpl implements BookService&#123;\n\t@Autowired\n\tprivate BookDao bookDao;\n\t\n\tpublic void save()&#123;\n\t\tSystem.out.println(&quot;book service save ...&quot;);\n\t\tbookDao.save();\n\t&#125;\n&#125;\n\n\n注意：自动装配基于反射设计创建对象并暴力反射对应属性为私有属性初始化数据，隐藏无需提供setter方法\n注意：自动装配建议使用无参构造方法创建对象(默认)，如果不提供对应构造对象，请提供唯一的构造方法\n\n\n\n使用@Qualifier注解开启指定名称装配bean\n\n@Service\npublic class BookServiceImpl implements BookService &#123;\n    &#x2F;&#x2F;@Autowired：注入引用类型，自动装配模式，默认按类型装配\n    @Autowired\n    &#x2F;&#x2F;@Qualifier：自动装配bean时按bean名称装配\n    @Qualifier(&quot;bookDao&quot;)\n    private BookDao bookDao;\n\n    public void save() &#123;\n        System.out.println(&quot;book service save ...&quot;);\n        bookDao.save();\n    &#125;\n&#125;\n\n\n注意：@Qualifier注解无法单独使用，必须配合@Autowired注解使用\n\n\n\n使用@Value实现简单类型注入\n\n@Repository(&quot;bookDao&quot;)\npublic class BookDaoImpl implements BookDao &#123;\n    &#x2F;&#x2F;@Value：注入简单类型（无需提供set方法）\n    @Value(&quot;Hello World&quot;)\n    private String name;\n\n    public void save() &#123;\n        System.out.println(&quot;book dao save ...&quot; + name);\n    &#125;\n&#125;\n\n\n加载properties文件\n使用@PropertySource注解加载properties文件\n\n@Configuration\n@ComponentScan(&quot;com.itheima&quot;)\n@PropertySource(&quot;classpath:jdbc.properties&quot;)\npublic class SpringConfig&#123;\n&#125;\n\n\n注意：路径仅支持单一文件配置，多文件请使用数组格式配置，不允许使用通配符*\n\n第三方bean第三方bean管理\n使用@bean配置第三方bean\n\n@Configuration\npublic class SpringConfig &#123;\n\n    @Bean\n    public DataSource dataSource()&#123;\n        DruidDataSource ds &#x3D; new DruidDataSource();\n        ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);\n      \tds.setUrl(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;spring_db&quot;);\n        ds.setUsername(&quot;root&quot;);\n        ds.setPassword(&quot;1234&quot;);\n        return ds;\n    &#125;\n&#125;\n\n\n\n建议使用方式一，因为方式二看不出你用过哪些配置类\n第三方bean依赖注入\n简单类型依赖注入\n\npublic class JdbcConfig &#123;\n    &#x2F;&#x2F;1.定义一个方法获得要管理的对象\n    @Value(&quot;com.mysql.jdbc.Driver&quot;)\n    private String driver;\n    @Value(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;spring_db&quot;)\n    private String url;\n    @Value(&quot;root&quot;)\n    private String userName;\n    @Value(&quot;root&quot;)\n    private String password;\n    &#x2F;&#x2F;2.添加@Bean，表示当前方法的返回值是一个bean\n    &#x2F;&#x2F;@Bean修饰的方法，形参根据类型自动装配\n    @Bean\n    public DataSource dataSource(BookDao bookDao)&#123;\n        System.out.println(bookDao);\n        DruidDataSource ds &#x3D; new DruidDataSource();\n        ds.setDriverClassName(driver);\n        ds.setUrl(url);\n        ds.setUsername(userName);\n        ds.setPassword(password);\n        return ds;\n    &#125;\n&#125;\n\n\n引用类型依赖注入\n\n@Bean\n   public DataSource dataSource(BookDao bookDao)&#123;\n       System.out.println(bookDao);\n       DruidDataSource ds &#x3D; new DruidDataSource();\n       ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);\n       ds.setUrl(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;spring_db&quot;);\n       ds.setUsername(&quot;root&quot;);\n       ds.setPassword(&quot;1234&quot;);\n       return ds;\n   &#125;\n\n引用类型注入只需要为bean定义方法设置形参即可，容器会根据类型自动装配对象\n注解开发总结XML配置对比注解配置\nSpring整合mybatis\n![](https://raw.githubusercontent.com/2295237514/image/main/20220802102956.png\n\nSpring应该管理的bean是SqlsessionFactory\n\n\nSpring整合junit&#x2F;&#x2F;设置类运行器\n@RunWith(SpringJUnit4ClassRunner.class)\n&#x2F;&#x2F;设置Spring环境对应的配置类\n@ContextConfiguration(classes &#x3D; SpringConfig.class)\npublic class AccountServiceTest &#123;\n    &#x2F;&#x2F;支持自动装配注入bean\n    @Autowired\n    private AccountService accountService;\n    @Test\n    public void testFindById()&#123;\n        System.out.println(accountService.findById(1));\n\n    &#125;\n&#125;\n\nAOP\nAOP(Aspect Oriented Programming)面向切面编程，一种编程范式，指导开发者如何组织程序结构\n\nOOP（Object Oriented Programming）面向对象编程\n\n\n作用：在不惊动原始设计的基础上为其进行功能增强\n\nSpring理念：无入侵式&#x2F;无侵入式\n\n\nAOP核心概念\n连接点(JoinPoint):程序执行过程中的任意位置，粒度为执行方法、抛出异常、设置变量等\n在SpringAop中，理解为方法的执行\n\n\n切入点（Pointcut）：匹配连接点的式子\n在SpringAOP中，一个切入点可以只描述一个具体方法，也可以匹配多个方法\n一个具体方法\n匹配多个方法：所有的save方法，所有的get开头的方法，所有以D奥结尾的接口中的任意方法，所有带有一个参数的方法\n\n\n\n\n通知（Advice）：在切入点处执行的操作，也就是共性功能\n在SpringAOP中，功能最终以方法的形式呈现\n\n\n通知类：定义通知的类\n切面(Aspect)：描述通知与切入点的对应关系\n目标对象（Target）：原始功能去掉共性功能对应的类产生的对象，这种对象是无法完成最终工作的\n代理（Proxy）：目标对象无法直接完成工作，需要对其进行功能回填，通过原始对象的代理对象实现\n\nAOP入门案例思路分析开发模式：XML 或 注解\n思路分析：\n1.导入坐标（pom.xml）\n2.制作连接点方法（原始操作，Dao接口与实现类）\n3.制作共性功能（通知类与通知）\n4.定义切入点\n5.绑定切入点与通知关系（切面）\n步骤1.导入aop相关坐标\n&lt;dependency&gt;\n      &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt;\n      &lt;artifactId&gt;aspectjweaver&lt;&#x2F;artifactId&gt;\n      &lt;version&gt;1.9.4&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n\n2.定义dao接口与实现类\npublic interface BookDao &#123;\n    public void save();\n    public void update();\n&#125;\n\n@Repository\npublic class BookDaoImpl implements BookDao &#123;\n\n    public void save() &#123;\n        System.out.println(System.currentTimeMillis());\n        System.out.println(&quot;book dao save ...&quot;);\n    &#125;\n\n    public void update()&#123;\n        System.out.println(&quot;book dao update ...&quot;);\n    &#125;\n&#125;\n\n3.定义通知类和切入点\n说明：切入点定义依托一个不具有实际意义的方法进行，即无参数，无返回值，方法体无实际逻辑,\n4.最后绑定切入点与通知关系，并指定通知添加到原始连接点的具体执行位置\n5.定义通知类受Spring容器管理，并定义当前类为切面类\n@Component\n&#x2F;&#x2F;设置当前类为切面类类\n@Aspect\npublic class MyAdvice &#123;\n    &#x2F;&#x2F;设置切入点，要求配置在方法上方\n    @Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)\n    private void pt()&#123;&#125;\n\n    &#x2F;&#x2F;设置在切入点pt()的前面运行当前操作（前置通知）\n    &#x2F;&#x2F; @Before(&quot;pt()&quot;)\n    public void method()&#123;\n        System.out.println(System.currentTimeMillis());\n    &#125;\n&#125;\n\n6.开启Spring对AOP注解驱动支持\n@Configuration\n@ComponentScan(&quot;com.itheima&quot;)\n&#x2F;&#x2F;开启注解开发AOP功能\n@EnableAspectJAutoProxy\npublic class SpringConfig &#123;\n&#125;\n\nAOP工作流程1.Spring容器启动\n2.读取所有切面配置中的切入点\n3.初始化bean，判定bean对应的类中的方法是否匹配到任意切入点\n\n匹配失败，创建对象\n匹配成功，创建原始对象(目标对象)的代理对象\n\n4.获取bean执行方法\n\n获取bean，调用方法并执行，完成操作\n获取的bean是代理对象时，根据代理对象的运行模式运行原始方法与增强的内容，完成操作\n\nAOP切入点表达式\n切入点：要进行增强的方法\n切入点表达式：要进行增强的方法的描述方法\n\n\n\n切入点表达式标准格式：动作关键字(访问修饰符 返回值 包名.类&#x2F;接口名.方法名(参数)异常名)\n\nexecution(public User com.itheima.service.UserService.findById(int))\n\n\n动作关键字：描述切入点的行为动作，例如execution表示执行到指定切入点\n访问修饰符：public，private等，可以省略\n返回值\n包名\n类&#x2F;接口名\n方法名\n参数\n异常名：方法定义中抛出指定异常，可以省略\n\n\n*****：必有最少一个\n..:可以没有，也可以有任意个\n书写技巧\n所有代码按照规范标准开发，否则以下技巧全部失效\n\n描述切入点通常描述接口，而不描述实现类\n\n访问控制修饰符针对接口开发均采用public描述(可省略访问控制修饰符描述)\n\n返回值类型对于增删改类使用精准类型加速匹配，对于查询类使用*通配快速描述\n\n包名书写尽量不使用**..*匹配，效率过低，常用做单个包描述匹配，或精准匹配\n\n接口名&#x2F;类型书写名称与模块相关的采用*匹配，例如UserService书写成*Service，绑定业务层接口\n\n方法名书写以动词进行精准匹配，名次采用*匹配，例如getById书写成getBy*\n\n参数规则较为复杂，根据业务方法灵活调整\n\n通常不适用异常作为匹配规则\n\n\nAOP通知类型\nAOP通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置\n\nAOP通知共分为5种类型\n\n前置通知 @Before\n后置通知 @After\n环绕通知（重点） @Around\n\n\n\n返回后通知（了解）@AfterReturning\n抛出异常后通知（了解）@AfterThrowing\n\n\n\n案例：测量业务层接口执行效率@Component\n@Aspect\npublic class ProjectAdvice &#123;\n    &#x2F;&#x2F;匹配业务层的所有方法\n    @Pointcut(&quot;execution(* com.itheima.service.*Service.*(..))&quot;)\n    private void servicePt()&#123;&#125;\n\n    &#x2F;&#x2F;设置环绕通知，在原始操作的运行前后记录执行时间\n    @Around(&quot;ProjectAdvice.servicePt()&quot;)\n    public void runSpeed(ProceedingJoinPoint pjp) throws Throwable &#123;\n        &#x2F;&#x2F;获取执行的签名对象\n        Signature signature &#x3D; pjp.getSignature();\n        String className &#x3D; signature.getDeclaringTypeName();\n        String methodName &#x3D; signature.getName();\n\n        long start &#x3D; System.currentTimeMillis();\n        for (int i &#x3D; 0; i &lt; 10000; i++) &#123;\n           pjp.proceed();\n        &#125;\n        long end &#x3D; System.currentTimeMillis();\n        System.out.println(&quot;万次执行：&quot;+ className+&quot;.&quot;+methodName+&quot;----&gt;&quot; +(end-start) + &quot;ms&quot;);\n    &#125;\n&#125;\n\nAOP通知获取数据\n获取切入点方法的参数、\nJoinPoint：适用于前置、后置、返回后、抛出异常后通知\nProceedJoinPoint：适用于环绕通知\n\n\n\n获取切入点方法返回值\n返回后通知\n环绕通知\n\n\n\n获取切入点方法运行异常信息\n抛出异常后通知\n环绕通知\n\n\n\n\nAOP总结\n概念：AOP面向切面编程，一种编程范式\n\n作用：在不惊动原始设计的基础上为方法进行功能增强\n\n核心概念：\n\n代理：SpringAOP的核心本质是采用代理模式实现的\n\n连接点：在SpringAOP中，理解为任意方法的执行\n\n切入点：匹配连接点的式子，也是具有共性功能的方法描述\n\n切入点表达式标准格式：动作关键字（访问修饰符  返回值  包名.类&#x2F;接口名.方法名（参数）异常名）\n\nexecution(* com.itheima.service.*Service.*(..))\n\n\n切入点表达式描述通配符：\n\n作用：用于快速描述，范围描述\n*：匹配任意符号（常用）\n..：匹配多个连续的任意符号(常用)\n+：匹配子类类型\n\n\n切入点表达式书写技巧\n1.按标准规范开发\n2.查询操作的返回值建议使用*匹配\n3.减少使用..的形式描述包\n4.对接口进行描述，使用*表示模块名，例如UserService的匹配描述为*Service\n5.方法名书写保留动词，例如get,使用*表示名词，例如getById匹配描述为*getBy*\n6.参数根据实际情况灵活调整\n\n\n\n通知：若干个方法的共性功能，在切入点处执行，具体体现为一个方法\n\n环绕通知：\n环绕通知依赖形参ProceedingJoinPoint才能实现对原始方法的调用\n环绕通知可以隔离原始方法的调用执行\n环绕通知返回值设置为Object类型\n环绕通知中可以对原始方法调用过程中出现的异常进行处理\n\n\n\n\n切面：描述通知与切入点的对应关系\n\n目标对象：被代理的原始对象称为目标对象\n\n\n\n\n事务\nSpirng事务作用：在数据层或业务层保障一系列的数据库操作同成功同失败\n\n案例：银行账户转账1.在业务层接口上添加Spring事务管理\npublic interface AccountService&#123;\n\t@Transactional\n\tpublic void transfer(String out,String in,Double money);\n&#125;\n\n注意事项\n\nSpring注解式事务通常添加在业务层接口中而不会添加到业务层实现类中，降低耦合\n\n注解式事务可以添加到业务方法上表示当前方法开启事务，也可以添加到接口上表示当前接口所有方法开启事务\n\n\n2.设置事务管理器\n@Bean\npublic PlatformTransactionManager transactionManager(DataSource dataSource)&#123;\n\tDataSourceTransactionManager ptm &#x3D; new DataSourceTransactionManager();\n\tptm.setDataSource(dataSource);\n    return ptm;\n&#125;\n\n注意事项\n\n事务管理器要根据实现技术进行选择\n\nMyBatis框架使用的是JDBC事务\n\n\n3.开启注解式事务驱动\n@Configuration\n@ComponentScan(&quot;com.itheima&quot;)\n@PropertySource(&quot;classpath:jdbc.properties&quot;)\n@Import(&#123;JdbcConfig.class,MybatisConfig.class&#125;)\n&#x2F;&#x2F;开启注解式事务驱动\n@EnableTransactionManagement\npublic class SpringConfig &#123;\n&#125;\n\nSpring事务角色\n事务管理员：发起事务方，在Spring中通常指代业务层开启事务的方法\n事务协调员：加入事务方，在Spring中通常代指数据层方法，也可以是业务层方法\n\n事务相关配置\n有些异常默认事务不回滚，如IOEXCEPTION需手动设置\troolbackFor属性\n案例：转账业务追加日志1.在业务层接口上添加Spring事务，设置事务传播行为REQUIRES_NEW(需要新事物)\n@Service\npublic class LogServiceImpl implements LogService &#123;\n\n    @Autowired\n    private LogDao logDao;\n\t\n    @Transactional(propagation &#x3D; Propagation.REQUIRES_NEW)\n    public void log(String out,String in,Double money ) &#123;\n        logDao.log(&quot;转账操作由&quot;+out+&quot;到&quot;+in+&quot;,金额：&quot;+money);\n    &#125;\n&#125;\n\n事务传播行为\nSpringMVC\nSpringMVC技术与Servlet技术功能等同，均属于web层开发技术\nSpringMVC是一种基于java实现MVC模型的轻量级Web框架\n优点\n使用简单，开发便捷（相比于Servlet）\n灵活性强\n\n\n\n学习目标：\n1.掌握基于SpringMVC获取请求参数与响应json数据操作\n2.熟练应用基于REST风格的请求路径设置与参数传递\n3.能够根据实际业务简历前后端开发通讯协议并进行实现\n4.基于SSM整合技术开发任意业务模块功能\nSpringMVC入门案例1.使用SpringMVC技术需要先导入SpringMVC坐标与Servlet坐标\n&lt;dependency&gt;\n      &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;\n      &lt;artifactId&gt;javax.servlet-api&lt;&#x2F;artifactId&gt;\n      &lt;version&gt;3.1.0&lt;&#x2F;version&gt;\n      &lt;scope&gt;provided&lt;&#x2F;scope&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n      &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n      &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;\n      &lt;version&gt;5.2.10.RELEASE&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n2.创建SpringMVC控制器类（等同于Servlet功能）\n@Controller\npublic class UserController &#123;\n\n    @RequestMapping(&quot;&#x2F;save&quot;)\n    @ResponseBody\n    public String save()&#123;\n        System.out.println(&quot;user save ...&quot;);\n        return &quot;&#123;&#39;info&#39;:&#39;springmvc&#39;&#125;&quot;;\n    &#125;\n&#125;\n\n3.初始化SpringMVC环境（同Spring环境），设定SpringMVC加载对应的bean\n@Configuration\n@ComponentScan(&quot;com.itheima.controller&quot;)\npublic class SpringMvcConfig&#123;\n\n&#125;\n\n\n知识点1：@Controller\n\n\n\n\n名称\n@Controller\n\n\n\n类型\n类注解\n\n\n位置\nSpringMVC控制器类定义上方\n\n\n作用\n设定SpringMVC的核心控制器bean\n\n\n\n知识点2：@RequestMapping\n\n\n\n\n名称\n@RequestMapping\n\n\n\n类型\n类注解或方法注解\n\n\n位置\nSpringMVC控制器类或方法定义上方\n\n\n作用\n设置当前控制器方法请求访问路径\n\n\n相关属性\nvalue(默认)，请求访问路径\n\n\n\n知识点3：@ResponseBody\n\n\n\n\n名称\n@ResponseBody\n\n\n\n类型\n类注解或方法注解\n\n\n位置\nSpringMVC控制器类或方法定义上方\n\n\n作用\n设置当前控制器方法响应内容为当前返回值，无需解析\n\n\n注意事项\n\nSpringMVC是基于Spring的，在pom.xml只导入了spring-webmvcjar包的原因是它会自动依赖spring相关坐标\nAbstractDispatcherServletInitializer类是SpringMVC提供的快速初始化Web3.0容器的抽象类\nAbstractDispatcherServletInitializer提供了三个接口方法供用户实现\ncreateServletApplicationContext方法，创建Servlet容器时，加载SpringMVC对应的bean并放入WebApplicationContext对象范围中，而WebApplicationContext的作用范围为ServletContext范围，即整个web容器范围\ngetServletMappings方法，设定SpringMVC对应的请求映射路径，即SpringMVC拦截哪些请求\ncreateRootApplicationContext方法，如果创建Servlet容器时需要加载非SpringMVC对应的bean,使用当前方法进行，使用方式和createServletApplicationContext相同。\ncreateServletApplicationContext用来加载SpringMVC环境\ncreateRootApplicationContext用来加载Spring环境\n\n\n\n入门案例工作流程分析\n启动服务器初始化过程\n1.服务器启动，执行ServletContainerInitConfig类，初始化web容器\n2.执行createServletApplicationContext方法，创建了WebApplicationContext对象\n3.加载SpringMvcConfig\n4.执行@ComponentScan加载对应的bean\n5.加载UserController，每个@RequestMapping的名称对应一个具体的方法\n6.执行getServletMappings方法，定义所有的请求都通过SpringMVC\n\n单次请求过程\n1.发送请求localhost&#x2F;save\n2.web容器发现所有请求都经过SpringMVC，将请求交给SpringMVC处理\n3.解析请求路径&#x2F;save\n4.由&#x2F;save匹配执行对应的方法save()\n5.执行save()\n6.检测到有@ResponseBody直接将save()方法的返回值作为响应体返回给请求方\n\n\nbean加载控制\n方式一:修改Spring配置类，设定扫描范围为精准范围。\n@Configuration\n@ComponentScan(&#123;&quot;com.itheima.service&quot;,&quot;comitheima.dao&quot;&#125;)\npublic class SpringConfig &#123;\n&#125;\n\n方式二:修改Spring配置类，设定扫描范围为com.itheima,排除掉controller包中的bean\n@Configuration\n@ComponentScan(value&#x3D;&quot;com.itheima&quot;,\n    excludeFilters&#x3D;@ComponentScan.Filter(\n    \ttype &#x3D; FilterType.ANNOTATION,\n        classes &#x3D; Controller.class\n    )\n)\npublic class SpringConfig &#123;\n&#125;\n\n\nexcludeFilters属性：设置扫描加载bean时，排除的过滤规则\n\n\nbean的加载格式：\npublic class ServletContainersInitConfig extends AbstractDispatcherServletInitializer &#123;\n    protected WebApplicationContext createServletApplicationContext() &#123;\n        AnnotationConfigWebApplicationContext ctx &#x3D; new AnnotationConfigWebApplicationContext();\n        ctx.register(SpringMvcConfig.class);\n        return ctx;\n    &#125;\n    protected String[] getServletMappings() &#123;\n        return new String[]&#123;&quot;&#x2F;&quot;&#125;;\n    &#125;\n    protected WebApplicationContext createRootApplicationContext() &#123;\n      AnnotationConfigWebApplicationContext ctx &#x3D; new AnnotationConfigWebApplicationContext();\n        ctx.register(SpringConfig.class);\n        return ctx;\n    &#125;\n&#125;\n\n对于上述的配置方式，Spring还提供了一种更简单的配置方式，可以不用再去创建AnnotationConfigWebApplicationContext对象，不用手动register对应的配置类，如何实现?\n简化开发的格式\npublic class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123;\n\n    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;\n        return new Class[]&#123;SpringConfig.class&#125;;\n    &#125;\n\n    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;\n        return new Class[]&#123;SpringMvcConfig.class&#125;;\n    &#125;\n\n    protected String[] getServletMappings() &#123;\n        return new String[]&#123;&quot;&#x2F;&quot;&#125;;\n    &#125;\n&#125;\n\n请求与响应请求映射路径优化映射路径\n@Controller\n@RequestMapping(&quot;&#x2F;user&quot;)\npublic class UserController &#123;\n\n    @RequestMapping(&quot;&#x2F;save&quot;)\n    @ResponseBody\n    public String save()&#123;\n        System.out.println(&quot;user save ...&quot;);\n        return &quot;&#123;&#39;module&#39;:&#39;user save&#39;&#125;&quot;;\n    &#125;\n    \n    @RequestMapping(&quot;&#x2F;delete&quot;)\n    @ResponseBody\n    public String save()&#123;\n        System.out.println(&quot;user delete ...&quot;);\n        return &quot;&#123;&#39;module&#39;:&#39;user delete&#39;&#125;&quot;;\n    &#125;\n&#125;\n\n@Controller\n@RequestMapping(&quot;&#x2F;book&quot;)\npublic class BookController &#123;\n\n    @RequestMapping(&quot;&#x2F;save&quot;)\n    @ResponseBody\n    public String save()&#123;\n        System.out.println(&quot;book save ...&quot;);\n        return &quot;&#123;&#39;module&#39;:&#39;book save&#39;&#125;&quot;;\n    &#125;\n&#125;\n\n注意:\n\n当类上和方法上都添加了@RequestMapping注解，前端发送请求的时候，要和两个注解的value值相加匹配才能访问到。\n@RequestMapping注解value属性前面加不加/都可以\n\n请求参数\nGet请求\nPost请求\n\n\n\nPost请求中文乱码处理\n\n为web容器添加过滤器并指定字符集，Spring-web包中提供了专用的字符过滤器\n\n解决方法：配置过滤器\npublic class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123;\n    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;\n        return new Class[0];\n    &#125;\n\n    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;\n        return new Class[]&#123;SpringMvcConfig.class&#125;;\n    &#125;\n\n    protected String[] getServletMappings() &#123;\n        return new String[]&#123;&quot;&#x2F;&quot;&#125;;\n    &#125;\n\n    &#x2F;&#x2F;乱码处理\n    @Override\n    protected Filter[] getServletFilters() &#123;\n        CharacterEncodingFilter filter &#x3D; new CharacterEncodingFilter();\n        filter.setEncoding(&quot;UTF-8&quot;);\n        return new Filter[]&#123;filter&#125;;\n    &#125;\n&#125;\n\n\n发送请求与参数:\nhttp:&#x2F;&#x2F;localhost&#x2F;commonParamDifferentName?name&#x3D;张三&amp;age&#x3D;18\n\n后台接收参数:\n@RequestMapping(&quot;&#x2F;commonParamDifferentName&quot;)\n@ResponseBody\npublic String commonParamDifferentName(String userName , int age)&#123;\n    System.out.println(&quot;普通参数传递 userName &#x3D;&#x3D;&gt; &quot;+userName);\n    System.out.println(&quot;普通参数传递 age &#x3D;&#x3D;&gt; &quot;+age);\n    return &quot;&#123;&#39;module&#39;:&#39;common param different name&#39;&#125;&quot;;\n&#125;\n\n因为前端给的是name,后台接收使用的是userName,两个名称对不上，导致接收数据失败:\n解决方案:使用@RequestParam注解\n@RequestMapping(&quot;&#x2F;commonParamDifferentName&quot;)\n    @ResponseBody\n    public String commonParamDifferentName(@RequestPaam(&quot;name&quot;) String userName , int age)&#123;\n        System.out.println(&quot;普通参数传递 userName &#x3D;&#x3D;&gt; &quot;+userName);\n        System.out.println(&quot;普通参数传递 age &#x3D;&#x3D;&gt; &quot;+age);\n        return &quot;&#123;&#39;module&#39;:&#39;common param different name&#39;&#125;&quot;;\n    &#125;\n\n用集合接收前台参数也需要@RequestParam注解\n\n日期类型参数传递\n类型转换器\njson数据接受请求中json数据1.添加json数据转换相关坐标\n&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;jackson-databind&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.9.0&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n2.设置发送json数据(请求body中添加json数据)\n\n3.开启自动转换json数据的支持\n\n4.设置接收json数据\n&#x2F;&#x2F;使用@RequestBody注解将外部传递的json数组数据映射到形参的集合对象中作为数据\n    @RequestMapping(&quot;&#x2F;listParamForJson&quot;)\n    @ResponseBody\n    public String listParamForJson(@RequestBody List&lt;String&gt; likes)&#123;\n        System.out.println(&quot;list common(json)参数传递 list &#x3D;&#x3D;&gt; &quot;+likes);\n        return &quot;&#123;&#39;module&#39;:&#39;list common for json param&#39;&#125;&quot;;\n    &#125;\n\n@RequestBody一个处理器方法只能使用一次\n\n@RequestBody与@RequestParam区别\n\n区别\n@RequestParam用于接收url地址传参，表单传参\n@RequestBody用于接收json数据\n\n\n应用\n后期开发中，发送json格式数据为主，@RequestBody应用较广\n如果发送非json格式数据，选用@RequestParam接收请求参数\n\n\n\n\n\n\n名称\n@ResponseBody\n\n\n\n类型\n&#x3D;&#x3D;方法\\类注解&#x3D;&#x3D;\n\n\n位置\nSpringMVC控制器方法定义上方和控制类上\n\n\n作用\n设置当前控制器返回值作为响应体,写在类上，该类的所有方法都有该注解功能\n\n\n相关属性\npattern：指定日期时间格式字符串\n\n\n说明:\n\n该注解可以写在类上或者方法上\n写在类上就是该类下的所有方法都有@ReponseBody功能\n当方法上有@ReponseBody注解后\n方法的返回值为字符串，会将其作为文本内容直接响应给前端\n方法的返回值为对象，会将对象转换成JSON响应给前端\n\n\n\n此处又使用到了类型转换，内部还是通过Converter接口的实现类完成的，所以Converter除了前面所说的功能外，它还可以实现:\n\n对象转Json数据(POJO -&gt; json)\n集合转Json数据(Collection -&gt; json)\n\nRest简介\nREST（Representational State Transfer），表现形式状态转换\n\n当我们想表示一个网络资源的时候，可以使用两种方式:\n\n传统风格资源描述形式\nhttp://localhost/user/getById?id=1 查询id为1的用户信息\nhttp://localhost/user/saveUser 保存用户信息\n\n\nREST风格描述形式\nhttp://localhost/user/1 \nhttp://localhost/user\n\n\n\n\n优点：\n隐藏资源的访问行为，无法通过地址得知对资源是何种操作\n书写简化\n\n\n\n\n\n按照REST风格访问资源时使用&#x3D;&#x3D;行为动作&#x3D;&#x3D;区分对资源进行了何种操作\nhttp://localhost/users\t查询全部用户信息 GET（查询）\nhttp://localhost/users/1  查询指定用户信息 GET（查询）\nhttp://localhost/users    添加用户信息    POST（新增&#x2F;保存）\nhttp://localhost/users    修改用户信息    PUT（修改&#x2F;更新）\nhttp://localhost/users/1  删除用户信息    DELETE（删除）\n\n\n根据REST风格对资源进行访问称为RESTful\n\n请求的方式比较多，但是比较常用的就4种，分别是GET,POST,PUT,DELETE。\n按照不同的请求方式代表不同的操作类型。\n\n发送GET请求是用来做查询\n发送POST请求是用来做新增\n发送PUT请求是用来做修改\n发送DELETE请求是用来做删除\n\n注意事项：\n上述行为是约定方式，约定不是规范，可以打破，所以称REST风格，而不是REST规范\n描述模块的名字通常使用负数，也就是可以加s的格式描述，表示此类资源，而非单个资源，例如：users、books、account......\n\n入门案例\n(2)如果有多个参数需要传递该如何编写?\n前端发送请求的时候使用:http://localhost/users/1/tom,路径中的1和tom就是我们想要传递的两个参数。\n后端获取参数，需要做如下修改:\n@Controller\npublic class UserController &#123;\n    &#x2F;&#x2F;设置当前请求方法为DELETE，表示REST风格中的删除操作\n\t@RequestMapping(value &#x3D; &quot;&#x2F;users&#x2F;&#123;id&#125;&#x2F;&#123;name&#125;&quot;,method &#x3D; RequestMethod.DELETE)\n    @ResponseBody\n    public String delete(@PathVariable Integer id,@PathVariable String name) &#123;\n        System.out.println(&quot;user delete...&quot; + id+&quot;,&quot;+name);\n        return &quot;&#123;&#39;module&#39;:&#39;user delete&#39;&#125;&quot;;\n    &#125;\n&#125;\n\n\n关于接收参数，我们学过三个注解@RequestBody、@RequestParam、@PathVariable,这三个注解之间的区别和应用分别是什么?\n\n区别\n@RequestParam用于接收url地址传参或表单传参\n@RequestBody用于接收json数据\n@PathVariable用于接收路径参数，使用{参数名称}描述路径参数\n\n\n应用\n后期开发中，发送请求参数超过1个时，以json格式为主，@RequestBody应用较广\n如果发送非json格式数据，选用@RequestParam接收请求参数\n采用RESTful进行开发，当参数数量较少时，例如1个，可以采用@PathVariable接收请求路径变量，通常用于传递id值\n\n\n\nRESTful快速开发问题1：每个方法的@RequestMapping注解中都定义了访问路径&#x2F;books，重复性太高。\n问题2：每个方法的@RequestMapping注解中都要使用method属性定义请求方式，重复性太高。\n问题3：每个方法响应json都需要加上@ResponseBody注解，重复性太高。\n对于刚才的问题，我们都有对应的解决方案：\n问题1：每个方法的@RequestMapping注解中都定义了访问路径&#x2F;books，重复性太高。\n将@RequestMapping提到类上面，用来定义所有方法共同的访问路径。\n\n问题2：每个方法的@RequestMapping注解中都要使用method属性定义请求方式，重复性太高。\n使用@GetMapping  @PostMapping  @PutMapping  @DeleteMapping代替\n\n问题3：每个方法响应json都需要加上@ResponseBody注解，重复性太高。\n1.将ResponseBody提到类上面，让所有的方法都有@ResponseBody的功能\n2.使用@RestController注解替换@Controller与@ResponseBody注解，简化书写\n\n知识点1：@RestController\n\n\n名称\n@RestController\n\n\n\n类型\n&#x3D;&#x3D;类注解&#x3D;&#x3D;\n\n\n位置\n基于SpringMVC的RESTful开发控制器类定义上方\n\n\n作用\n设置当前控制器类为RESTful风格，等同于@Controller与@ResponseBody两个注解组合功能\n\n\n知识点2：@GetMapping @PostMapping @PutMapping @DeleteMapping\n\n\n名称\n@GetMapping @PostMapping @PutMapping @DeleteMapping\n\n\n\n类型\n&#x3D;&#x3D;方法注解&#x3D;&#x3D;\n\n\n位置\n基于SpringMVC的RESTful开发控制器方法定义上方\n\n\n作用\n设置当前控制器方法请求访问路径与请求动作，每种对应一个请求动作，例如@GetMapping对应GET请求\n\n\n相关属性\nvalue（默认）：请求访问路径\n\n\n案例：基于RESTful页面数据交互编写Controller类并使用RESTful进行配置@RestController\n@RequestMapping(&quot;&#x2F;books&quot;)\npublic class BookController &#123;\n\n    @PostMapping\n    public String save(@RequestBody Book book)&#123;\n        System.out.println(&quot;book save &#x3D;&#x3D;&gt; &quot;+ book);\n        return &quot;&#123;&#39;module&#39;:&#39;book save success&#39;&#125;&quot;;\n    &#125;\n\n \t@GetMapping\n    public List&lt;Book&gt; getAll()&#123;\n        System.out.println(&quot;book getAll is running ...&quot;);\n        List&lt;Book&gt; bookList &#x3D; new ArrayList&lt;Book&gt;();\n\n        Book book1 &#x3D; new Book();\n        book1.setType(&quot;计算机&quot;);\n        book1.setName(&quot;SpringMVC入门教程&quot;);\n        book1.setDescription(&quot;小试牛刀&quot;);\n        bookList.add(book1);\n\n        Book book2 &#x3D; new Book();\n        book2.setType(&quot;计算机&quot;);\n        book2.setName(&quot;SpringMVC实战教程&quot;);\n        book2.setDescription(&quot;一代宗师&quot;);\n        bookList.add(book2);\n\n\n        return bookList;\n    &#125;\n\n&#125;\n\n\nSpringMVC需要将静态资源进行放行。\n\n@Configuration\npublic class SpringMvcSupport extends WebMvcConfigurationSupport &#123;\n    &#x2F;&#x2F;设置静态资源访问过滤，当前类需要设置为配置类，并被扫描加载\n    @Override\n    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;\n        &#x2F;&#x2F;当访问&#x2F;pages&#x2F;????时候，从&#x2F;pages目录下查找内容\n        registry.addResourceHandler(&quot;&#x2F;pages&#x2F;**&quot;).addResourceLocations(&quot;&#x2F;pages&#x2F;&quot;);\n        registry.addResourceHandler(&quot;&#x2F;js&#x2F;**&quot;).addResourceLocations(&quot;&#x2F;js&#x2F;&quot;);\n        registry.addResourceHandler(&quot;&#x2F;css&#x2F;**&quot;).addResourceLocations(&quot;&#x2F;css&#x2F;&quot;);\n        registry.addResourceHandler(&quot;&#x2F;plugins&#x2F;**&quot;).addResourceLocations(&quot;&#x2F;plugins&#x2F;&quot;);\n    &#125;\n&#125;\n\n\n\n该配置类是在config目录下，SpringMVC扫描的是controller包，所以该配置类还未生效，要想生效需要将SpringMvcConfig配置类进行修改\n\n@Configuration\n@ComponentScan(&#123;&quot;com.itheima.controller&quot;,&quot;com.itheima.config&quot;&#125;)\n@EnableWebMvc\npublic class SpringMvcConfig &#123;\n&#125;\n\n或者\n\n@Configuration\n@ComponentScan(&quot;com.itheima&quot;)\n@EnableWebMvc\npublic class SpringMvcConfig &#123;\n&#125;\n\nSSM整合1.创建工程\n2.SSM整合\n\nSpring\n\nSpringConfig\n\n\nMyBatis\n\nMybatisConfig\n\nJdbcConfig\n\njdbc.properties\n\n\n\nSpringMVC\n\nServletConfig\nSpirngMvcConfig\n\n\n\n3.功能模块\n\n表与实现类\ndao(接口+自动代理)\nservice(接口+实现类)\n业务层接口测试(整合JUnit)\n\n\ncontroller\n表现层接口测试(PostMan)\n\n\n\n\n\n\n\n异常处理器\n出现异常现象的常见位置与常见诱因如下：\n\n框架内部抛出的异常：因使用不合规导致\n数据层抛出的异常：因外部服务器故障导致（例如：服务器访问超时）\n业务层抛出的异常：因业务逻辑书写失败导致（例如：遍历业务书写操作，导致索引异常等）\n表现层抛出的异常：因数据收集、校验等规则导致（例如：不匹配的数据类型间导致异常）\n工具类抛出的异常：因工具类书写不严谨不够健壮导致（例如：必要释放的连接长期未释放导致等）\n\n\n所有异常均抛出到表现层处理\n\n对于上面这些问题及解决方案，SpringMVC已经为我们提供了一套解决方案:\n\n对于上面这些问题及解决方案，SpringMVC已经为我们提供了一套解决方案:\n\n异常处理器:\n集中的、统一的处理项目中出现的异常。\n\n\n\n@RestControllerAdvice\npublic class ProjectExceptionAdvice &#123;\n    @ExceptionHandler(Exception.class)\n    public void doException(Exception ex)&#123;\n        System.out.println(&quot;出现异常了&quot;);\n    &#125;\n&#125;\n\n\n\n知识点1：@RestControllerAdvice\n\n\n\n名称\n@RestControllerAdvice\n\n\n\n类型\n&#x3D;&#x3D;类注解&#x3D;&#x3D;\n\n\n位置\nRest风格开发的控制器增强类定义上方\n\n\n作用\n为Rest风格开发的控制器类做增强\n\n\n**说明:**此注解自带@ResponseBody注解与@Component注解，具备对应的功能\n\n知识点2：@ExceptionHandler\n\n\n\n名称\n@ExceptionHandler\n\n\n\n类型\n&#x3D;&#x3D;方法注解&#x3D;&#x3D;\n\n\n位置\n专用于异常处理的控制器方法上方\n\n\n作用\n设置指定异常的处理方案，功能等同于控制器方法，出现异常后终止原始控制器执行,并转入当前方法执行\n\n\n说明：此类方法可以根据处理的异常不同，制作多个方法分别处理对应的异常\n项目异常分类及处理项目异常分类\n\n业务异常（BusinessException）\n\n规范的用户行为产生的异常\n\n用户在页面输入内容的时候未按照指定格式进行数据填写，如在年龄框输入的是字符串\n\n\n不规范的用户行为操作产生的异常\n\n如用户故意传递错误数据\n\n\n\n\n系统异常（SystemException）\n\n项目运行过程中可预计但无法避免的异常\n比如数据库或服务器宕机\n\n\n\n\n其他异常（Exception）\n\n编程人员未预期到的异常，如:用到的文件不存在\n\n\n\n处理方案\n\n业务异常（BusinessException）\n发送对应消息传递给用户，提醒规范操作\n大家常见的就是提示用户名已存在或密码格式不正确等\n\n\n\n\n系统异常（SystemException）\n发送固定消息传递给用户，安抚用户\n系统繁忙，请稍后再试\n系统正在维护升级，请稍后再试\n系统出问题，请联系系统管理员等\n\n\n发送特定消息给运维人员，提醒维护\n可以发送短信、邮箱或者是公司内部通信软件\n\n\n记录日志\n发消息和记录日志对用户来说是不可见的，属于后台程序\n\n\n\n\n其他异常（Exception）\n发送固定消息传递给用户，安抚用户\n发送特定消息给编程人员，提醒维护（纳入预期范围内）\n一般是程序没有考虑全，比如未做非空校验等\n\n\n记录日志\n\n\n\n拦截器\n拦截器是一种动态拦截方法调用的机制，在SpirngMVC中动态拦截控制器方法的执行\n作用：\n在指定的方法调用前后执行预先设定的代码\n阻止原始方法的执行\n\n\n\n拦截器和过滤器区别\n归属不同：Filter输入Servlet技术，Interceptor呼入SpringMVC技术\n拦截内容不同：Filter对所有访问进行增强，Interceptor仅针对SpringMVC的访问进行增强\n\n拦截器入门案例\n创建拦截器类\n让类实现HandlerInterceptor接口，重写接口中的三个方法\n@Component\n&#x2F;&#x2F;定义拦截器类，实现HandlerInterceptor接口\n&#x2F;&#x2F;注意当前类必须受Spring容器控制\npublic class ProjectInterceptor implements HandlerInterceptor &#123;\n    @Override\n    &#x2F;&#x2F;原始方法调用前执行的内容\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;\n        System.out.println(&quot;preHandle...&quot;);\n        return true;\n    &#125;\n\n    @Override\n    &#x2F;&#x2F;原始方法调用后执行的内容\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;\n        System.out.println(&quot;postHandle...&quot;);\n    &#125;\n\n    @Override\n    &#x2F;&#x2F;原始方法调用完成后执行的内容\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;\n        System.out.println(&quot;afterCompletion...&quot;);\n    &#125;\n&#125;\n\n配置拦截器类\n@Configuration\npublic class SpringMvcSupport extends WebMvcConfigurationSupport &#123;\n    @Autowired\n    private ProjectInterceptor projectInterceptor;\n\n    @Override\n    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;\n        registry.addResourceHandler(&quot;&#x2F;pages&#x2F;**&quot;).addResourceLocations(&quot;&#x2F;pages&#x2F;&quot;);\n    &#125;\n\n    @Override\n    protected void addInterceptors(InterceptorRegistry registry) &#123;\n        &#x2F;&#x2F;配置拦截器\n        registry.addInterceptor(projectInterceptor).addPathPatterns(&quot;&#x2F;books&quot; );\n    &#125;\n&#125;\n\nSpringMVC添加SpringMvcSupport包扫描\n@Configuration\n@ComponentScan(&#123;&quot;com.itheima.controller&quot;,&quot;com.itheima.config&quot;&#125;)\n@EnableWebMvc\npublic class SpringMvcConfig&#123;\n   \n&#125;\n\n简化SpringMvcSupport的编写\n@Configuration\n@ComponentScan(&#123;&quot;com.itheima.controller&quot;&#125;)\n@EnableWebMvc\n&#x2F;&#x2F;实现WebMvcConfigurer接口可以简化开发，但具有一定的侵入性\npublic class SpringMvcConfig implements WebMvcConfigurer &#123;\n    @Autowired\n    private ProjectInterceptor projectInterceptor;\n\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) &#123;\n        &#x2F;&#x2F;配置多拦截器\n        registry.addInterceptor(projectInterceptor).addPathPatterns(&quot;&#x2F;books&quot;,&quot;&#x2F;books&#x2F;*&quot;);\n    &#125;\n&#125;\n\n\n\n拦截器中的preHandler方法，如果返回true,则代表放行，会执行原始Controller类中要请求的方法，如果返回false，则代表拦截，后面的就不会再执行了。\n当有拦截器后，请求会先进入preHandle方法，\n​\t如果方法返回true，则放行继续执行后面的handle[controller的方法]和后面的方法\n​\t如果返回false，则直接跳过后面方法的执行。\n多拦截器执行顺序\nSpringBootSpringBoot简介\nSpringBoot设计目的是用来简化Spring应用的初始搭建以及开发过程\n\n\n原始 Spring 环境搭建和开发存在以下问题：\n\n配置繁琐\n依赖设置繁琐\n\nSpringBoot 程序优点恰巧就是针对 Spring 的缺点\n\n自动配置。这个是用来解决 Spring 程序配置繁琐的问题\n起步依赖。这个是用来解决 Spring 程序依赖设置繁琐的问题\n辅助功能（内置服务器,…）。我们在启动 SpringBoot 程序时既没有使用本地的 tomcat 也没有使用 tomcat 插件，而是使用 SpringBoot 内置的服务器。\n\n创建SpringBoot项目流程\n创建新模块\n\n点击 + 选择 New Module 创建新模块\n\n\n选择 Spring Initializr ，用来创建 SpringBoot 工程\n\n以前我们选择的是 Maven ，今天选择 Spring Initializr 来快速构建 SpringBoot 工程。而在 Module SDK 这一项选择我们安装的 JDK 版本。\n\n\n对 SpringBoot 工程进行相关的设置\n\n我们使用这种方式构建的 SpringBoot 工程其实也是 Maven 工程，而该方式只是一种快速构建的方式而已。\n\n\n\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;注意：打包方式这里需要设置为 Jar&#x3D;&#x3D;\n\n选中 Web，然后勾选 Spring Web\n由于我们需要开发一个 web 程序，使用到了 SpringMVC 技术，所以按照下图红框进行勾选\n\n\n\n\n下图界面不需要任何修改，直接点击 Finish 完成 SpringBoot 工程的构建\n\n\n\n创建 Controller\n\n@RestController\n@RequestMapping(&quot;&#x2F;books&quot;)\npublic class BookController &#123;\n\n    @GetMapping(&quot;&#x2F;&#123;id&#125;&quot;)\n    public String getById(@PathVariable Integer id)&#123;\n        System.out.println(&quot;id &#x3D;&#x3D;&gt; &quot;+id);\n        return &quot;hello , spring boot!&quot;;\n    &#125;\n&#125;\n\n\n启动服务器\n\n运行Application类\n\n进行测试\n\n用Postman发送请求\n也可以选择去官网https://spring.io/projects/spring-boot创建项目\nSpirng项目快速启动1.所以我们只需要使用 Maven 的 package 指令打包就会在 target 目录下生成对应的 Jar 包。\n2.进入 jar 包所在位置，在 命令提示符 中输入如下命令\njar -jar springboot_01_quickstart-0.0.1-SNAPSHOT.jar\n\n切换web服务器我们启动工程默认是tomcat服务器，那能不能不使用 tomcat 而使用 jetty 服务器?而要切换 web 服务器就需要将默认的 tomcat 服务器给排除掉，怎么排除呢？使用 exclusion 标签\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;&#x2F;artifactId&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;&#x2F;exclusion&gt;\n    &lt;&#x2F;exclusions&gt;\n&lt;&#x2F;dependency&gt;\n\n添加jetty服务器\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-jetty&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n基础配置配置文件格式\nSpringBoot提供了多种属性配置方式\n\napplication.properties\nserver.port&#x3D;80\n\napplication.yml\nserver:\n  port: 81\n\napplication.yaml\nserver:\n  port: 82\n\n\nSpringBoot配置文件加载顺序\n\napplication.properties &gt; application.yml &gt; application.yaml\n\n\n\nyaml\nYAML 一种数据序列化格式\n优点：\n容易阅读\n容易与脚本语言交互\n以数据为核心，重数据轻格式\n\n\nYAML文件扩展名\n.yml(主流)\n.yaml\n\n\n\nyaml语法规则\n书写yaml文件应该严格遵守yaml语法规则，不然文件将不会被识别导致问题\n\n\n大小写敏感\n属性层级关系使用多行描述，每行结尾使用冒号结束\n使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用Tab建）\n属性值前面添加空格（属性名与属性值之间使用冒号+空格作为分隔）\n# 表示注释\n\nyaml数据读取方式\n\n\n在进行自定义对象封装数据被警告时，将依赖加入pom文件中\n&lt;dependency&gt;\n\t&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-boot-configuration-processor&lt;&#x2F;artifactId&gt;\n\t&lt;optional&gt;true&lt;&#x2F;optional&gt;\n&lt;&#x2F;dependency&gt;\n\n多环境配置yml 和 yamlapplication.yml 配置文件内容如下\n#设置启用的环境\nspring:\n  profiles:\n    active: dev\n\n---\n#开发\nspring:\n  profiles: dev\nserver:\n  port: 80\n---\n#生产\nspring:\n  profiles: pro\nserver:\n  port: 81\n---\n#测试\nspring:\n  profiles: test\nserver:\n  port: 82\n---\n\n&#x3D;&#x3D;注意：&#x3D;&#x3D;\n在上面配置中给不同配置起名字的 spring.profiles 配置项已经过时。最新用来起名字的配置项是 \n#开发\nspring:\n  config:\n    activate:\n      on-profile: dev\n\n\nproperties文件properties 类型的配置文件配置多环境需要定义不同的配置文件\n\napplication-dev.properties 是开发环境的配置文件。我们在该文件中配置端口号为 80\nserver.port&#x3D;80\n\napplication-test.properties 是测试环境的配置文件。我们在该文件中配置端口号为 81\nserver.port&#x3D;81\n\napplication-pro.properties 是生产环境的配置文件。我们在该文件中配置端口号为 82\nserver.port&#x3D;82\n\nSpringBoot 只会默认加载名为 application.properties 的配置文件，所以需要在 application.properties 配置文件中设置启用哪个配置文件，配置如下:\nspring.profiles.active&#x3D;pro\n\n命令行启动参数设置使用 SpringBoot 开发的程序以后都是打成 jar 包，通过 java -jar xxx.jar 的方式启动服务的。那么就存在一个问题，如何切换环境呢？因为配置文件打到的jar包中了。\n我们知道 jar 包其实就是一个压缩包，可以解压缩，然后修改配置，最后再打成jar包就可以了。这种方式显然有点麻烦，而 SpringBoot 提供了在运行 jar 时设置开启指定的环境的方式，如下\njava –jar xxx.jar –-spring.profiles.active&#x3D;test\n\n那么这种方式能不能临时修改端口号呢？也是可以的，可以通过如下方式\njava –jar xxx.jar –-server.port&#x3D;88\n\n当然也可以同时设置多个配置，比如即指定启用哪个环境配置，又临时指定端口，如下\njava –jar springboot.jar –-server.port&#x3D;88 –-spring.profiles.active&#x3D;test\n\n大家进行测试后就会发现命令行设置的端口号优先级高（也就是使用的是命令行设置的端口号），配置的优先级其实 SpringBoot 官网已经进行了说明，参见 :\nhttps:&#x2F;&#x2F;docs.spring.io&#x2F;spring-boot&#x2F;docs&#x2F;current&#x2F;reference&#x2F;html&#x2F;spring-boot-features.html#boot-features-external-config\n\n配置文件分类有这样的场景，我们开发完毕后需要测试人员进行测试，由于测试环境和开发环境的很多配置都不相同，所以测试人员在运行我们的工程时需要临时修改很多配置，如下\njava –jar springboot.jar –-spring.profiles.active&#x3D;test --server.port&#x3D;85 --server.servlet.context-path&#x3D;&#x2F;heima --server.tomcat.connection-timeout&#x3D;-1 …… …… …… …… ……\n\n针对这种情况，SpringBoot 定义了配置文件不同的放置的位置；而放在不同位置的优先级时不同的。\nSpringBoot 中4级配置文件放置位置：\n\n1级：classpath：application.yml  \n2级：classpath：config&#x2F;application.yml\n3级：file ：application.yml\n4级：file ：config&#x2F;application.yml\n\n作用：\n\n1级与2级留作系统打包后设置通用属性\n3级与4级用于系统开发阶段设置通用属性\n\nSpringBoot整合junit回顾 Spring 整合 junit\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(classes &#x3D; SpringConfig.class)\npublic class UserServiceTest &#123;\n    \n    @Autowired\n    private BookService bookService;\n    \n    @Test\n    public void testSave()&#123;\n        bookService.save();\n    &#125;\n&#125;\n\n使用 @RunWith 注解指定运行器，使用 @ContextConfiguration 注解来指定配置类或者配置文件。而 SpringBoot 整合 junit 特别简单，分为以下三步完成\n\n在测试类上添加 SpringBootTest 注解\n使用 @Autowired 注入要测试的资源\n定义测试方法进行测试\n\nSpringBoot整合junit\n@SpringBootTest\nclass Springboot07TestApplicationTests &#123;\n\n    @Autowired\n    private BookService bookService;\n\n    @Test\n    public void save() &#123;\n        bookService.save();\n    &#125;\n&#125;\n\n&#x3D;&#x3D;注意：&#x3D;&#x3D;这里的引导类所在包必须是测试类所在包及其子包。\nSpringBoot整合Mybatis回顾Spring整合MybatisSpring 整合 Mybatis 需要定义很多配置类\n\nSpringConfig 配置类\n\n导入 JdbcConfig 配置类\n\n导入 MybatisConfig 配置类\n@Configuration\n@ComponentScan(&quot;com.itheima&quot;)\n@PropertySource(&quot;classpath:jdbc.properties&quot;)\n@Import(&#123;JdbcConfig.class,MyBatisConfig.class&#125;)\npublic class SpringConfig &#123;\n&#125;\n\n\n\nJdbcConfig 配置类\n\n定义数据源（加载properties配置项：driver、url、username、password）\npublic class JdbcConfig &#123;\n    @Value(&quot;$&#123;jdbc.driver&#125;&quot;)\n    private String driver;\n    @Value(&quot;$&#123;jdbc.url&#125;&quot;)\n    private String url;\n    @Value(&quot;$&#123;jdbc.username&#125;&quot;)\n    private String userName;\n    @Value(&quot;$&#123;jdbc.password&#125;&quot;)\n    private String password;\n\n    @Bean\n    public DataSource getDataSource()&#123;\n        DruidDataSource ds &#x3D; new DruidDataSource();\n        ds.setDriverClassName(driver);\n        ds.setUrl(url);\n        ds.setUsername(userName);\n        ds.setPassword(password);\n        return ds;\n    &#125;\n&#125;\n\n\nMybatisConfig 配置类\n\n定义 SqlSessionFactoryBean\n\n定义映射配置\n@Bean\npublic MapperScannerConfigurer getMapperScannerConfigurer()&#123;\n    MapperScannerConfigurer msc &#x3D; new MapperScannerConfigurer();\n    msc.setBasePackage(&quot;com.itheima.dao&quot;);\n    return msc;\n&#125;\n\n@Bean\npublic SqlSessionFactoryBean getSqlSessionFactoryBean(DataSource dataSource)&#123;\n    SqlSessionFactoryBean ssfb &#x3D; new SqlSessionFactoryBean();\n    ssfb.setTypeAliasesPackage(&quot;com.itheima.domain&quot;);\n    ssfb.setDataSource(dataSource);\n    return ssfb;\n&#125;\n\n\n\n\nSpringBoot整合Mybatis\n创建新模块，选择Spirng初始化，并配置模块相关基础信息\n\n\n\n选择当前模块需要使用的技术集(MyBatis Mysql)\n\n在配置文件中（application.yaml）设置数据源参数\n\n\n注意事项\nSpirngBoot版本低于2.4.3，Mysql驱动版本大于8时，需要在url连接串中配置时区\njdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;ssm_db?serverTimezone&#x3D;UTC\n或在MySql数据库配置时区解决此问题\n\n\n定义数据层接口与映射配置\n@Mapper\npublic interface BookDao &#123;\n    @Select(&quot;select * from tbl_book where id &#x3D; #&#123;id&#125;&quot;)\n    public Book getById(Integer id);\n&#125;\n\n测试类中注入dao接口，测试功能\n@SpringBootTest\nclass Spring08MybatisApplicationTests &#123;\n    @Autowired\n    private BookDao bookDao;\n    @Test\n    void testGetById() &#123;\n        Book book &#x3D; bookDao.getById(2);\n        System.out.println(book);\n    &#125;\n&#125;\n\nSpringBoot整合ssm\npom.xml\n配置起步依赖，必要的资源坐标\n\naplication.yml\n设置数据源，端口\n\n配置类\n全部删除\n\ndao\n设置@Mapper\n\n测试类\n\n页面\n放置在resources目录下的static目录中\n\n\nMyBatis PlusMyBatisPlus入门案例与简介入门案例\n创建新模块，选择Spring初始化，并配置模块相关基础信息\n\n\n选择当前模块需要使用的技术集（仅保留JDBC）\n\n\n手动添加MyBatisPlus起步依赖\n&lt;dependency&gt;\n\t&lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;mybatis-plus-boot-starter&lt;&#x2F;artifactId&gt;\t\n    &lt;version&gt;3.4.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n由于MyBatisPlus并未被收录到idea的系统内置配置，无法直接选择加入\n\n设置Jdbc参数(application.yml)\nspring:\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;ssm_db\n    username: \n    password: \n\n使用druid数据源，需要导入对应坐标\n\n制作实体类与表结构（类名与表名对应，属性名与字段名对应） 如类名与表名不对应 可在实体类上方添加注释@TableName(&quot;表名&quot;)\n\n定义数据接口，继承BaseMapper&lt;实体类类名&gt;\n@Mapper\npublic interface BookDao extends BaseMapper&lt;Book&gt; &#123;\n&#125;\n\n测试类中注入dao接口，测试功能\n@SpringBootTest\nclass Mybatisplus001QuickstartApplicationTests &#123;\n\n    @Autowired\n    private BookDao bookDao;\n\n    @Test\n    void test() &#123;\n        List&lt;Book&gt; books &#x3D; bookDao.selectList(null);\n        System.out.println(books);\n    &#125;\n\n&#125;\n\nMybatis简介\nMP是基于Mybatis框架基础上开发的增强型工具，旨在简化开发，提升效率\n开发方式\n基于MyBatis使用MyBatisPlus\n基于Spring使用MyBatisPlus\n基于SpringBoot使用MyBatisPlus\n\n\nMyBatisPlus的官网为:https://mp.baomidou.com/\n\nMyBatisPlus的特性:\n\n无侵入：只做增强不做改变，不会对现有工程产生影响\n强大的 CRUD 操作：内置通用 Mapper，少量配置即可实现单表CRUD 操作\n支持 Lambda：编写查询条件无需担心字段写错\n支持主键自动生成\n内置分页插件\n……\n\n标准数据层开发标准CRUD使用\n新增在进行新增之前，我们可以分析下新增的方法:\nint insert (T t)\n\n\nT:泛型，新增用来保存新增数据\n\nint:返回值，新增成功后返回1，没有新增成功返回的是0\n\n\n在测试类中进行新增操作:\n@Test\nvoid testSave()&#123;\n    Book book &#x3D; new Book();\n    book.setId(1);\n    book.setType(&quot;市场营销&quot;);\n    book.setName(&quot;零基础学python（全彩版）&quot;);\n    book.setDescription(&quot;黑马程序员，帮你成为python语言黑马&quot;);\n    bookDao.insert(book);\n&#125;\n\n删除int deleteById (Serializable id)\n\nSerializable：参数类型\n\n思考:参数类型为什么是一个序列化类?\n\n\n从这张图可以看出，\n\nString和Number是Serializable的子类，\nNumber又是Float,Double,Integer等类的父类，\n能作为主键的数据类型都已经是Serializable的子类，\nMP使用Serializable作为参数类型，就好比我们可以用Object接收任何数据类型一样。\n\n\nint:返回值类型，数据删除成功返回1，未删除数据返回0。\n\n\n在测试类中进行新增操作:\n @SpringBootTest\nclass Mybatisplus01QuickstartApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n\n    @Test\n    void testDelete() &#123;\n        userDao.deleteById(1401856123725713409L);\n    &#125;\n&#125;\n\n修改int updateById(T t);\n\n\nT:泛型，需要修改的数据内容，注意因为是根据ID进行修改，所以传入的对象中需要有ID属性值\n\nint:返回值，修改成功后返回1，未修改数据返回0\n\n\n在测试类中进行新增操作:\n@SpringBootTest\nclass Mybatisplus01QuickstartApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n\n    @Test\n    void testUpdate() &#123;\n        User user &#x3D; new User();\n        user.setId(1L);\n        user.setName(&quot;Tom888&quot;);\n        user.setPassword(&quot;tom888&quot;);\n        userDao.updateById(user);\n    &#125;\n&#125;\n\n**说明:**修改的时候，只修改实体对象中有值的字段。\n根据ID查询T selectById (Serializable id)\n\n\nSerializable：参数类型,主键ID的值\nT:根据ID查询只会返回一条数据\n\n在测试类中进行新增操作:\n@SpringBootTest\nclass Mybatisplus01QuickstartApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n    \n    @Test\n    void testGetById() &#123;\n        User user &#x3D; userDao.selectById(2L);\n        System.out.println(user);\n    &#125;\n&#125;\n\n查询所有在进行查询所有之前，我们可以分析下查询所有的方法:\nList&lt;T&gt; selectList(Wrapper&lt;T&gt; queryWrapper)\n\n\nWrapper：用来构建条件查询的条件，目前我们没有可直接传为Null\nList:因为查询的是所有，所以返回的数据是一个集合\n\n在测试类中进行新增操作:\n@SpringBootTest\nclass Mybatisplus01QuickstartApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n    \n    @Test\n    void testGetAll() &#123;\n        List&lt;User&gt; userList &#x3D; userDao.selectList(null);\n        System.out.println(userList);\n    &#125;\n&#125;\n\nLombok概念\nLombok，一个Java类库，提供了一组注解，简化POJO实体类开发。\n\n使用步骤步骤1:添加lombok依赖&lt;dependency&gt;\n    &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;\n    &lt;!--&lt;version&gt;1.18.12&lt;&#x2F;version&gt;--&gt;\n&lt;&#x2F;dependency&gt;\n\n注意：版本可以不用写，因为SpringBoot中已经管理了lombok的版本。\n步骤2:安装Lombok的插件&#x3D;&#x3D;新版本IDEA已经内置了该插件，如果删除setter和getter方法程序有报红，则需要安装插件&#x3D;&#x3D;\n如果在IDEA中找不到lombok插件，可以访问如下网站\nhttps://plugins.jetbrains.com/plugin/6317-lombok/versions\n根据自己IDEA的版本下载对应的lombok插件，下载成功后，在IDEA中采用离线安装的方式进行安装。\n步骤3:模型类上添加注解Lombok常见的注解有:\n\n@Setter:为模型类的属性提供setter方法\n@Getter:为模型类的属性提供getter方法\n@ToString:为模型类的属性提供toString方法\n@EqualsAndHashCode:为模型类的属性提供equals和hashcode方法\n&#x3D;&#x3D;@Data:是个组合注解，包含上面的注解的功能&#x3D;&#x3D;\n&#x3D;&#x3D;@NoArgsConstructor:提供一个无参构造函数&#x3D;&#x3D;\n&#x3D;&#x3D;@AllArgsConstructor:提供一个包含所有参数的构造函数&#x3D;&#x3D;\n\nLombok的注解还有很多，上面标红的三个是比较常用的，其他的大家后期用到了，再去补充学习。\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class User &#123;\n    private Long id;\n    private String name;\n    private String password;\n    private Integer age;\n    private String tel;\n&#125;\n\n说明:\nLombok只是简化模型类的编写，我们之前的方法也能用，比如有人会问:我如果只想要有name和password的构造函数，该如何编写?\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class User &#123;\n    private Long id;\n    private String name;\n    private String password;\n    private Integer age;\n    private String tel;\n\n    public User(String name, String password) &#123;\n        this.name &#x3D; name;\n        this.password &#x3D; password;\n    &#125;\n&#125;\n\n这种方式是被允许的。\n分页功能IPage&lt;T&gt; selectPage(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)\n\n\nIPage:用来构建分页查询条件\nWrapper：用来构建条件查询的条件，目前我们没有可直接为Null\nIPage:返回值，你会发现构建分页条件和方法的返回值都是IPage\n\nIPage是一个接口，我们需要找到它的实现类来构建它，具体的实现类，可以进入到IPage类中按ctrl+h,会找到其有一个实现类为Page。\n步骤1:调用方法传入参数获取返回值@SpringBootTest\nclass Mybatisplus01QuickstartApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n    \n    &#x2F;&#x2F;分页查询\n    @Test\n    void testSelectPage()&#123;\n        &#x2F;&#x2F;1 创建IPage分页对象,设置分页参数,1为当前页码，3为每页显示的记录数\n        IPage&lt;User&gt; page&#x3D;new Page&lt;&gt;(1,3);\n        &#x2F;&#x2F;2 执行分页查询\n        userDao.selectPage(page,null);\n        &#x2F;&#x2F;3 获取分页结果\n        System.out.println(&quot;当前页码值：&quot;+page.getCurrent());\n        System.out.println(&quot;每页显示数：&quot;+page.getSize());\n        System.out.println(&quot;一共多少页：&quot;+page.getPages());\n        System.out.println(&quot;一共多少条数据：&quot;+page.getTotal());\n        System.out.println(&quot;数据：&quot;+page.getRecords());\n    &#125;\n&#125;\n\n步骤2:设置分页拦截器这个拦截器MP已经为我们提供好了，我们只需要将其配置成Spring管理的bean对象即可。\n@Configuration\npublic class MybatisPlusConfig &#123;\n    \n    @Bean\n    public MybatisPlusInterceptor mybatisPlusInterceptor()&#123;\n        &#x2F;&#x2F;1 创建MybatisPlusInterceptor拦截器对象\n        MybatisPlusInterceptor mpInterceptor&#x3D;new MybatisPlusInterceptor();\n        &#x2F;&#x2F;2 添加分页拦截器\n        mpInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());\n        return mpInterceptor;\n    &#125;\n&#125;\n\n**说明:**上面的代码记不住咋办呢?\n这些内容在MP的官方文档中有详细的说明，我们可以查看官方文档类配置\n\n步骤3:运行测试程序如果想查看MP执行的SQL语句，可以修改application.yml配置文件，\nmybatis-plus:\n  configuration:\n    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl #打印SQL日志到控制台\n\n打开日志后，就可以在控制台打印出对应的SQL语句，开启日志功能性能就会受到影响，调试完后记得关闭。\nDQL编程控制条件查询多条件查询格式需要： 查询年龄大于等于18，小于65岁的用户\n\n格式一：常规格式\nQueryWrapper&lt;User&gt; qw &#x3D; new QueryWrapper&lt;User&gt;();\nqw.lt(&quot;age&quot;,65);\nqw.ge(&quot;age&quot;,18);\nList&lt;User&gt; userList &#x3D; userDao.selectList(qw);\nSysteam.out.println(userList);\n\n格式二：链式编程格式\nQueryWrapper&lt;User&gt; qw &#x3D; new QueryWrapper&lt;User&gt;();\nqw.lt(&quot;age&quot;,65).ge(&quot;age&quot;,18);\nList&lt;User&gt; userList &#x3D; userDao.selectList(qw);\nSysteam.out.println(userList);\n\n格式三：lambda格式(推荐)\nQueryWrapper&lt;User&gt; qw &#x3D; new QueryWrapper&lt;User&gt;();\n        qw.lambda().lt(User::getAge, 65).ge(User::getAge,18);&#x2F;&#x2F;添加条件\n        List&lt;User&gt; userList &#x3D; userDao.selectList(qw);\n        System.out.println(userList);\n\n格式四：lambda格式(推荐)\nLambdaQueryWrapper&lt;User&gt; qw &#x3D; new LambdaQueryWrapper&lt;User&gt;();\n        qw.lt(User::getAge, 65).ge(User::getAge,18);&#x2F;&#x2F;添加条件\n        List&lt;User&gt; userList &#x3D; userDao.selectList(qw);\n        System.out.println(userList);\n\n\n并且(and)\nLambdaQueryWrapper&lt;User&gt; lqw &#x3D; new LambdaQueryWrapper&lt;User&gt;();\nlqw.lt(User::getAge, 30).gt(User::getAge, 10);\nList&lt;User&gt; userList &#x3D; userDao.selectList(lqw);\nSystem.out.println(userList);\n\n或者(or)\nLambdaQueryWrapper&lt;User&gt; lqw &#x3D; new LambdaQueryWrapper&lt;User&gt;();\nlqw.lt(User::getAge, 30).or().gt(User::getAge, 10);\nList&lt;User&gt; userList &#x3D; userDao.selectList(lqw);\nSystem.out.println(userList);\n\n关于null的判定如果传入的某一个查询条件为空，则查询会失败。\n我们选择lt(boolean condition, R column, Object val)方法\ntrue，则添加条件，返回false则不添加条件\n因此，如果某一查询条件为空时，我们返回false。\n@Test\n   void testGetAll()&#123;\n       &#x2F;&#x2F;模拟页面传递过来的查询数据\n       UserQuery uq &#x3D; new UserQuery();\n       uq.setAge(10);\n       uq.setAge2(30);\n       LambdaQueryWrapper&lt;User&gt; lqw &#x3D; new LambdaQueryWrapper&lt;User&gt;();\n       lqw.lt(null!&#x3D;uq.getAge2(),User::getAge, uq.getAge2());\n       lqw.gt(null!&#x3D;uq.getAge(),User::getAge, uq.getAge());\n       List&lt;User&gt; userList &#x3D; userDao.selectList(lqw);\n       System.out.println(userList);\n   &#125;\n\n查询投影\n查询结果包含模型类中的部分属性\n\n\n查询条件\n\n更多查询条件设置参看https://mybatis.plus/guide/wrapper.html#abstractwrapper\n映射匹配兼容性\n\n\n\nDML编程控制id生成策略控制不同的表应用不同的id生成策略\n\n日志：自增（1,2,3,4，……）\n购物订单：特殊规则（FQ23948AK3843）\n外卖单：关联地区日期等信息（10 04 20200314 34 91）\n关系表：可省略id\n……\n\n\n\n\n名称\n@TableId\n\n\n\n类型\n&#x3D;&#x3D;属性注解&#x3D;&#x3D;\n\n\n位置\n模型类中用于表示主键的属性定义上方\n\n\n作用\n设置当前类中主键属性的生成策略\n\n\n相关属性\nvalue(默认)：设置数据库表主键名称type:设置主键属性的生成策略，值查照IdType的枚举值\n\n\n@Data\n@TableName(&quot;tbl_user&quot;)\npublic class User &#123;\n    @TableId(type &#x3D; IdType.AUTO)\n    private Long id;\n    private String name;\n    @TableField(value&#x3D;&quot;pwd&quot;,select&#x3D;false)\n    private String password;\n    private Integer age;\n    private String tel;\n    @TableField(exist&#x3D;false)\n    private Integer online;\n&#125;\n\n能不能在某一处进行配置，就能让所有的模型类都可以使用该主键ID策略呢?\n答案是肯定有，我们只需要在配置文件中添加如下内容:\nmybatis-plus:\n  global-config:\n    db-config:\n    \tid-type: assign_id\n\n配置完成后，每个模型类的主键ID策略都将成为assign_id.\n数据库表与模型类的映射关系MP会默认将模型类的类名名首字母小写作为表名使用，假如数据库表的名称都以tbl_开头，那么我们就需要将所有的模型类上添加@TableName\n配置起来还是比较繁琐，简化方式为在配置文件中配置如下内容:\nmybatis-plus:\n  global-config:\n    db-config:\n    \ttable-prefix: tbl_\n\n设置表的前缀内容，这样MP就会拿 tbl_加上模型类的首字母小写，就刚好组装成数据库的表名。\n多记录操作具体该如何实现多条删除，我们找找对应的API方法\nint deleteBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);\n\n除了按照id集合进行批量删除，也可以按照id集合进行批量查询，还是先来看下API\nList&lt;T&gt; selectBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);\n\n逻辑删除\n删除操作业务问题：业务数据从数据库中丢弃\n\n逻辑删除：为数据设置是否可用状态字段，删除时设置状态字段为不可用状态，数据保留在数据库中\n\n\n修改数据库表添加deleted列字段名可以任意，内容也可以自定义，比如0代表正常，1代表删除，可以在添加列的同时设置其默认值为0正常。\n实体类添加属性(1)添加与数据库表的列对应的一个属性名，名称可以任意，如果和数据表列名对不上，可以使用@TableField进行关系映射，如果一致，则会自动对应。\n(2)标识新增的字段为逻辑删除字段，使用@TableLogic\n@Data\n&#x2F;&#x2F;@TableName(&quot;tbl_user&quot;) 可以不写是因为配置了全局配置\npublic class User &#123;\n    @TableId(type &#x3D; IdType.ASSIGN_UUID)\n    private String id;\n    private String name;\n    @TableField(value&#x3D;&quot;pwd&quot;,select&#x3D;false)\n    private String password;\n    private Integer age;\n    private String tel;\n    @TableField(exist&#x3D;false)\n    private Integer online;\n    @TableLogic(value&#x3D;&quot;0&quot;,delval&#x3D;&quot;1&quot;)\n    &#x2F;&#x2F;value为正常数据的值，delval为删除数据的值\n    private Integer deleted;\n&#125;\n\n运行删除方法@SpringBootTest\nclass Mybatisplus03DqlApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n\t\n    @Test\n    void testDelete()&#123;\n       userDao.deleteById(1L);\n    &#125;\n&#125;\n\nMP的逻辑删除会将所有的查询都添加一个未被删除的条件，也就是已经被删除的数据是不应该被查询出来的。\n如果每个表都要有逻辑删除，那么就需要在每个模型类的属性上添加@TableLogic注解，如何优化?\n在配置文件中添加全局配置，如下:\nmybatis-plus:\n  global-config:\n    db-config:\n      # 逻辑删除字段名\n      logic-delete-field: deleted\n      # 逻辑删除字面值：未删除为0\n      logic-not-delete-value: 0\n      # 逻辑删除字面值：删除为1\n      logic-delete-value: 1\n\n逻辑删除本质逻辑删除的本质其实是修改操作。如果加了逻辑删除字段，查询数据时也会自动带上逻辑删除字段。\n执行的SQL语句为:\nUPDATE tbl_user SET &#x3D;&#x3D;deleted&#x3D;&#x3D;&#x3D;1 where id &#x3D; ? AND &#x3D;&#x3D;deleted&#x3D;&#x3D;&#x3D;0\n乐观锁\n业务并发现象带来的问题：秒杀\n\n步骤1:数据库表添加列列名可以任意，比如使用version,给列设置默认值为1\n步骤2:在模型类中添加对应的属性根据添加的字段列名，在模型类中添加对应的属性值\n@Data\n&#x2F;&#x2F;@TableName(&quot;tbl_user&quot;) 可以不写是因为配置了全局配置\npublic class User &#123;\n    @TableId(type &#x3D; IdType.ASSIGN_UUID)\n    private String id;\n    private String name;\n    @TableField(value&#x3D;&quot;pwd&quot;,select&#x3D;false)\n    private String password;\n    private Integer age;\n    private String tel;\n    @TableField(exist&#x3D;false)\n    private Integer online;\n    private Integer deleted;\n    @Version\n    private Integer version;\n&#125;\n\n步骤3:添加乐观锁的拦截器@Configuration\npublic class MpConfig &#123;\n    @Bean\n    public MybatisPlusInterceptor mpInterceptor() &#123;\n        &#x2F;&#x2F;1.定义Mp拦截器\n        MybatisPlusInterceptor mpInterceptor &#x3D; new MybatisPlusInterceptor();\n        &#x2F;&#x2F;2.添加乐观锁拦截器\n        mpInterceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());\n        return mpInterceptor;\n    &#125;\n&#125;\n\n步骤4:执行更新操作@SpringBootTest\nclass Mybatisplus03DqlApplicationTests &#123;\n\n    @Autowired\n    private UserDao userDao;\n\t\n    @Test\n    void testUpdate()&#123;\n       User user &#x3D; new User();\n        user.setId(3L);\n        user.setName(&quot;Jock666&quot;);\n        user.setVersion(1);\n        userDao.updateById(user);\n    &#125;\n&#125;\n\n代码生成器\n模板: MyBatisPlus提供，可以自己提供，但是麻烦，不建议\n数据库相关配置:读取数据库获取表和字段信息\n开发者自定义配置:手工配置，比如ID生成策略\n\n步骤：\n\n添加依赖\n&lt;!--代码生成器--&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt;\n&lt;artifactId&gt;mybatis-plus-generator&lt;&#x2F;artifactId&gt;\n&lt;version&gt;3.4.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n&lt;!--velocity模板引擎--&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;org.apache.velocity&lt;&#x2F;groupId&gt;\n&lt;artifactId&gt;velocity-engine-core&lt;&#x2F;artifactId&gt;\n&lt;version&gt;2.3&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n创建代码生成类\npublic class CodeGenerator &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;1.获取代码生成器的对象\n        AutoGenerator autoGenerator &#x3D; new AutoGenerator();\n\n        &#x2F;&#x2F;设置数据库相关配置\n        DataSourceConfig dataSource &#x3D; new DataSourceConfig();\n        dataSource.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n        dataSource.setUrl(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatisplus_db?serverTimezone&#x3D;UTC&quot;);\n        dataSource.setUsername(&quot;root&quot;);\n        dataSource.setPassword(&quot;root&quot;);\n        autoGenerator.setDataSource(dataSource);\n\n        &#x2F;&#x2F;设置全局配置\n        GlobalConfig globalConfig &#x3D; new GlobalConfig();\n        globalConfig.setOutputDir(System.getProperty(&quot;user.dir&quot;)+&quot;&#x2F;mybatisplus_04_generator&#x2F;src&#x2F;main&#x2F;java&quot;);    &#x2F;&#x2F;设置代码生成位置\n        globalConfig.setOpen(false);    &#x2F;&#x2F;设置生成完毕后是否打开生成代码所在的目录\n        globalConfig.setAuthor(&quot;黑马程序员&quot;);    &#x2F;&#x2F;设置作者\n        globalConfig.setFileOverride(true);     &#x2F;&#x2F;设置是否覆盖原始生成的文件\n        globalConfig.setMapperName(&quot;%sDao&quot;);    &#x2F;&#x2F;设置数据层接口名，%s为占位符，指代模块名称\n        globalConfig.setIdType(IdType.ASSIGN_ID);   &#x2F;&#x2F;设置Id生成策略\n        autoGenerator.setGlobalConfig(globalConfig);\n\n        &#x2F;&#x2F;设置包名相关配置\n        PackageConfig packageInfo &#x3D; new PackageConfig();\n        packageInfo.setParent(&quot;com.aaa&quot;);   &#x2F;&#x2F;设置生成的包名，与代码所在位置不冲突，二者叠加组成完整路径\n        packageInfo.setEntity(&quot;domain&quot;);    &#x2F;&#x2F;设置实体类包名\n        packageInfo.setMapper(&quot;dao&quot;);   &#x2F;&#x2F;设置数据层包名\n        autoGenerator.setPackageInfo(packageInfo);\n\n        &#x2F;&#x2F;策略设置\n        StrategyConfig strategyConfig &#x3D; new StrategyConfig();\n        strategyConfig.setInclude(&quot;tbl_user&quot;);  &#x2F;&#x2F;设置当前参与生成的表名，参数为可变参数\n        strategyConfig.setTablePrefix(&quot;tbl_&quot;);  &#x2F;&#x2F;设置数据库表的前缀名称，模块名 &#x3D; 数据库表名 - 前缀名  例如： User &#x3D; tbl_user - tbl_\n        strategyConfig.setRestControllerStyle(true);    &#x2F;&#x2F;设置是否启用Rest风格\n        strategyConfig.setVersionFieldName(&quot;version&quot;);  &#x2F;&#x2F;设置乐观锁字段名\n        strategyConfig.setLogicDeleteFieldName(&quot;deleted&quot;);  &#x2F;&#x2F;设置逻辑删除字段名\n        strategyConfig.setEntityLombokModel(true);  &#x2F;&#x2F;设置是否启用lombok\n        autoGenerator.setStrategy(strategyConfig);\n        &#x2F;&#x2F;2.执行生成操作\n        autoGenerator.execute();\n    &#125;\n&#125;\n\n对于代码生成器中的代码内容，我们可以直接从官方文档中获取代码进行修改\nhttps://mp.baomidou.com/guide/generator.html\n","slug":"SSM","date":"2022-07-26T08:33:15.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"2d34257e8e68ae00ecf08b330efedcd5","title":"Web核心","content":"Web概述JavaWeb技术栈\nB&#x2F;S架构：Browser&#x2F;Server，浏览器&#x2F;服务器 架构模式，它的特点是，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web资源，服务器把Web资源发送给浏览器即可\n\n好处：易于维护升级：服务器升级苟，客户端无需任何不输就可以使用到新的版本\n\n\n静态资源：HTML  CSS  JavaScript  图片等。 负责页面展现\n\n动态资源：Servlet  Jsp等。 负责逻辑处理\n\n数据库：负责存储数据\n\n\n\nHTTP\n概念：HyperText  Transfer  Protocol， 超文本传输协议，规定了浏览器和服务器之间数据传输的规则\n\nHTTP协议特点：\n1.基于TCP协议：面向连接，安全\n2.基于请求-响应模型：一次请求对应一次响应\n3.HTTP协议是无状态的协议：对于事务处理没有记忆能力。每次请求-响应都是独立的\n\n缺点：多次请求间不能共享数据       Java中使用会话技术（Cookie、Session）来解决\n有点：速度快\n\n\n\n请求数据格式\n请求数据分为三部分：\n\n1.请求行：请求数据的第一行。其中GET表示请求方式，&#x2F;表示请求资源路径，HTTP&#x2F;1.1表示协议版本\n2.请求头：第二行开始，格式为key：value形式，常见的HTTP请求头有:\nHost: 表示请求的主机名\nUser-Agent: 浏览器版本,例如Chrome浏览器的标识类似Mozilla&#x2F;5.0 ...Chrome&#x2F;79，IE浏览器的标识类似Mozilla&#x2F;5.0 (Windows NT ...)like Gecko；\nAccept：表示浏览器能接收的资源类型，如text&#x2F;*，image&#x2F;*或者*&#x2F;*表示所有；\nAccept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页；\nAccept-Encoding：表示浏览器可以支持的压缩类型，例如gzip, deflate等。\n\n3.请求体：POST请求的最后一部分，存放请求参数\n\n\n响应数据格式\n1.响应行：响应数据的第一行。其中HTTP&#x2F;1.1表示协议版本，200表示响应状态码，OK表示状态码描述\n\n2.响应头：第二行开始，格式为key：value形式，常见的HTTP响应头有:\nContent-Type：表示该响应内容的类型，例如text&#x2F;html，image&#x2F;jpeg；\nContent-Length：表示该响应内容的长度（字节数）；\nContent-Encoding：表示该响应压缩算法，例如gzip；\nCache-Control：指示客户端应如何缓存，例如max-age&#x3D;300表示可以最多缓存300秒\n\n3.响应体：最后一部分。存放相应数据\n\n\n\n一、状态码大类\n\n\n状态码分类\n说明\n\n\n\n1xx\n响应中——临时状态码，表示请求已经接受，告诉客户端应该继续请求或者如果它已经完成则忽略它\n\n\n2xx\n成功——表示请求已经被成功接收，处理已完成\n\n\n3xx\n重定向——重定向到其它地方：它让客户端再发起一个请求以完成整个处理。\n\n\n4xx\n客户端错误——处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等\n\n\n5xx\n服务器端错误——处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等\n\n\n状态码大全：https://cloud.tencent.com/developer/chapter/13553 \n二、常见的响应状态码\n\n\n状态码\n英文描述\n解释\n\n\n\n200\nOK\n客户端请求成功，即处理成功，这是我们最想看到的状态码\n\n\n302\nFound\n指示所请求的资源已移动到由Location响应头给定的 URL，浏览器会自动重新访问到这个页面\n\n\n304\nNot Modified\n告诉客户端，你请求的资源至上次取得后，服务端并未更改，你直接用你本地缓存吧。隐式重定向\n\n\n400\nBad Request\n客户端请求有语法错误，不能被服务器所理解\n\n\n403\nForbidden\n服务器收到请求，但是拒绝提供服务，比如：没有权限访问相关资源\n\n\n404\nNot Found\n请求资源不存在，一般是URL输入有误，或者网站资源被删除了\n\n\n428\nPrecondition Required\n服务器要求有条件的请求，告诉客户端要想访问该资源，必须携带特定的请求头\n\n\n429\nToo Many Requests\n太多请求，可以限制客户端请求某个资源的数量，配合 Retry-After(多长时间后可以请求)响应头一起使用\n\n\n431\n Request Header Fields Too Large\n请求头太大，服务器不愿意处理请求，因为它的头部字段太大。请求可以在减少请求头域的大小后重新提交。\n\n\n405\nMethod Not Allowed\n请求方式有误，比如应该用GET请求方式的资源，用了POST\n\n\n500\nInternal Server Error\n服务器发生不可预期的错误。服务器出异常了，赶紧看日志去吧\n\n\n503\nService Unavailable\n服务器尚未准备好处理请求，服务器刚刚启动，还未初始化好\n\n\n511\nNetwork Authentication Required\n客户端需要进行身份验证才能获得网络访问权限\n\n\nTomcatWeb服务器是一个应用程序（软件），对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作，让开发更加便捷，主要功能是提供网上信息浏览服务 \n作用：\n\n封装HTTP协议操作，简化开发\n可以将web项目部署到服务器中，对外提供网上浏览服务\n\nTomcat是一个轻量级的Web服务器，支持Servlet&#x2F;JSP少量JavaEE规范，也称为Web服务器，Servlet容器\n基本使用\n部署项目\nIDEA中创建Maven Web项目项目结构：\n创建方法1、\n2、\nIDEA集成本地Tomcat\nIDEA中使用Tomcat - Tomcat Maven插件1.pom.xml添加Tomcat插件\n&lt;build&gt;\n    &lt;plugins&gt;\n    \t&lt;!--Tomcat插件 --&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.apache.tomcat.maven&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;tomcat7-maven-plugin&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;2.2&lt;&#x2F;version&gt;\n        &lt;&#x2F;plugin&gt;\n    &lt;&#x2F;plugins&gt;\n&lt;&#x2F;build&gt;\n\n2.使用Maven Helper 插件快速启动项目，选中项目，右键 Run Maven –&gt; tomcat7:run\nServlet\nServlet是java提供的一门动态Web资源开发技术\nServlet是javaEE规范之一，其实就是一个接口，将来我们要定义Servlet类来访问Servlet接口，并由web服务器运行Servlet\n\nServlet快速入门1.创建一个项目，导入Servlet依赖坐标\n&lt;dependency&gt;\n    &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;javax.servlet-api&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;3.1.0&lt;&#x2F;version&gt;\n    &lt;!--\n      此处为什么需要添加该标签?\n      provided指的是在编译和测试过程中有效,最后生成的war包时不会加入\n       因为Tomcat的lib目录中已经有servlet-api这个jar包，如果在生成war包的时候生效就会和Tomcat中的jar包冲突，导致报错\n    --&gt;\n    &lt;scope&gt;provided&lt;&#x2F;scope&gt;\n&lt;&#x2F;dependency&gt;\n\n\n\n2.创建：定义一个类，实现Servlet接口，并重写接口中的所有方法，并在service方法中输入一句话\npackage com.itheima.web;\n\nimport javax.servlet.*;\nimport java.io.IOException;\n\npublic class ServletDemo1 implements Servlet &#123;\n\n    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;\n        System.out.println(&quot;servlet hello world~&quot;);\n    &#125;\n    public void init(ServletConfig servletConfig) throws ServletException &#123;\n\n    &#125;\n\n    public ServletConfig getServletConfig() &#123;\n        return null;\n    &#125;\n\n    public String getServletInfo() &#123;\n        return null;\n    &#125;\n\n    public void destroy() &#123;\n\n    &#125;\n&#125;\n\n\n\n3.配置: 在类上使用@WebServlet注解，配置该Servlet的访问路径\n@WebServlet(&quot;&#x2F;demo1&quot;)\n\n\n\n4.访问:启动Tomcat，浏览器输入URL访问该Servlet\nhttp:&#x2F;&#x2F;localhost:8080&#x2F;web-demo&#x2F;demo1\n\nServlet执行流程Servlet生命周期\n对象的生命周期指一个对象从被创建到被销毁的整个过程\n\nServlet运行在Servlet容器（Web服务器）中，其生命周期由容器来管理，分为4个阶段\n1.加载和实例化：默认情况下，当Servlet第一次被访问时，其容器创建Servlet对象\n\n\n\t\n默认情况，Servlet会在第一次访问被容器创建，但是如果创建Servlet比较耗时的话，\n那么第一个访问的人等待的时间就比较长，用户的体验就比较差，\n那么我们能不能把Servlet的创建放到服务器启动的时候来创建，具体如何来配置?\n\n@WebServlet(urlPatterns &#x3D; &quot;&#x2F;demo1&quot;,loadOnStartup &#x3D; 1)\nloadOnstartup的取值有两类情况\n（1）负整数:第一次访问时创建Servlet对象\n（2）0或正整数:服务器启动时创建Servlet对象，数字越小优先级越高\n\n2.初始化：在Servlet实例化之后，容器将调用Servlet的init()方法来初始化这个对象，完成一些如加载配置文件、创建连接等初始化的工作。该方法只调用一次\n3.请求处理：每次请求Servlet时，Servlet容器都会调用Servlet的service()方法对请求进行处理\n4.服务终止：当需要释放内存或容器关闭时，容器就会调用Servlet实例的destory()方法完成资源的释放。在destory()方法调用之后，容器会释放这个Servlet实例，该实例随后会被java的垃圾收集器所回收\nServlet方法介绍\n初始化方法，在Servlet被创建时执行，只执行一次\n\nvoid init(ServletConfig config) \n\n\n提供服务方法， 每次Servlet被访问，都会调用该方法\n\nvoid service(ServletRequest req, ServletResponse res)\n\n\n销毁方法，当Servlet被销毁时，调用该方法。在内存释放或服务器关闭时销毁Servlet\n\nvoid destroy() \n\n剩下的两个方法是:\n\n获取Servlet信息\n\nString getServletInfo() \n&#x2F;&#x2F;该方法用来返回Servlet的相关信息，没有什么太大的用处，一般我们返回一个空字符串即可\npublic String getServletInfo() &#123;\n    return &quot;&quot;;\n&#125;\n\n\n获取ServletConfig对象\n\nServletConfig getServletConfig()\n\nServlet体系结构\n我们将来开发B&#x2F;S架构的web项目，都是针对HTTP协议，所以我们自定义Servlet，会继承HttpServlet\n\nHttpServlet使用步骤\n\n继承HttpServlet\n重写doGet和doPost方法\n\n\nHttpServlet原理\n获取请求方式，并根据不同的请求方式，调用不同的doXxx方法。\n\n\nServlet urlPattern配置\n优先级：1&gt;2&gt;3&gt;&#x2F;*&gt;&#x2F;\nXML配置Servlet前面对应Servlet的配置，我们都使用的是@WebServlet,这个是Servlet从3.0版本后开始支持注解配置，3.0版本前只支持XML配置文件的配置方法。\n对于XML的配置步骤有两步:\n\n编写Servlet类\n\n在web.xml中配置该Servlet 代码如下：\n&lt;servlet&gt;\n       &lt;!-- servlet的名称，名字任意--&gt;\n       &lt;servlet-name&gt;demo13&lt;&#x2F;servlet-name&gt;\n       &lt;!--servlet的类全名--&gt;\n       &lt;servlet-class&gt;com.itheima.web.ServletDemo13&lt;&#x2F;servlet-class&gt;\n   &lt;&#x2F;servlet&gt;\n  \n   &lt;!-- \n       Servlet 访问路径\n   --&gt;\n   &lt;servlet-mapping&gt;\n       &lt;!-- servlet的名称，要和上面的名称一致--&gt;\n       &lt;servlet-name&gt;demo13&lt;&#x2F;servlet-name&gt;\n       &lt;!-- servlet的访问路径--&gt;\n       &lt;url-pattern&gt;&#x2F;demo13&lt;&#x2F;url-pattern&gt;\n   &lt;&#x2F;servlet-mapping&gt;\n\nRequestRequest继承体系\nRequest获取数据请求参数HTTP请求数据总共分为三部分内容，分别是  请求行、请求头、请求体\nRequest获取请求行数据请求行包含三块内容，分别是请求方式、请求资源路径、HTTP协议及版本\n\n对于这三部分内容，request对象都提供了对应的API方法来获取，具体如下:\n\n获取请求方式GET\n\nString getMethod()\n\n\n获取虚拟目录（项目访问路径）/request-demo\n\nSting getContextPath()\n\n\n获取URL（统一资源定位符）https://localhost:8080/request-demo/req1\n\nStringBuffer getRequestURL()\n\n\n获取URI(统一资源标识符)request-demo/req1\n\nString getRequestURI()\n\n\n获取请求参数(GET方式)username=zhangsan&amp;password=123\n\nSting getQueryString()\n\n例：\n&#x2F;**\n * request 获取请求数据\n *&#x2F;\n@WebServlet(&quot;&#x2F;req1&quot;)\npublic class RequestDemo1 extends HttpServlet &#123;\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        &#x2F;&#x2F; String getMethod()：获取请求方式： GET\n        String method &#x3D; req.getMethod();\n        System.out.println(method);&#x2F;&#x2F;GET\n        &#x2F;&#x2F; String getContextPath()：获取虚拟目录(项目访问路径)：&#x2F;request-demo\n        String contextPath &#x3D; req.getContextPath();\n        System.out.println(contextPath);\n        &#x2F;&#x2F; StringBuffer getRequestURL(): 获取URL(统一资源定位符)：http:&#x2F;&#x2F;localhost:8080&#x2F;request-demo&#x2F;req1\n        StringBuffer url &#x3D; req.getRequestURL();\n        System.out.println(url.toString());\n        &#x2F;&#x2F; String getRequestURI()：获取URI(统一资源标识符)： &#x2F;request-demo&#x2F;req1\n        String uri &#x3D; req.getRequestURI();\n        System.out.println(uri);\n        &#x2F;&#x2F; String getQueryString()：获取请求参数（GET方式）： username&#x3D;zhangsan\n        String queryString &#x3D; req.getQueryString();\n        System.out.println(queryString);\n    &#125;\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n    &#125;\n&#125;\n\n获取请求头数据对于请求头的数据，格式为key: value如下：\n\n所以根据请求头名称获取对应值的方法为:\nString getHeader(String name)\n\n获取请求体数据浏览器在发送GET请求的时候是没有请求体的，所以需要把请求方式变更为POST，请求体中的数据格式如下:\n\n\n获取字节输入流，如果前端发送的是字节数据，比如传递的是文件数据，则使用该方法\n\nServletInputStream getInputStream()\n该方法可以获取字节\n\n\n获取字符输入流，如果前端发送的是纯文本数据，则使用该方法\n\nBufferedReader getReader()\n\n\n\n具体实现的步骤如下:\n1.准备一个页面，在页面中添加form表单,用来发送post请求\n2.在Servlet的doPost方法中获取请求体数据\n3.在doPost方法中使用request的getReader()或者getInputStream()来获取\n4.访问测试\n获取请求参数的通用方式\n\n获取所有参数Map集合\n\nMap&lt;String,String[]&gt; getParameterMap()\n\n\n根据名称获取参数值（数组）\n\nString[] getParameterValues(String name)\n\n\n根据名称获取参数值(单个值)\n\nString getParameter(String name)\n\npublic class RequestDemo1 extends HttpServlet &#123;\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n       &#x2F;&#x2F;采用request提供的获取请求参数的通用方式来获取请求参数\n       &#x2F;&#x2F;编写其他的业务代码...\n    &#125;\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        this.doGet(req,resp);\n    &#125;\n&#125;\n\n请求参数中文乱码处理\n请求参数如果存在中文数据，则会乱码\n\n解决方案：\n\nPOST:设置输入流的编码\nreq.setCharacterEncoding(&quot;UTF-8&quot;);\n\n通用方式（GET&#x2F;POST）：先编码，再解码\nnew String(username.getBytes(&quot;ISO-8859-\t1&quot;),&quot;UTF-8&quot;);\n\n\n\nRequest请求转发\n请求转发：一种在服务器的内部资源跳转方式\n\n\n\n实现方式：\nreq.getRequestDispatcher(&quot;资源B路径&quot;).forward(req,resp);\n\n请求转发资源间共享数据:使用Request对象\n\nvoid setAttribute(String name, Object o)：存储数据到request域中\nObject getAttribute(String name)：根据key，获取值\nvoid removAttribute(String name)：根据key，删除该键值对\n\n\n请求转发特点：\n\n浏览器地址栏领不发生变化\n只能转发到当前服务器的内部资源\n一次请求，可以在转发的资源间使用requset共享数据\n\n\n\nResponseResponse设置响应数据功能介绍\n响应数据分为3部分：\n\n响应行：\nHTTP&#x2F;1.1 200 OK\n\nvoid setStatus(int sc): 设置响应状态码\n\n响应头：\nContent-Type:text&#x2F;html\n\nvoid setHeader(String name, String value):设置响应头键值对\n\n响应体：\n&lt;html&gt;\n\t&lt;head&gt;\n\t\n\t&lt;head&gt;\n\t\n\t&lt;body&gt;\n\t\n\t&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\nprintWriter getWriter(): 获取字符输出流\nServletOutputStream getOutputStream():获取字节输出流\n\n\n\n\nResponse完成重定向\n重定向：一种资源跳转方式\n\n​\t\n资源路径问题\n建议动态获取虚拟目录：String contextPath &#x3D; request.getContextPath();\n重定向：response.sendRedirect(contextPath + “&#x2F;resp2”);\nResponse响应字符数据\n使用：\n1.通过Response对象获取字符输入流\nPrintWriter writer &#x3D; response.getWriter();\n\n2.写数据\nwriter.write(&quot;aaa&quot;);\n\n注意：\n\n该流不需要关闭，随着响应结束，Response对象销毁，由服务器关闭\n\n中文数据乱码：原因通过获取的字符输出流默认编码：ISO-8859-1\nresp.setContentType(&quot;text&#x2F;html;charset&#x3D;utf-8&quot;);\n\n\n\nResponse响应字节数据\n使用：\n1.通过Response对象获取字符输入流\nServletOutputStream outputStream &#x3D; resp.getOutputStream();\n\n2.写数据\noutputStream.write(字节数据);\n\nIOUtils工具类使用\n1.导入坐标\n&lt;dependency&gt;\n\t&lt;groupid&gt;commons-io&lt;&#x2F;groupid&gt;\n    &lt;artifactld&gt;commons-io&lt;&#x2F;artifactld&gt;\n    &lt;version&gt;2.6&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n2.使用\nIOUtils.copy(输入流，输出流);\n\nSqlSessionFactory代码优化String resource &#x3D; &quot;org&#x2F;mybatis&#x2F;example&#x2F;mybatis-config.xml&quot;;\nInputStream inputStream &#x3D; Resources.getResourceAsStream(resource);\nSqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);\n\n问题： \n​\t1.代码重复：       解决（工具类)\n​\t2.SqlSessionFactory工厂只创建一次，不要重复创建：  解决（静态代码块）\n我创建的工具类：\npackage com.itheima.util;\n\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\npublic class SqlSessionFactoryUtils &#123;\n    private static  SqlSessionFactory sqlSessionFactory;\n\n    static &#123;\n        &#x2F;&#x2F;静态代码块会随着类的加载自动执行，且只执行一次\n        try &#123;\n            String resource &#x3D; &quot;mybatis-config.xml&quot;;\n            InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);\n            SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);\n        &#125; catch (IOException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n    public static SqlSessionFactory getSqlSessionFactory()&#123;\n        return sqlSessionFactory;\n    &#125;\n&#125;\n\nJSP\nJava Server Pages ，Java服务端页面\n一种动态的网页技术，其中既可以定义HTML,JS,CSS等静态内容，还可以定义Java代码的动态内容\nJSP &#x3D; HTML + Java\n作用：简化开发，避免了在Servlet中直接输出HTML标签\n\n快速入门\n缺点\nEL表达式\n用于简化JSP页面内的Java代码\n\n主要功能：获取数据\n\n语法：${expression}\n$&#123;brands&#125;\n\n获取域中存储key为brands的数据\n\nJavaWeb中的四大域对象：\n\npage:当前页面有效\nrequest:当前请求有效\nsession:当前会话有效\napplication:当前应用有效\n\n\n\n*el表达式获取数据，会依次从这4个域中寻找，直到找到为止\nJSTL标签\nJSP标签库（Jsp Standarded Tag Library），使用标签取代JSP页面上的Java代码\n\n\n\nMVC模式和三层架构MVC\nMVC是一种分层开发模式，其中：\n\nM:Model，业务模型，处理业务\nV:View，视图，页面展示\nC：Controller，控制器，处理请求，调用模型和视图\n\n\nMVC好处\n\n职责单一，互不影响\n有利于分工协作\n有利于组件重用\n\n\n\n三层架构\n案例\n会话跟踪技术\n会话：用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应\n会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自同一浏览器，以便在同义词绘画的多次请求间共享数据\nHTTP协议是无状态的，每次浏览器向服务器请求时，服务器都会将该请求视为新的请求，因此我们需要会话跟踪技术来实现会话内数据共享\n实现方式：\n客户端会话跟踪技术：Cookie\n服务端会话跟踪技术：Session\n\n\n\nCookieCookie:客户端会话技术，将数据保存到客户端，以后每次请求都携带Cookie数据进行访问\nCookie基本使用发送Cookie1.创建Cookie对象，设置数据\nCookie cookie &#x3D; new Cookie(&quot;key&quot;,&quot;value&quot;);\n\n2.发送Cookie到客户端：使用response对象\nresponse.addCookie(cookie);\n\n获取Cookie3.获取客户端携带的所有Cookie，使用request对象\nCookie[] cookies &#x3D; request.getCookies();\n\n4.遍历数组，获取每一个Cookie对象：for\n5.使用Cookie对象方法获取数据\ncookie.getName();\n\ncookie.getValue();\n\nCookie原理\nCookie使用细节\nCookie存活时间：\n\n​\t-默认情况下，Cookie存储爱浏览器内存中，当浏览器关闭，内存释放，则Cookie被销毁\n​\tsetMaxAge（int seconds）：设置Cookie存活时间\n​\t\t1.正数：将Cookie写入浏览器所爱电脑的硬盘，持久化存储，到时见自动删除\n​\t\t2.负数：默认值，Cookie在当前浏览器内存中，当浏览器关闭，则Cookie被销毁\n​\t\t2.零：删除对应Cookie\n\nCookie存储中文\nCookie不能直接存储中文\n如需要存储，则需要进行转码：URL编码，使用时再解码\n\n\nSessionSession：服务端会话跟踪技术，将数据保存到服务端\nJavaEE提供HttpSession接口，来实现一次会话的多次请求间数据共享功能\nSession基本使用1.获取Session对象：\nHttpSession session &#x3D; request.getSession();\n\n2.Session对象功能：\n(1) void setAttribute(String name, Object o): 存储数据到session域中\n(2)Object getAttribute(String name):根据key，获取值\n(3)void removeAttribute(String name):根据key，删除该键值对\nSession原理\nSession是基于Cookie实现的\n\n在一次会话的多次请求之间获取的session对象是同一个\n\n\n\nSession使用细节\nSession钝化，活化：\n\n钝化：在服务器正常关闭后，Tomcat会自动将Session数据写入硬盘的文件\n活化：再次启动服务器后，从文件中加载到Session中\n\n\nSession销毁： \n\n默认情况下，无操作，30分钟自动销毁\n&lt;session-config&gt;\n\t&lt;session-timeout&gt;30&lt;&#x2F;session-timeout&gt;\n&lt;session-config&gt;\t\n\n调用Session对象的invalidate()方法\n\n\n\n\n小结\nCookie和Session都是来完成一次会话内多次请求建数据共享的\n区别：\n存储位置：Cookie是将数据存储在客户端，Session将数据存储在服务端\n安全性：Cookie不安全，Session安全\n数据大小：Cookie最大3KB，Session无大小限制\n存储时间：Cookie可以长期存储，Session默认30分钟\n服务器性能：Cookie不占服务器资源，Session占用服务器资源\n\n\n\nFilter\n概念：Filter表示过滤器，是Javaweb三大组件（Servlet，Filter，Listener）之一\n过滤器可以把对资源的请求拦截下来，从未实现一些特殊的功能\n过滤器一般完成一些通用的操作，比如：权限控制，统一编码处理，敏感字符处理等等……\n\n快速入门\n执行流程\n使用细节拦截路径配置\nFilter可以根据需求，配置不同的拦截资源路径\n@WebFilter(“&#x2F;*”)\npublic class FilterDemo\n\n拦截具体的资源：&#x2F;index.jsp: 只有访问index.jsp时才会被拦截\n目录拦截：&#x2F;user&#x2F;*:访问&#x2F;user下的所有资源，都会被拦截\n后缀名拦截：*.jsp：访问后缀名为jsp的资源，都会被拦截\n拦截所有：&#x2F;*：访问所有的资源，都会被拦截\n\n\n\n过滤器链\n一个Web应用，可以配置多个过滤器，这多个过滤器称为过滤器链\n\n\n\n注解配置的Filter，优先级按照过滤器类名（字符串）的自然排序\n\nListener\n概念：Listener是监听器，是JavaWeb三大组件(Servlet,Filter,Listener)之一\n\n监听器可以监听就是在application，session，request三个对象创建，销毁或者往其中添加修改删除属性时自动执行代码的功能组件\n\nListener分类：JavaWeb提供了8个监听器\n\n\n\n\nAJAX\n概念：异步的Javascript和XML\n\nAJAX作用：\n1.与服务器进行数据交换：通过AJAX可以给服务器发送请求，并获取服务器响应的数据\n\n使用了AJAX和服务器进行通信，就可以使用HTML+AJAX来替换JSP页面了\n\n2.异步交互：可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术，如：搜索联想，用户名是否可用校验，等等……\n异步和同步\n\n\nAJAX快速入门\nAxios异步框架\nAxios对原生的AJAX进行封装，简化书写\n官网：http://www.axios-http.cn\n\n将js文件 &#x2F;放到项目的webapp目录下\n\n引入 axios 的 js 文件\n&lt;script src&#x3D;&quot;js&#x2F;axios-0.18.0.js&quot;&gt;&lt;&#x2F;script&gt;\n\n使用axios 发送请求，并获取响应结果\n\n发送 get 请求\naxios(&#123;\n    method:&quot;get&quot;,\n    url:&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;ajax-demo1&#x2F;aJAXDemo1?username&#x3D;zhangsan&quot;\n&#125;).then(function (resp)&#123;\n    alert(resp.data);\n&#125;)\n\n发送 post 请求\naxios(&#123;\n    method:&quot;post&quot;,\n    url:&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;ajax-demo1&#x2F;aJAXDemo1&quot;,\n    data:&quot;username&#x3D;zhangsan&quot;\n&#125;).then(function (resp)&#123;\n    alert(resp.data);\n&#125;);\n\n整体页面代码如下：\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n\n&lt;script src&#x3D;&quot;js&#x2F;axios-0.18.0.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script&gt;\n    &#x2F;&#x2F;1. get\n   &#x2F;* axios(&#123;\n        method:&quot;get&quot;,\n        url:&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;ajax-demo&#x2F;axiosServlet?username&#x3D;zhangsan&quot;\n    &#125;).then(function (resp) &#123;\n        alert(resp.data);\n    &#125;)*&#x2F;\n\n    &#x2F;&#x2F;2. post  在js中&#123;&#125; 表示一个js对象，而这个js对象中有三个属性\n    axios(&#123;\n        method:&quot;post&quot;,\n        url:&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;ajax-demo&#x2F;axiosServlet&quot;,\n        data:&quot;username&#x3D;zhangsan&quot;\n    &#125;).then(function (resp) &#123;\n        alert(resp.data);\n    &#125;)\n&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n请求别名方式入门案例中的 get 请求代码可以改为如下：\naxios.get(&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;ajax-demo&#x2F;axiosServlet?username&#x3D;zhangsan&quot;).then(function (resp) &#123;\n    alert(resp.data);\n&#125;);\n\n入门案例中的 post 请求代码可以改为如下：\naxios.post(&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;ajax-demo&#x2F;axiosServlet&quot;,&quot;username&#x3D;zhangsan&quot;).then(function (resp) &#123;\n    alert(resp.data);\n&#125;)\n\nJSON\nJavaScript Object Notation。 JavaScript对象表示法\n\n由于其语法简单，层次结构鲜明，现多用于作为数据载体，在网络中进行数据传输\n\n\nJSON基础语法\nJSON数据和JAVA对象的转换\nFastjson 是阿里巴巴提供的一个Java语言编写的高性能功能完善的 JSON 库，是目前Java语言中最快的 JSON 库，可以实现 Java 对象和 JSON 字符串的相互转换。\n\n导入坐标\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.2.62&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\nJava对象转JSON\nString jsonStr &#x3D; JSON.toJSONString(obj);\n\n将 Java 对象转换为 JSON 串，只需要使用 Fastjson 提供的 JSON 类中的 toJSONString() 静态方法即可。\n\nJSON字符串转Java对象\nUser user &#x3D; JSON.parseObject(jsonStr, User.class);\n\n将 json 转换为 Java 对象，只需要使用 Fastjson 提供的 JSON 类中的 parseObject() 静态方法即可。\n\n\nVUE\n免除原生JavaScript中的DOM操作，简化书写\n基于MVVM(Model-View-ViewModel)思想，实现数据的双向绑定，将编程的关注点放在数据上\n官网：https：&#x2F;&#x2F;cn.vuejs.org\n\n\nVue快速入门1.新建HTML页面，引入Vue.js文件\n&lt;script src&#x3D;&quot;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n\n2.在JS代码区域，创建Vue和新对象，进行数据绑定\nnew Vue(&#123;\n\tel:&quot;#app&quot;,\n\tdata()&#123;\n\t\treturn &#123;\n\t\t\tusername:&quot;&quot;\n\t\t&#125;\n\t&#125;\n&#125;)\n\n3.编写视图\n&lt;div&gt;\n    &lt;input name&#x3D;&quot;username&quot; v-model&#x3D;&quot;username&quot;&gt;\n    &#123;&#123;username&#125;&#125;\n&lt;&#x2F;div&gt;\n\n\n\nVue常用指令\n\n\n指令\n作用\n\n\n\nv-bind\n为HTML标签绑定属性值，如设置  href , css样式等\n\n\nv-model\n在表单元素上创建双向数据绑定\n\n\nv-on\n为HTML标签绑定事件\n\n\nv-if\n条件性的渲染某元素，判定为true时渲染,否则不渲染\n\n\nv-else\n\n\n\nv-else-if\n\n\n\nv-show\n根据条件展示某元素，区别在于切换的是display属性的值\n\n\nv-for\n列表渲染，遍历容器的元素或者对象的属性\n\n\n v-show 不展示的原理是给对应的标签添加 display css属性，并将该属性值设置为 none ，这样就达到了隐藏的效果。而 v-if 指令是条件不满足时根本就不会渲染。\nVue生命周期\n\nElement\nElement：是饿了么公司前端开发团队提供的一套基于Vue的网站组件库，用于快速构建网页\n组件：组成网页的部件，例如超链接，按钮，图片，表格等等\n\nElement快速入门 引入Element的css，js文件和vue.js\n&lt;script src&#x3D;&quot;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script src&#x3D;&quot;element-ui&#x2F;lib&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;element-ui&#x2F;lib&#x2F;theme-chalk&#x2F;index.css&quot;&gt;\n\n创建Vue核心对象\n&lt;script&gt;\n    new Vue(&#123;\n        el:&quot;#app&quot;\n    &#125;)\n&lt;&#x2F;script&gt;\n\n官网复制Element组件代码\nElement布局\n","slug":"Web核心","date":"2022-07-06T06:27:05.000Z","categories_index":"","tags_index":"JavaWeb","author_index":"Aurora"},{"id":"cf5277bd1519d645b084515a79fe0c20","title":"java的值传递和引用传递","content":"一、基本类型和引用类型的理解Java中的数据类型分为两种为基本类型和引用类型。\n1、基本类型的变量保存原始值，所以变量就是数据本身。\n  常见的基本类型：byte,short,int,long,char,float,double,Boolean,returnAddress。\n2、引用类型的变量保存引用值，所谓的引用值就是对象所在内存空间的“首地址值”，通过对这个引用值来操作对象。\n  常见的引用类型：类类型，接口类型和数组。\n二、值传递和引用传递的理解1、值传递  在方法的调用过程中，实参把它的实际值传递给形参，此传递过程就是将实参的值复制一份传递到函数中，这样如果在函数中对该值（形参的值）进行了操作将不会影响实参的值。因为是直接复制，所以这种方式在传递大量数据时，运行效率会特别低下。\n2、引用传递  引用传递弥补了值传递的不足，如果传递的数据量很大，直接复过去的话，会占用大量的内存空间，而引用传递就是将对象的地址值传递过去，函数接收的是原始值的首地址值。在方法的执行过程中，形参和实参的内容相同，指向同一块内存地址，也就是说操作的其实都是源数据，所以方法的执行将会影响到实际对象。\n举例说明：\npublic class Example &#123;\n    String str &#x3D; new String(&quot;hello&quot;);\n    char[] ch &#x3D; &#123;&#39;a&#39;, &#39;b&#39;&#125;;\n    public static void main(String[] args) &#123;\n        Example ex &#x3D; new Example();\n        ex.change(ex.str, ex.ch);\n        System.out.println(ex.str + &quot; and&quot;);\n        System.out.println(ex.ch);\n    &#125;\n\n    public void change(String str, char[] ch) &#123;\n        str &#x3D; &quot;ok&quot;;\n        ch[0] &#x3D; &#39;c&#39;;\n    &#125;\n&#125;\n\n输出是：\nhello and\ncb\n\n过程分析：\n1、为对象分配空间\n\n2、执行change()方法\n执行前实参（黑色）和形参（红色）的指向如下：\n\n因为String是不可变类且为值传递，而ch[]是引用传递，所以方法中的str &#x3D; “ok”,相当于重新创建一个对象并没有改变实参str的值，数组是引用传递，直接改变，所以执行完方法后，指向关系如下：\n\n3.结论通过上面的分析我们可以得出以下结论：\n基本数据类型传值，对形参的修改不会影响实参；引用类型传引用，形参和实参指向同一个内存地址（同一个对象），所以对参数的修改会影响到实际的对象。String, Integer, Double等immutable的类型特殊处理，可以理解为传值，最后的操作不会修改实参对象。\n哈希表中的特殊情况只要是哈希表中的原生类型，如Integer，String，尽管他们平时是引用传递，但在哈希表中是按值传递！！！\n非原生类型，按值传递，如自己定义的类型。\n","slug":"java的值传递和引用传递","date":"2022-07-05T08:53:49.000Z","categories_index":"","tags_index":"java基础知识","author_index":"Aurora"},{"id":"711e99b247f8f70b0f4cf84df30732b2","title":"Leetcode高频题总结","content":"剑指Offer06 从尾到头打印链表class Solution &#123;\n    int i;\n    int j;\n    int[] res;\n    public int[] reversePrint(ListNode head) &#123;\n        solve(head);\n        return res;\n    &#125;\n\n    public void solve(ListNode head)&#123;\n        if(head &#x3D;&#x3D; null)&#123;\n            res &#x3D; new int[i];\n            return;\n        &#125;\n        i ++;\n        solve(head.next);\n        res[j] &#x3D; head.val;\n        j ++;\n    &#125;\n&#125;\n\n\n\n15 二进制中1的个数\n位移法 时间复杂度O(N) N为二进制数的位数\npublic class Solution &#123;\n    &#x2F;&#x2F; you need to treat n as an unsigned value\n    public int hammingWeight(int n) &#123;\n        int res &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; 32; i ++)&#123;\n            if((n &amp; (1 &lt;&lt; i)) !&#x3D; 0)&#123;\n                res ++;\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;\n\n“与”操作法 【最优解法】时间复杂度O(K) K为二进制数中1的个数\npublic class Solution &#123;\n    &#x2F;&#x2F; you need to treat n as an unsigned value\n    public int hammingWeight(int n) &#123;\n        int res &#x3D; 0;\n        while(n !&#x3D; 0)&#123;\n            res ++;\n            n &#x3D; n &amp; (n - 1);\n            &#x2F;&#x2F;n &amp; (n-1)会将二进制代码中最后一位的1变成0\n        &#125;\n        return res;\n    &#125;\n&#125;\n\n18 删除链表的节点class Solution &#123;\n    public ListNode deleteNode(ListNode head, int val) &#123;\n        while(head !&#x3D; null)&#123;\n            if(head.val !&#x3D; val)&#123;\n                break;\n            &#125;\n            head &#x3D; head.next;\n        &#125; &#x2F;&#x2F;找到第一个非空的头结点，用于返回和执行下步操作\n        ListNode pre &#x3D; head;\n        ListNode cur &#x3D; head;\n        while(cur !&#x3D; null)&#123;\n            if(cur.val &#x3D;&#x3D; val)&#123;\n                pre.next &#x3D; cur.next;\n            &#125;else&#123;\n                pre &#x3D; cur;\n            &#125;\n            cur &#x3D; cur.next;\n        &#125;\n        return head;\n    &#125;\n&#125;\n\n24 反转链表class Solution &#123;\n    public ListNode reverseList(ListNode head) &#123;\n        ListNode pre &#x3D; null;\n        ListNode next &#x3D; head;\n        while(next!&#x3D;null)&#123;\n            next &#x3D; head.next;\n            head.next &#x3D; pre;\n            pre &#x3D; head;\n            head &#x3D; next;\n        &#125;\n        return pre;\n    &#125;\n&#125;\n\n35 复杂链表的复制class Solution &#123;\n    Map&lt;Node, Node&gt; res &#x3D; new HashMap&lt;&gt;();\n    public Node copyRandomList(Node head) &#123;\n        if(head &#x3D;&#x3D; null) return null;\n        if(!res.containsKey(head))&#123;\n            Node clone &#x3D; new Node(head.val);\n            res.put(head, clone);\n            clone.next &#x3D; copyRandomList(head.next);\n            clone.random &#x3D; copyRandomList(head.random);\n        &#125;\n        return res.get(head);\n    &#125;\n&#125;\n\n\n\n65 不用加减乘除做加法&#x2F;*\n思路：\n      首先看十进制是如何做的： 5+7&#x3D;12，三步走 第一步：相加各位的值，不算进位，得到2。\n      第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。\n      第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。 同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111 \n      第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。 \n      第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。 \n      第三步重复上述两步， 各位相加 010^1010&#x3D;1000，进位值为100&#x3D;(010&amp;1010)&lt;&lt;1。 继续重复上述两步：1000^100 &#x3D; 1100，进位值为0，跳出循环，1100为最终结果。\n*&#x2F;\npublic class Solution &#123;\n    public int Add(int num1,int num2) &#123;\n        while (num2!&#x3D;0) &#123;\n            int temp &#x3D; num1^num2;\n            num2 &#x3D; (num1&amp;num2)&lt;&lt;1;\n            num1 &#x3D; temp;\n        &#125;\n        return num1;\n    &#125;\n&#125;\n\n","slug":"Leetcode高频题总结","date":"2022-07-05T03:05:06.000Z","categories_index":"","tags_index":"算法与数据结构","author_index":"Aurora"},{"id":"6688690e355db1dd869bd788558b9211","title":"数据结构与算法学习","content":"由于之前并未完整成体系的学习算法，在力扣刷100道题后\n感觉到算法知识不成体系，决定看左程云的体系学习班学习算法\n学习路线\n搞定1,2,3差不多达到面试水平\n杂记子问题规模一样的递归可以用Master公式求时间复杂度\nT(N) &#x3D; a * T(N&#x2F;b) + O(N ^ d);\na:会有几次调用代码\nb:每次调用规模的大小\n\n如果 log（b , a) &lt; d 时间复杂度为： O(N^d)\n如果log (b , a) &gt; d 时间复杂度为 ： O(N^(log(b,a)))\n如果log（b , a）&#x3D;&#x3D; d 时间复杂度为：O(N^d * log(2,n)))注：log(b,a) 指以b为地a为指数\n\n基础的数据结构实现栈和队列用数组实现队列&#x2F;&#x2F; 给定一个长度被限制数组空间，如何实现队列？\npublic class RingArray&#123;\n    public static class MyQueue&#123;\n        private int[]arr;\n        private int pushi;\n        private int rolli;\n        private int size;\n        private final int limit;\n        \n        public MyQueue(int limit)&#123;\n            arr &#x3D; new int[limit];\n            pushi &#x3D; 0;\n            polli &#x3D; 0;\n            size &#x3D; 0;\n            this.limit &#x3D; limit;\n        &#125;\n        \n        public void push(int value)&#123;\n            if(size &#x3D;&#x3D; limit)&#123;\n                throw new RuntimeException(&quot;队列满了，不能再加了&quot;);\n            &#125;\n            size++;\n            arr[pushi] &#x3D; value;\n            pushi &#x3D; nextIndex(pushi);\n        &#125;\n        \n        public int pop()&#123;\n            if(size &#x3D;&#x3D; 0)&#123;\n                throw new RuntimeException(&quot;队列空了，不能再拿了&quot;);\n            &#125;\n            int ans &#x3D; arr[rolli];\n            rolli &#x3D; nextIndex(rolli);\n            return ans;\n        &#125;\n        \n        public boolean isEmpty()&#123;\n            return size &#x3D;&#x3D; 0;\n        &#125;\n        \n        private int nextIndex(int i)&#123;\n            return i &lt; limit - 1 ? i + 1: 0;\n        &#125;\n    &#125;\n&#125;\n\n数组实现一个特殊的栈，可实时返回栈中最小值&#x2F;&#x2F;在基本功能上，再实现返回栈中最小元素的功能，且pop、push、getMin操作的时间复杂度是O(1).\n\n&#x2F;&#x2F;思路：维护一个栈和一个最小值栈，最小栈中存此时栈中的最小值。\n\npublic class GetMinStack &#123;\n\n\tpublic static class MyStack &#123;\n\t\tprivate Stack&lt;Integer&gt; stackData;\n\t\tprivate Stack&lt;Integer&gt; stackMin;\n\n\t\tpublic MyStack2() &#123;\n\t\t\tthis.stackData &#x3D; new Stack&lt;Integer&gt;();\n\t\t\tthis.stackMin &#x3D; new Stack&lt;Integer&gt;();\n\t\t&#125;\n\n\t\tpublic void push(int newNum) &#123;\n\t\t\tif (this.stackMin.isEmpty()) &#123;\n\t\t\t\tthis.stackMin.push(newNum);\n\t\t\t&#125; else if (newNum &lt; this.getmin()) &#123;\n\t\t\t\tthis.stackMin.push(newNum);\n\t\t\t&#125; else &#123;\n\t\t\t\tint newMin &#x3D; this.stackMin.peek();\n\t\t\t\tthis.stackMin.push(newMin);\n\t\t\t&#125;\n\t\t\tthis.stackData.push(newNum);\n\t\t&#125;\n\n\t\tpublic int pop() &#123;\n\t\t\tif (this.stackData.isEmpty()) &#123;\n\t\t\t\tthrow new RuntimeException(&quot;Your stack is empty.&quot;);\n\t\t\t&#125;\n\t\t\tthis.stackMin.pop();\n\t\t\treturn this.stackData.pop();\n\t\t&#125;\n\n\t\tpublic int getmin() &#123;\n\t\t\tif (this.stackMin.isEmpty()) &#123;\n\t\t\t\tthrow new RuntimeException(&quot;Your stack is empty.&quot;);\n\t\t\t&#125;\n\t\t\treturn this.stackMin.peek();\n\t\t&#125;\n\t&#125;\n\n&#125;\n\n如何用栈实现队列&#x2F;&#x2F; 思路：一个push栈，一个pop栈，把push栈的元素放进pop栈再取出来\n&#x2F;&#x2F; 为保证顺序，1、pop栈不为空时,push栈不能往pop栈里倒元素。2、push栈倒元素需要一次性倒完\n\npublic class TwoStacksImplementQueue &#123;\n\n\tpublic static class TwoStacksQueue &#123;\n\t\tpublic Stack&lt;Integer&gt; stackPush;\n\t\tpublic Stack&lt;Integer&gt; stackPop;\n\n\t\tpublic TwoStacksQueue() &#123;\n\t\t\tstackPush &#x3D; new Stack&lt;Integer&gt;();\n\t\t\tstackPop &#x3D; new Stack&lt;Integer&gt;();\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; push栈向pop栈倒入数据\n\t\tprivate void pushToPop() &#123;\n\t\t\tif (stackPop.empty()) &#123;\n\t\t\t\twhile (!stackPush.empty()) &#123;\n\t\t\t\t\tstackPop.push(stackPush.pop());\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tpublic void add(int pushInt) &#123;\n\t\t\tstackPush.push(pushInt);\n\t\t\tpushToPop();\n\t\t&#125;\n\n\t\tpublic int poll() &#123;\n\t\t\tif (stackPop.empty() &amp;&amp; stackPush.empty()) &#123;\n\t\t\t\tthrow new RuntimeException(&quot;Queue is empty!&quot;);\n\t\t\t&#125;\n\t\t\tpushToPop();\n\t\t\treturn stackPop.pop();\n\t\t&#125;\n\n\t\tpublic int peek() &#123;\n\t\t\tif (stackPop.empty() &amp;&amp; stackPush.empty()) &#123;\n\t\t\t\tthrow new RuntimeException(&quot;Queue is empty!&quot;);\n\t\t\t&#125;\n\t\t\tpushToPop();\n\t\t\treturn stackPop.peek();\n\t\t&#125;\n\t&#125;\n&#125;\n\n如何用队列实现栈&#x2F;&#x2F;实现poll或peek功能是第一个队列中除最后一个元素依次取出加进另一个队列，剩下的那个就是所需要的元素\npublic class Code07_TwoQueueImplementStack &#123;\n\n\tpublic static class TwoQueueStack&lt;T&gt; &#123;\n\t\tpublic Queue&lt;T&gt; queue;\n\t\tpublic Queue&lt;T&gt; help;\n\n\t\tpublic TwoQueueStack() &#123;\n\t\t\tqueue &#x3D; new LinkedList&lt;&gt;();\n\t\t\thelp &#x3D; new LinkedList&lt;&gt;();\n\t\t&#125;\n\n\t\tpublic void push(T value) &#123;\n\t\t\tqueue.offer(value);\n\t\t&#125;\n\n\t\tpublic T poll() &#123;\n\t\t\twhile (queue.size() &gt; 1) &#123;\n\t\t\t\thelp.offer(queue.poll());\n\t\t\t&#125;\n\t\t\tT ans &#x3D; queue.poll();\n\t\t\tQueue&lt;T&gt; tmp &#x3D; queue;\n\t\t\tqueue &#x3D; help;\n\t\t\thelp &#x3D; tmp;\n\t\t\treturn ans;\n\t\t&#125;\n\n\t\tpublic T peek() &#123;\n\t\t\twhile (queue.size() &gt; 1) &#123;\n\t\t\t\thelp.offer(queue.poll());\n\t\t\t&#125;\n\t\t\tT ans &#x3D; queue.poll();\n\t\t\thelp.offer(ans);\n\t\t\tQueue&lt;T&gt; tmp &#x3D; queue;\n\t\t\tqueue &#x3D; help;\n\t\t\thelp &#x3D; tmp;\n\t\t\treturn ans;\n\t\t&#125;\n\n\t\tpublic boolean isEmpty() &#123;\n\t\t\treturn queue.isEmpty();\n\t\t&#125;\n\t&#125;\n&#125;\n\n堆public class Heap &#123;\n\n\tpublic static class MyMaxHeap &#123;\n\t\tprivate int[] heap;\n\t\tprivate final int limit;\n\t\tprivate int heapSize;\n\n\t\tpublic MyMaxHeap(int limit) &#123;\n\t\t\theap &#x3D; new int[limit];\n\t\t\tthis.limit &#x3D; limit;\n\t\t\theapSize &#x3D; 0;\n\t\t&#125;\n\n\t\tpublic boolean isEmpty() &#123;\n\t\t\treturn heapSize &#x3D;&#x3D; 0;\n\t\t&#125;\n\n\t\tpublic boolean isFull() &#123;\n\t\t\treturn heapSize &#x3D;&#x3D; limit;\n\t\t&#125;\n\n\t\tpublic void push(int value) &#123;\n\t\t\tif (heapSize &#x3D;&#x3D; limit) &#123;\n\t\t\t\tthrow new RuntimeException(&quot;heap is full&quot;);\n\t\t\t&#125;\n\t\t\theap[heapSize] &#x3D; value;\n\t\t\t&#x2F;&#x2F; value heapSize\n\t\t\theapInsert(heap, heapSize++);\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; 返回最大值，并且在大根堆中，把最大值删掉\n\t\t&#x2F;&#x2F; 剩下的数，依然保持大根堆组织\n\t\tpublic int pop() &#123;\n\t\t\tint ans &#x3D; heap[0];\n\t\t\tswap(heap, 0, --heapSize);\n\t\t\theapify(heap, 0, heapSize);\n\t\t\treturn ans;\n\t\t&#125;\n\n\t\tprivate void heapInsert(int[] arr, int index) &#123;\n\t\t\t&#x2F;&#x2F; [index] [index-1]&#x2F;2\n\t\t\t&#x2F;&#x2F; index &#x3D;&#x3D; 0\n\t\t\twhile (arr[index] &gt; arr[(index - 1) &#x2F; 2]) &#123;\n\t\t\t\tswap(arr, index, (index - 1) &#x2F; 2);\n\t\t\t\tindex &#x3D; (index - 1) &#x2F; 2;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tprivate void heapify(int[] arr, int index, int heapSize) &#123;\n\t\t\tint left &#x3D; index * 2 + 1;\n\t\t\twhile (left &lt; heapSize) &#123; &#x2F;&#x2F; 如果有左孩子，有没有右孩子，可能有可能没有！\n\t\t\t\t&#x2F;&#x2F; 把较大孩子的下标，给largest\n\t\t\t\tint largest &#x3D; left + 1 &lt; heapSize &amp;&amp; arr[left + 1] &gt; arr[left] ? left + 1 : left;\n\t\t\t\tlargest &#x3D; arr[largest] &gt; arr[index] ? largest : index;\n\t\t\t\tif (largest &#x3D;&#x3D; index) &#123;\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t\t\t&#x2F;&#x2F; index和较大孩子，要互换\n\t\t\t\tswap(arr, largest, index);\n\t\t\t\tindex &#x3D; largest;\n\t\t\t\tleft &#x3D; index * 2 + 1;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tprivate void swap(int[] arr, int i, int j) &#123;\n\t\t\tint tmp &#x3D; arr[i];\n\t\t\tarr[i] &#x3D; arr[j];\n\t\t\tarr[j] &#x3D; tmp;\n\t\t&#125;\n\n\t&#125;\n&#125;\n\n\n\n排序选择排序0~N-1上找到最小值与下标为0的值交换\n1~N-1上找到最小值与下标为1的值交换\n2~N-1上找到最小值与下标为2的值交换\n······\npublic static void selectionSort(int[] arr) &#123;\n\t\tif (arr &#x3D;&#x3D; null || arr.length &lt; 2) &#123;\n\t\t\treturn;\n\t\t&#125;\n\t\t&#x2F;&#x2F; 0 ~ N-1  找到最小值，在哪，放到0位置上\n\t\t&#x2F;&#x2F; 1 ~ n-1  找到最小值，在哪，放到1 位置上\n\t\t&#x2F;&#x2F; 2 ~ n-1  找到最小值，在哪，放到2 位置上\n\t\tfor (int i &#x3D; 0; i &lt; arr.length - 1; i++) &#123;\n\t\t\tint minIndex &#x3D; i;\n\t\t\tfor (int j &#x3D; i + 1; j &lt; arr.length; j++) &#123; &#x2F;&#x2F; i ~ N-1 上找最小值的下标 \n\t\t\t\tminIndex &#x3D; arr[j] &lt; arr[minIndex] ? j : minIndex;\n\t\t\t&#125;\n\t\t\tswap(arr, i, minIndex);\n\t\t&#125;\n\t&#125;\n\n\tpublic static void swap(int[] arr, int i, int j) &#123;\n\t\tint tmp &#x3D; arr[i];\n\t\tarr[i] &#x3D; arr[j];\n\t\tarr[j] &#x3D; tmp;\n\t&#125;\n\n冒泡排序public static void bubbleSort(int[] arr) &#123;\n\t\tif (arr &#x3D;&#x3D; null || arr.length &lt; 2) &#123;\n\t\t\treturn;\n\t\t&#125;\n\t\t&#x2F;&#x2F; 0 ~ N-1\n\t\t&#x2F;&#x2F; 0 ~ N-2\n\t\t&#x2F;&#x2F; 0 ~ N-3\n\t\tfor (int e &#x3D; arr.length - 1; e &gt; 0; e--) &#123; &#x2F;&#x2F; 0 ~ e\n\t\t\tfor (int i &#x3D; 0; i &lt; e; i++) &#123;\n\t\t\t\tif (arr[i] &gt; arr[i + 1]) &#123;\n\t\t\t\t\tswap(arr, i, i + 1);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F; 交换arr的i和j位置上的值，i和j是一个位置的话，会出错\n\tpublic static void swap(int[] arr, int i, int j) &#123;\n\t\tarr[i] &#x3D; arr[i] ^ arr[j];\n\t\tarr[j] &#x3D; arr[i] ^ arr[j];\n\t\tarr[i] &#x3D; arr[i] ^ arr[j];\n\t&#125;\n\n\n\n\n插入排序public static void insertionSort(int[] arr) &#123;\n\t\tif (arr &#x3D;&#x3D; null || arr.length &lt; 2) &#123;\n\t\t\treturn;\n\t\t&#125;\n\t\t&#x2F;&#x2F; 不只1个数\n\t\tfor (int i &#x3D; 1; i &lt; arr.length; i++) &#123; &#x2F;&#x2F; 0 ~ i 做到有序\n\t\t\tfor (int j &#x3D; i - 1; j &gt;&#x3D; 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) &#123;\n\t\t\t\tswap(arr, j, j + 1);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F; i和j是一个位置的话，会出错\n\tpublic static void swap(int[] arr, int i, int j) &#123;\n\t\tarr[i] &#x3D; arr[i] ^ arr[j];\n\t\tarr[j] &#x3D; arr[i] ^ arr[j];\n\t\tarr[i] &#x3D; arr[i] ^ arr[j];\n\t&#125;\n\n归并排序&#x2F;&#x2F; 递归方法实现\n\tpublic static void mergeSort1(int[] arr) &#123;\n\t\tif (arr &#x3D;&#x3D; null || arr.length &lt; 2) &#123;\n\t\t\treturn;\n\t\t&#125;\n\t\tprocess(arr, 0, arr.length - 1);\n\t&#125;\n\n\t&#x2F;&#x2F; 请把arr[L..R]排有序\n\t&#x2F;&#x2F; l...r N\n\t&#x2F;&#x2F; T(N) &#x3D; 2 * T(N &#x2F; 2) + O(N)\n\t&#x2F;&#x2F; O(N * logN)\n\tpublic static void process(int[] arr, int L, int R) &#123;\n\t\tif (L &#x3D;&#x3D; R) &#123; &#x2F;&#x2F; base case\n\t\t\treturn;\n\t\t&#125;\n\t\tint mid &#x3D; L + ((R - L) &gt;&gt; 1);\n\t\tprocess(arr, L, mid);\n\t\tprocess(arr, mid + 1, R);\n\t\tmerge(arr, L, mid, R);\n\t&#125;\n\n\tpublic static void merge(int[] arr, int L, int M, int R) &#123;\n\t\tint[] help &#x3D; new int[R - L + 1];\n\t\tint i &#x3D; 0;\n\t\tint p1 &#x3D; L;\n\t\tint p2 &#x3D; M + 1;\n\t\twhile (p1 &lt;&#x3D; M &amp;&amp; p2 &lt;&#x3D; R) &#123;\n\t\t\thelp[i++] &#x3D; arr[p1] &lt;&#x3D; arr[p2] ? arr[p1++] : arr[p2++];\n\t\t&#125;\n\t\t&#x2F;&#x2F; 要么p1越界了，要么p2越界了\n\t\twhile (p1 &lt;&#x3D; M) &#123;\n\t\t\thelp[i++] &#x3D; arr[p1++];\n\t\t&#125;\n\t\twhile (p2 &lt;&#x3D; R) &#123;\n\t\t\thelp[i++] &#x3D; arr[p2++];\n\t\t&#125;\n\t\tfor (i &#x3D; 0; i &lt; help.length; i++) &#123;\n\t\t\tarr[L + i] &#x3D; help[i];\n\t\t&#125;\n\t&#125;\n\n变形1：给定一个数组，求出每个元素左边比他小的元素之和，再求每个元素左边比他小的元素之和的累加和，要求小于O（N^2）\npublic static int smallSum(int[] arr) &#123;\n\t\tif (arr &#x3D;&#x3D; null || arr.length &lt; 2) &#123;\n\t\t\treturn 0;\n\t\t&#125;\n\t\treturn process(arr, 0, arr.length - 1);\n\t&#125;\n\n\t&#x2F;&#x2F; arr[L..R]既要排好序，也要求小和返回\n\t&#x2F;&#x2F; 所有merge时，产生的小和，累加\n\t&#x2F;&#x2F; 左 排序   merge\n\t&#x2F;&#x2F; 右 排序  merge\n\t&#x2F;&#x2F; merge\n\tpublic static int process(int[] arr, int l, int r) &#123;\n\t\tif (l &#x3D;&#x3D; r) &#123;\n\t\t\treturn 0;\n\t\t&#125;\n\t\t&#x2F;&#x2F; l &lt; r\n\t\tint mid &#x3D; l + ((r - l) &gt;&gt; 1);\n\t\treturn \n\t\t\t\tprocess(arr, l, mid) \n\t\t\t\t+ \n\t\t\t\tprocess(arr, mid + 1, r) \n\t\t\t\t+ \n\t\t\t\tmerge(arr, l, mid, r);\n\t&#125;\n\n\tpublic static int merge(int[] arr, int L, int m, int r) &#123;\n\t\tint[] help &#x3D; new int[r - L + 1];\n\t\tint i &#x3D; 0;\n\t\tint p1 &#x3D; L;\n\t\tint p2 &#x3D; m + 1;\n\t\tint res &#x3D; 0;\n\t\twhile (p1 &lt;&#x3D; m &amp;&amp; p2 &lt;&#x3D; r) &#123;\n\t\t\tres +&#x3D; arr[p1] &lt; arr[p2] ? (r - p2 + 1) * arr[p1] : 0;&#x2F;&#x2F;就多了这一行代码\n\t\t\thelp[i++] &#x3D; arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];\n\t\t&#125;\n\t\twhile (p1 &lt;&#x3D; m) &#123;\n\t\t\thelp[i++] &#x3D; arr[p1++];\n\t\t&#125;\n\t\twhile (p2 &lt;&#x3D; r) &#123;\n\t\t\thelp[i++] &#x3D; arr[p2++];\n\t\t&#125;\n\t\tfor (i &#x3D; 0; i &lt; help.length; i++) &#123;\n\t\t\tarr[L + i] &#x3D; help[i];\n\t\t&#125;\n\t\treturn res;\n\t&#125;\n\n变形2：求逆序对的数量\n给定一个序列有n个数，求n个数中逆序对的个数，逆序对的定义：i &lt; j &amp;&amp; a[i] &gt; a[j]。\nint merge_sort(int a[], int l ,int r)&#123;\n    &#x2F;&#x2F;序列只有一个数\n    if (l &#x3D;&#x3D; r) return 0;\n    &#x2F;&#x2F;递归左边和右边\n    int mid &#x3D; l + r &gt;&gt; 1;\n    int res &#x3D; merge_sort(a, l , mid) + merge_sort(a, mid + 1, r);\n    &#x2F;&#x2F;归并的过程\n    int i &#x3D; l , j &#x3D; mid + 1, k &#x3D; 0;\n    while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r)&#123;\n        if (a[i] &lt;&#x3D; a[j]) t[k++] &#x3D; a[i++];\n        else&#123;\n            t[k++] &#x3D; a[j++];\n            res +&#x3D; mid - i + 1;\n        &#125;\n    &#125;\n    while (i &lt;&#x3D; mid) t[k++] &#x3D; a[i++];\n    while (j &lt;&#x3D; r) t[k++] &#x3D; a[j++];\n    \n    &#x2F;&#x2F;还原数组\n    for (int i &#x3D; 0 , j &#x3D; l ; j &lt;&#x3D; r ; i ++ , j ++) a[j] &#x3D; t[i];\n    \n    return res;\n&#125;\n\n\n变形3：翻转对\nclass Solution &#123;\n   public static int reversePairs(int[] nums) &#123;\n\t\tif (nums &#x3D;&#x3D; null || nums.length &lt; 2) &#123;\n\t\t\treturn 0;\n\t\t&#125;\n\t\treturn process(nums, 0, nums.length - 1);\n\t&#125;\n\n\tpublic static int process(int[] nums, int l, int r) &#123;\n\t\tif (l &#x3D;&#x3D; r) &#123;\n\t\t\treturn 0;\n\t\t&#125;\n\t\t&#x2F;&#x2F; l &lt; r\n\t\tint mid &#x3D; l + ((r - l) &gt;&gt; 1);\n\t\treturn process(nums, l, mid) + process(nums, mid + 1, r) + merge(nums, l, mid, r);\n\t&#125;\n\n\tpublic static int merge(int[] nums, int L, int m, int r) &#123;\n\t\t&#x2F;&#x2F; [L....M] [M+1....R]\n\t\tint ans &#x3D; 0;\n\t\tint windowR &#x3D; m + 1;\n\t\tfor (int i &#x3D; L; i &lt;&#x3D; m; i++) &#123;\n\t\t\twhile (windowR &lt;&#x3D; r &amp;&amp; (long) nums[i] &gt; (long) nums[windowR] * 2) &#123;\n\t\t\t\twindowR++;\n\t\t\t&#125;\n\t\t\tans +&#x3D; windowR - m - 1;\n\t\t&#125;\n\t\tint[] help &#x3D; new int[r - L + 1];\n\t\tint i &#x3D; 0;\n\t\tint p1 &#x3D; L;\n\t\tint p2 &#x3D; m + 1;\n\t\twhile (p1 &lt;&#x3D; m &amp;&amp; p2 &lt;&#x3D; r) &#123;\n\t\t\thelp[i++] &#x3D; nums[p1] &lt;&#x3D; nums[p2] ? nums[p1++] : nums[p2++];\n\t\t&#125;\n\t\twhile (p1 &lt;&#x3D; m) &#123;\n\t\t\thelp[i++] &#x3D; nums[p1++];\n\t\t&#125;\n\t\twhile (p2 &lt;&#x3D; r) &#123;\n\t\t\thelp[i++] &#x3D; nums[p2++];\n\t\t&#125;\n\t\tfor (i &#x3D; 0; i &lt; help.length; i++) &#123;\n\t\t\tnums[L + i] &#x3D; help[i];\n\t\t&#125;\n\t\treturn ans;\n\t&#125;\n&#125;\n\n堆排序public class HeapSort&#123;\n    public static void heapSort(int[] arr) &#123;\n\t\tif (arr &#x3D;&#x3D; null || arr.length &lt; 2) &#123;\n\t\t\treturn;\n\t\t&#125;\n\t\tfor (int i &#x3D; 0; i &lt; arr.length; i++) &#123; &#x2F;&#x2F; O(N)\n\t\t\theapInsert(arr, i); &#x2F;&#x2F; O(logN)\n\t\t&#125;\n\t\t&#x2F;&#x2F; O(N)\n&#x2F;&#x2F;\t\tfor (int i &#x3D; arr.length - 1; i &gt;&#x3D; 0; i--) &#123;\n&#x2F;&#x2F;\t\t\theapify(arr, i, arr.length);\n&#x2F;&#x2F;\t\t&#125;\n\t\tint heapSize &#x3D; arr.length;\n\t\tswap(arr, 0, --heapSize);\n\t\twhile (heapSize &gt; 0) &#123; &#x2F;&#x2F; O(N) \n\t\t\theapify(arr, 0, heapSize); &#x2F;&#x2F; O(logN)\n\t\t\tswap(arr, 0, --heapSize); &#x2F;&#x2F; O(1)\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F; arr[index]刚来的数，往上\n\tpublic static void heapInsert(int[] arr, int index) &#123;\n\t\twhile (arr[index] &gt; arr[(index - 1) &#x2F; 2]) &#123;\n\t\t\tswap(arr, index, (index - 1) &#x2F; 2);\n\t\t\tindex &#x3D; (index - 1) &#x2F; 2;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F; arr[index]位置的数，能否往下移动\n\tpublic static void heapify(int[] arr, int index, int heapSize) &#123;\n\t\tint left &#x3D; index * 2 + 1; &#x2F;&#x2F; 左孩子的下标\n\t\twhile (left &lt; heapSize) &#123; &#x2F;&#x2F; 下方还有孩子的时候\n\t\t\t&#x2F;&#x2F; 两个孩子中，谁的值大，把下标给largest\n\t\t\tint largest &#x3D; left + 1 &lt; heapSize &amp;&amp; arr[left + 1] &gt; arr[left] ? left + 1 : left;\n\t\t\t&#x2F;&#x2F; 父和较大的孩子之间，谁的值大，把下标给largest\n\t\t\tlargest &#x3D; arr[largest] &gt; arr[index] ? largest : index;\n\t\t\tif (largest &#x3D;&#x3D; index) &#123;\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t\tswap(arr, largest, index);\n\t\t\tindex &#x3D; largest;\n\t\t\tleft &#x3D; index * 2 + 1;\n\t\t&#125;\n\t&#125;\n\n\tpublic static void swap(int[] arr, int i, int j) &#123;\n\t\tint tmp &#x3D; arr[i];\n\t\tarr[i] &#x3D; arr[j];\n\t\tarr[j] &#x3D; tmp;\n\t&#125;\n&#125;\n\n\n\n位运算int a &#x3D; 7;\nint b &#x3D; -a &#x3D; (~a) + 1 &#x3D; -7;\n\n&#x2F;&#x2F; arr中，只有一种数，出现奇数次\npublic static void printOddTimesNum1(int[] arr) &#123;\n\tint eor &#x3D; 0;\n\tfor (int i &#x3D; 0; i &lt; arr.length; i++) &#123;\n\t\teor ^&#x3D; arr[i];\n\t&#125;\n\tSystem.out.println(eor);\n&#125;\n\n&#x2F;&#x2F; arr中，有两种数，出现奇数次\npublic static void printOddTimesNum2(int[] arr) &#123;\n\tint eor &#x3D; 0;\n\tfor (int i &#x3D; 0; i &lt; arr.length; i++) &#123;\n\t\teor ^&#x3D; arr[i];\n\t&#125;\n\t&#x2F;&#x2F; a 和 b是两种数\n\t&#x2F;&#x2F; eor !&#x3D; 0\n\t&#x2F;&#x2F; eor最右侧的1，提取出来\n\t&#x2F;&#x2F; eor :     00110010110111000\n\t&#x2F;&#x2F; rightOne :00000000000001000\n\tint rightOne &#x3D; eor &amp; (-eor); &#x2F;&#x2F; 提取出最右的1\n\t\n\t\n\tint onlyOne &#x3D; 0; &#x2F;&#x2F; eor&#39;\n\tfor (int i &#x3D; 0 ; i &lt; arr.length;i++) &#123;\n\t\t&#x2F;&#x2F;  arr[1] &#x3D;  111100011110000\n\t\t&#x2F;&#x2F; rightOne&#x3D;  000000000010000\n\t\tif ((arr[i] &amp; rightOne) !&#x3D; 0) &#123;\n\t\t\tonlyOne ^&#x3D; arr[i];\n\t\t&#125;\n\t&#125;\n\tSystem.out.println(onlyOne + &quot; &quot; + (eor ^ onlyOne));\n&#125;\n   &#x2F;&#x2F; 输入一定能够保证，数组中所有的数都出现了M次，只有一种数出现了K次\n   &#x2F;&#x2F; 1 &lt;&#x3D; K &lt; M\n   &#x2F;&#x2F; 返回这种数\n   public static int km(int[] arr, int k, int m) &#123;\n       int[] help &#x3D; new int[32];\n       for (int num : arr) &#123;\n           for (int i &#x3D; 0; i &lt; 32; i++) &#123;\n               help[i] +&#x3D; (num &gt;&gt; i) &amp; 1;\n           &#125;\n       &#125;\n       int ans &#x3D; 0;\n       for (int i &#x3D; 0; i &lt; 32; i++) &#123;\n           help[i] %&#x3D; m;\n           if (help[i] !&#x3D; 0) &#123;\n               ans |&#x3D; 1 &lt;&lt; i;\n           &#125;\n       &#125;\n       return ans;\n   &#125;\n\n二叉树","slug":"数据结构与算法学习","date":"2022-07-02T01:51:23.000Z","categories_index":"","tags_index":"算法与数据结构","author_index":"Aurora"},{"id":"d75b47533ffd84933c1aac3f8bde1caa","title":"前端三件套","content":"HTMLHTML：超文本标记语言超文本：超越了文本的的限制，比普通文本更强大，除了文字信息，还可以定义图片，音频，视频等内容。标记语言：由标签构成的语言\nHTML运行在浏览器上，HTML标签由浏览器来解析\nHTML标签都是预定义好的。例如：使用&lt;img&gt;展示图片\n\nW3C标准：网页主要由三部分组成\n结构：HTML\n表现：CSS\n行为：JavaScript\n\n\n\nHTML结构：\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;&lt;&#x2F;title&gt;\n    &lt;&#x2F;head&gt;\n    &lt;body&gt;\n        \n    &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\n\n\n\n\n \nCSS导入方式：\n1、使用“”引入css样式；\n2、在style标签里写css样式；\n3、在元素标签里使用style属性写css样式。\n具体使用查W3cschool\njs导入方式：\n1、直接引入\n&lt;script&gt;alert(&quot;这是js的内部引入&quot;);&lt;&#x2F;script&gt;\n2、\n定义外部js文件\n&lt;script type&#x3D;”text&#x2F;javascript” src&#x3D;”demo.js”&gt;\n基本语法结尾 ; 可有可无\n使用window.alert()写入警告框\n使用document.write()写入html输出\n使用console.log()写入浏览器控制台\n用var声明变量\nvar test &#x3D; 20;\ntest &#x3D; &quot;张三&quot;\n\nJavascript是一门弱类型语言，变量可以存放不同类型的值\n变量名命名规则：\n\n组成字符可以是任何字母，数组，下划线(_)或美元符号($)\n数字不能开头\n建议使用驼峰命名\n\nECMAScript6新增了let关键字来定义变量，它的用法类似于var，但是所声明的变量，只在let关键字所在的代码块内有效，且不允许重复声明\nECMAScript6新增了const关键字，用来声明一个只读的常量。一旦声明，常量的值就不能改变了\n\n运算符 &#x3D;&#x3D;  和  &#x3D;&#x3D;&#x3D; \nvar age1 &#x3D; 20;\nvar age2 &#x3D; &quot;20&quot;;\nalert(age1 &#x3D;&#x3D; age2) &#x2F;&#x2F;会返回true\nalert(age1 &#x3D;&#x3D;&#x3D; age2) &#x2F;&#x2F;会返回false\n&#x2F;*\n\t&#x3D;&#x3D; ：1.判断类型是否一样，如果不一样，先转换成一样\n    \t2.再判断是否相等\n\t&#x3D;&#x3D;&#x3D;：1.判断类型是否一样，如果不一样，直接返回false\n\t\t2.再判断是否相等\n*&#x2F;\n\n\n\n\n\n类型转换：其他类型转为number：\n\nstring: 按照字符串的字面值，转为数字.如果字面值不是数字，则转为NaN。一般使用parseInt\nboolean: true 转为1，false转为0\n\n其他类型转为boolean：\n\nnumber:0和NaN转为false，其他的数字转为true \nstring:空字符串转为false，其他的字符串转为true \nnull:false \nundefined:false\n\n\n\n对象Array\nString\n自定义对象\nBOMBOM：Browser Object Model 浏览器对象模型。也就是 JavaScript 将浏览器的各个组成部分封装为对象。\n我们要操作浏览器的各个组成部分就可以通过操作 BOM 中的对象来实现。比如：我现在想将浏览器地址栏的地址改为 https://www.itheima.com 就可以通过使用 BOM 中定义的 Location 对象的 href 属性，代码： location.href = &quot;https://itheima.com&quot;; \n BOM 中包含了如下对象：\n\nWindow：浏览器窗口对象\nNavigator：浏览器对象\nScreen：屏幕对象\nHistory：历史记录对象\nLocation：地址栏对象\n\n下图是 BOM 中的各个对象和浏览器的各个组成部分的对应关系\n\nwindow对象\nhistory对象\nloaction对象\nDOMDOM：Document Object Model 文档对象模型。也就是 JavaScript 将 HTML 文档的各个组成部分封装为对象。\nDOM 其实我们并不陌生，之前在学习 XML 就接触过，只不过 XML 文档中的标签需要我们写代码解析，而 HTML 文档是浏览器解析。封装的对象分为\n\nDocument：整个文档对象\nElement：元素对象\nAttribute：属性对象\nText：文本对象\nComment：注释对象\n\n如下图，左边是 HTML 文档内容，右边是 DOM 树\n\n作用：\nJavaScript 通过 DOM， 就能够对 HTML进行操作了\n\n改变 HTML 元素的内容\n改变 HTML 元素的样式（CSS）\n对 HTML DOM 事件作出反应\n添加和删除 HTML 元素\n\nDOM相关概念：\nDOM 是 W3C（万维网联盟）定义了访问 HTML 和 XML 文档的标准。该标准被分为 3 个不同的部分：\n\n核心 DOM：针对任何结构化文档的标准模型。 XML 和 HTML 通用的标准\n\nDocument：整个文档对象\n\nElement：元素对象\n\nAttribute：属性对象\n\nText：文本对象\n\nComment：注释对象\n\n\n\nXML DOM： 针对 XML 文档的标准模型\n\nHTML DOM： 针对 HTML 文档的标准模型\n该标准是在核心 DOM 基础上，对 HTML 中的每个标签都封装成了不同的对象\n\n例如：&lt;img&gt; 标签在浏览器加载到内存中时会被封装成 Image 对象，同时该对象也是 Element 对象。\n例如：&lt;input type=&#39;button&#39;&gt; 标签在浏览器加载到内存中时会被封装成 Button 对象，同时该对象也是 Element 对象。\n\n\n\n获取Element对象HTML 中的 Element 对象可以通过 Document 对象获取，而 Document 对象是通过 window 对象获取。\nDocument 对象中提供了以下获取 Element 元素对象的函数\n\ngetElementById()：根据id属性值获取，返回单个Element对象\ngetElementsByTagName()：根据标签名称获取，返回Element对象数组\ngetElementsByName()：根据name属性值获取，返回Element对象数组\ngetElementsByClassName()：根据class属性值获取，返回Element对象数组\n\n事件监听\n事件：HTML事件是发生在HTML元素身上的“事情”。比如：\n\n按钮被点击\n鼠标移动到元素之上\n按下键盘按键\n\n\n事件监听：Javascript可以在事件被侦测到时执行代码\n\n\n事件绑定方式一：通过 HTML标签中的事件属性进行绑定\nonclick 是 单击事件 的事件属性\n&lt;input type&#x3D;&quot;button&quot; onclick&#x3D;&#39;on()’&gt;\nfunction on()&#123;\n\talert(&quot;我被点了&quot;);\n&#125;\n\n方式二：通过 DOM 元素属性绑定\n&lt;input type&#x3D;&quot;button&quot; id&#x3D;&quot;btn&quot;&gt;\ndocument.getElementById(&quot;btn&quot;).onclick &#x3D; function ()&#123;\n    alert(&quot;我被点了&quot;);\n&#125;\n\n为保证单一职责，建议使用方式二\n常见事件\n正则表达式正则对象有两种创建方式：\n\n直接量方式：注意不要加引号\nvar reg &#x3D; &#x2F;正则表达式&#x2F;;\n\n创建 RegExp 对象\nvar reg &#x3D; new RegExp(&quot;正则表达式&quot;);\n\ntest(str) ：判断指定字符串是否符合规则，返回 true或 false\n从上面创建正则对象的格式中可以看出不管哪种方式都需要正则表达式，那么什么是正则表达式呢？\n正则表达式定义了字符串组成的规则。也就是判断指定的字符串是否符合指定的规则，如果符合返回true，如果不符合返回false。\n正则表达式是和语言无关的。很多语言都支持正则表达式，Java语言也支持，只不过正则表达式在不同的语言中的使用方式不同，js 中需要使用正则对象来使用正则表达式。\n正则表达式常用的规则如下：\n\n^：表示开始\n\n$：表示结束\n\n[ ]：代表某个范围内的单个字符，比如： [0-9] 单个数字字符\n\n.：代表任意单个字符，除了换行和行结束符\n\n\\w：代表单词字符：字母、数字、下划线()，相当于 [A-Za-z0-9]\n\n\\d：代表数字字符： 相当于 [0-9]\n\n\n量词：\n\n+：至少一个\n\n*：零个或多个\n\n？：零个或一个\n\n{x}：x个\n\n{m,}：至少m个\n\n{m,n}：至少m个，最多n个\n\n\n","slug":"前端三件套基础入门","date":"2022-06-30T02:44:09.000Z","categories_index":"","tags_index":"前端","author_index":"Aurora"},{"id":"54e1d69dbe01003cc0c2e45b21bc6b3e","title":"Mybatis","content":"入门_MyBatis中文网(Mybatis.pdf)什么是Mybatis？\nMybatis是一款优秀的持久层框架，用于简化JDBC开发\n官网：https://mybatis.org/mybatis-3/zh/index.html\n\n持久层：\n\n负责将数据保存到数据库的那一层代码\n\nJavaEE三层架构：表现层，业务层，持久层\n\n\n框架：\n\n框架就是一个半成品软件，是一套可重用的、通用的、软件基础代码模型\n\n在框架的基础之上构建软件编写更加高效、规范、通用、可扩展\n\n\n\n快速入门\nJDBC写的是硬编码，后期维护很麻烦，无论是增删改查语句的修改，或者是用户名密码的改变，\nMyBatis虽然麻烦，不过很多步骤只做一次，后期维护非常的方便\n解决SQL映射文件的警告提示产生原因：IDEA和数据库没有建立连接，不识别表信息\n解决方法：在IDEA中配置MySQL数据库连接\n\n\nMapper代理开发\n目的\n1.解决原生方式中的硬编码\n2.简化后期执行SQL\n\n步骤\n1.定义与SQL映射文件同名的Mapper接口，并且将Mapper接口和SQL映射文件放置在同一目录下\n2.设置SQL映射文件的namespace属性为Mapper接口全限定名\n3.在Mapper接口中定义方法，方法名就是SQL映射文件中sql语句的id，并保持参数类型和返回值类型一致\n4.编码\n\n通过SqlSession的getMapper方法获取Mapper接口的代理对象\n调用对应方法完成sql的执行\n\n\n细节\n如果Mapper接口名称和SQL映射文件名称相同，并在同一目录下，则可以使用包扫描的方式简化SQL映射文件的加载\n&lt;mappers&gt;\n&lt;!--        加载sql映射文件--&gt;\n&lt;!--        &lt;mapper resource&#x3D;&quot;UserMapper.xml&quot;&#x2F;&gt;--&gt;\n&lt;!--        Mapper代理方式--&gt;\n        &lt;package name&#x3D;&quot;com.itheima.mapper&quot;&#x2F;&gt;\n    &lt;&#x2F;mappers&gt;\n\nMybatis核心配置文件详解\n注解完成增删改查\n注解即在接口方法上直接写SQL语句，不用在xml文件中再配置\n配置文件完成增删改查起别名\n定义&lt;sql&gt;片段\n定义&lt;resultMap&gt;片段\n注意事项\n参数占位符\n\n​      #{}: 执行SQL时，会将#{}占位符替换为?，将来自动设置参数值\n​      ${}: 拼SQL。会存在SQL注入问题\n​      使用时机：\n​      参数传递，都是用#{}\n​      如果要对表名，列名进行动态设置，只能使用${}进行sql拼接\n2.parameterType\n​\t\t用于设置参数类型，该参数可以省略\n3.SQL语句中特殊字符处理\n​\t转义字符\n&lt;![CDATA[内容]]&gt;\n动态SQLif标签：用于判断参数是否有值，使用test属性进行条件判断\n\n存在的问题：第一个条件不需要逻辑运算符\n\n解决方案：\n\n使用恒等式让所有条件格式都一样\n&lt;select id&#x3D;&quot;selectByCondition&quot; resultMap&#x3D;&quot;brandResultMap&quot;&gt;\n        select *\n        from tb_brand\nwhere 1 &#x3D; 1\n        &lt;if test&#x3D;&quot;status !&#x3D; null&quot;&gt;and status &#x3D; #&#123;status&#125;&lt;&#x2F;if&gt;\n        &lt;if test&#x3D;&quot;companyName !&#x3D; null and companyName !&#x3D; &#39;&#39;&quot;&gt;and company_name like #&#123;companyName&lt;&#x2F;if&gt;\n        &lt;if test&#x3D;&quot;brandName !&#x3D; null and brandName !&#x3D; &#39;&#39;&quot;&gt;and brand_name like #&#123;brandName&#125;&lt;&#x2F;if&gt;\n\n    &lt;&#x2F;select&gt;\n\n\n\n&lt;where&gt;标签替换where关键字\n&lt;select id&#x3D;&quot;selectByCondition&quot; resultMap&#x3D;&quot;brandResultMap&quot;&gt;\n        select *\n        from tb_brand\n&lt;where&gt;\n        &lt;if test&#x3D;&quot;status !&#x3D; null&quot;&gt; status &#x3D; #&#123;status&#125;&lt;&#x2F;if&gt;\n        &lt;if test&#x3D;&quot;companyName !&#x3D; null and companyName !&#x3D; &#39;&#39;&quot;&gt;and company_name like #&#123;companyName&lt;&#x2F;if&gt;\n        &lt;if test&#x3D;&quot;brandName !&#x3D; null and brandName !&#x3D; &#39;&#39;&quot;&gt;and brand_name like #&#123;brandName&#125;&lt;&#x2F;if&gt;&lt;&#x2F;where&gt;\n\n    &lt;&#x2F;select&gt;\n\n\n\n\n事务提交自动提交\nSqlSession sqlSession &#x3D; sqlSessionFactory.openSession(true);\n\n手动提交\nSqlSession sqlSession &#x3D; sqlSessionFactory.openSession();\n或\nSqlSession sqlSession &#x3D; sqlSessionFactory.openSession(false);\n\n事务后写sqlSession.commit();\n\n\n\n返回添加数据的主键\n&lt;insert useGeneratedKeys &#x3D; &quot;true&quot; keyProperty &#x3D; &quot;id&quot;&gt; \n\n\n\n\n\n上图（批量删除） 如果接口方法未加param注解，collection属性的值应该为array\n参数传递  \n参数封装\n\nMyBatis 参数封装：\n   单个参数：\n      1. POJO类型：直接使用，属性名 和 参数占位符名称 一致\n      2. Map集合：直接使用，键名 和 参数占位符名称 一致\n      3. Collection：封装为Map集合，可以使用@Param注解，替换Map集合中默认的arg键名\n          map.put(&quot;arg0&quot;,collection集合);\n          map.put(&quot;collection&quot;,collection集合);\n      4. List：封装为Map集合，可以使用@Param注解，替换Map集合中默认的arg键名\n          map.put(&quot;arg0&quot;,list集合);\n          map.put(&quot;collection&quot;,list集合);\n          map.put(&quot;list&quot;,list集合);\n      5. Array：封装为Map集合，可以使用@Param注解，替换Map集合中默认的arg键名\n          map.put(&quot;arg0&quot;,数组);\n          map.put(&quot;array&quot;,数组);\n      6. 其他类型：直接使用\n   多个参数：封装为Map集合,可以使用@Param注解，替换Map集合中默认的arg键名\n      map.put(&quot;arg0&quot;,参数值1)\n      map.put(&quot;param1&quot;,参数值1)\n      map.put(&quot;param2&quot;,参数值2)\n      map.put(&quot;agr1&quot;,参数值2)\n      ---------------@Param(&quot;username&quot;)\n      map.put(&quot;username&quot;,参数值1)\n      map.put(&quot;param1&quot;,参数值1)\n      map.put(&quot;param2&quot;,参数值2)\n      map.put(&quot;agr1&quot;,参数值2)\n\n \n\n\n使用中出现的问题（注意）\n不加@Param注解，取值的时候直接写属性\n\npublic void addUser(User user);\n&lt;insert id&#x3D;&quot;addUser&quot; parameterType&#x3D;&quot;com.xxxx.mybatis.entity.User&quot;&gt;\n    insert into user(id,user_name,name,birthday,age)\n    values (#&#123;id&#125;,#&#123;userName&#125;,#&#123;name&#125;,#&#123;birthday&#125;,#&#123;age&#125;)\n&lt;&#x2F;insert&gt;\n\n\n加了@Param注解，取值必须使用对象.属性的方式\n\npublic void addUser(@Param(&quot;user&quot;) User user);\n&lt;insert id&#x3D;&quot;addUser&quot; parameterType&#x3D;&quot;com.xxxx.mybatis.entity.User&quot;&gt;\n    insert into user(id,user_name,name,birthday,age)\n    values (#&#123;user.id&#125;,#&#123;user.userName&#125;,#&#123;user.name&#125;,#&#123;user.birthday&#125;,#&#123;user.age&#125;)\n&lt;&#x2F;insert&gt;\n","slug":"Mybatis","date":"2022-06-07T08:06:27.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"6f4f974e39a23a6637b9ccfa82544a76","title":"Maven","content":"\nMaven是专门用于管理和构建java项目的工具Maven基础Maven的功能\n\n1、提供了一套标准化的项目结构\n\n2、提供了一套标准化的构建流程（编译，测试，打包，发布……）\n\n3、提供了一套依赖管理机制\n\n模型\n\n常见命令\ncompile 编译\nclean 清理\ntest 测试\npackage 打包\ninstall 安装\n\nIDEA配置Maven\nMaven坐标详解\n什么是坐标：\n\nMaven中的坐标是资源的唯一标识\n\n使用坐标来定义项目或引入项目中需要的依赖\n\n\n\nMaven坐标的主要组成\n\ngroupld：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima）\nartifactld：定义当前Maven项目名称（通常是模块名称）\nversion：定义当前项目版本号\n\n\n\n\nIDEA创建Maven项目\n依赖管理使用坐标导入jar包1.在pom.xml中编写&lt;dependencies&gt;标签\n2.在&lt;dependencies&gt;标签中 使用&lt;dependency&gt;引入坐标\n3.定义坐标的groupid，artifactld，version\n4.点击刷新按钮，使坐标生效(建议配置自动生效，无需刷新)\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;\n      &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;\n      &lt;version&gt;4.11&lt;&#x2F;version&gt;\n      &lt;scope&gt;test&lt;&#x2F;scope&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;\n      &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;\n      &lt;version&gt;5.1.48&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n  &lt;&#x2F;dependencies&gt;\n\n\n依赖范围 \nMaven进阶分模块开发与设计\n将原始模块按照功能拆分成若干个子模块，方便模块间的相互调用，接口共享\n\n\n步骤：\n1.创建Maven模块\n2.书写模块代码\n3.通过maven指令安装模块到本地仓库（install指令）\n依赖管理\n依赖具有传递性\n\n直接依赖：在当前项目中通过依赖配置建立的依赖关系\n间接依赖：被依赖的资源如果依赖其他资源，当前项目间接依赖其他资源\n\n\n依赖传递冲突问题\n\n路径优先：当依赖中出现相同的资源时，层级越深，优先级越低，层级越浅，优先级越高\n声明优先：当资源在相同层级被依赖时，配置顺序靠前的覆盖配置顺序靠后的\n特殊优先：当同级配置了相同资源的不同版本，后配置的覆盖先配置的\n\n\n可选依赖\n&lt;dependency&gt;\n      &lt;groupId&gt;com.itheima&lt;&#x2F;groupId&gt;\n      &lt;artifactId&gt;maven_03_pojo&lt;&#x2F;artifactId&gt;\n      &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n      &lt;!--可选依赖是隐藏当前工程所依赖的资源，隐藏后对应资源将不具有依赖传递--&gt;\n      &lt;optional&gt;true&lt;&#x2F;optional&gt;\n  &lt;&#x2F;dependency&gt;\n\n排除依赖\n&lt;dependency&gt;\n    &lt;groupId&gt;com.itheima&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;maven_04_dao&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;!--排除依赖是隐藏当前资源对应的依赖关系--&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;com.itheima&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;maven_03_pojo&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;exclusion&gt;\n    &lt;&#x2F;exclusions&gt;\n&lt;&#x2F;dependency&gt;\n\n简单来梳理下，就是\n\nA依赖B,B依赖C,C通过依赖传递会被A使用到，现在要想办法让A不去依赖C\n可选依赖是在B上设置&lt;optional&gt;,A不知道有C的存在，\n排除依赖是在A上设置&lt;exclusions&gt;,A知道有C的存在，主动将其排除掉。\n\n聚合 与 继承聚合\n聚合项目的打包方式为POM，并添加所要管理的项目\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n\n    &lt;groupId&gt;com.itheima&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;maven_01_parent&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.0-RELEASE&lt;&#x2F;version&gt;\n    &lt;packaging&gt;pom&lt;&#x2F;packaging&gt;\n    \n    \n    &lt;!--设置管理的模块名称--&gt;\n    &lt;modules&gt;\n        &lt;module&gt;..&#x2F;maven_02_ssm&lt;&#x2F;module&gt;\n        &lt;module&gt;..&#x2F;maven_03_pojo&lt;&#x2F;module&gt;\n        &lt;module&gt;..&#x2F;maven_04_dao&lt;&#x2F;module&gt;\n    &lt;&#x2F;modules&gt;\n&lt;&#x2F;project&gt;\n\n\njar:默认情况，说明该项目为java项目\nwar:说明该项目为web项目\npom:说明该项目为聚合或继承(后面会讲)项目\n\n使用聚合统一管理项目\n\n测试发现，当maven_01_parent的compile被点击后，所有被其管理的项目都会被执行编译操作。这就是聚合工程的作用。\n说明：聚合工程管理的项目在进行运行的时候，会按照项目与项目之间的依赖关系来自动决定执行的顺序和配置的顺序无关。\n继承\n所谓继承:描述的是两个工程间的关系，与java中的继承相似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承。\n作用：\n简化配置\n减少版本冲突\n\n\n\n步骤\n创建maven模块，设置打包方式为pom\n&lt;packaging&gt;pom&lt;&#x2F;packaging&gt;\n\n在父工程的pom文件中配置依赖关系(子工程将沿用父工程中的依赖关系)\n\n配置子工程中可选的依赖关系\n&lt;dependencyManagement&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;1.1.16&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n    ...\n&lt;&#x2F;dependencyManagement&gt;\n\n在子工程中配置当前工程所继承的父工程\n&lt;!--定义该工程的父工程--&gt;\n&lt;parent&gt;\n    &lt;groupId&gt;com.itheima&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;maven_01_parent&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.0-RELEASE&lt;&#x2F;version&gt;\n    &lt;!--填写父工程的pom文件,可以不写--&gt;\n    &lt;relativePath&gt;..&#x2F;maven_01_parent&#x2F;pom.xml&lt;&#x2F;relativePath&gt;\n&lt;&#x2F;parent&gt;\n\n在子工程中配置父工程中可选依赖的坐标\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\n注意事项:\n1.子工程中使用父工程中的可选依赖时，仅需要提供群组id和项目id，无需提供版本，版本由父工程统一提供，避免版本冲突\n2.子工程中还可以定义父工程中没有定义的依赖关系,只不过不能被父工程进行版本统一管理。\n\n聚合和继承的区别\n作用：\n聚合用于快速构建项目\n继承用于快速配置\n\n\n相同点：\n聚合与继承的pom.xml文件打包方式均为pom，可以将两种关系制作到同一个pom文件中\n聚合和继承均属于设计型模块，并无实际的内容模块\n\n\n不同点：\n聚合是在当前模块中配置关系，聚合可以感知到参与聚合的模块有哪些\n继承是在子模块中配置关系，父模块无法感知哪些子模块继承了自己\n\n\n\n属性如果我们现在想更新Spring的版本 如何保证多个jar包版本的统一？\n\n步骤1:父工程的pom.xml中定义属性\n&lt;properties&gt;\n    &lt;spring.version&gt;5.2.10.RELEASE&lt;&#x2F;spring.version&gt;\n    &lt;junit.version&gt;4.12&lt;&#x2F;junit.version&gt;\n    &lt;mybatis-spring.version&gt;1.3.0&lt;&#x2F;mybatis-spring.version&gt;\n&lt;&#x2F;properties&gt;\n\n步骤2:修改依赖的version\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-core&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n此时，我们只需要更新父工程中properties标签中所维护的jar包版本，所有子项目中的版本也就跟着更新。\n配置文件加载属性步骤步骤1:父工程定义属性&lt;properties&gt;\n   &lt;jdbc.url&gt;jdbc:mysql:&#x2F;&#x2F;127.1.1.1:3306&#x2F;ssm_db&lt;&#x2F;jdbc.url&gt;\n&lt;&#x2F;properties&gt;\n\n步骤2:jdbc.properties文件中引用属性在jdbc.properties，将jdbc.url的值直接获取Maven配置的属性\njdbc.driver&#x3D;com.mysql.jdbc.Driver\njdbc.url&#x3D;$&#123;jdbc.url&#125;\njdbc.username&#x3D;root\njdbc.password&#x3D;root\n\n步骤3:设置maven过滤文件范围Maven在默认情况下是从当前项目的src\\main\\resources下读取文件进行打包。现在我们需要打包的资源文件是在maven_02_ssm下,需要我们通过配置来指定下具体的资源目录。\n&lt;build&gt;\n    &lt;resources&gt;\n        &lt;!--设置资源目录--&gt;\n        &lt;resource&gt;\n            &lt;directory&gt;..&#x2F;maven_02_ssm&#x2F;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;\n            &lt;!--设置能够解析$&#123;&#125;，默认是false --&gt;\n            &lt;filtering&gt;true&lt;&#x2F;filtering&gt;\n        &lt;&#x2F;resource&gt;\n    &lt;&#x2F;resources&gt;\n&lt;&#x2F;build&gt;\n\n**说明:**directory路径前要添加../的原因是maven_02_ssm相对于父工程的pom.xml路径是在其上一层的目录中，所以需要添加。\n修改完后，注意maven_02_ssm项目的resources目录就多了些东西，如下:\n\n步骤4:测试是否生效测试的时候，只需要将maven_02_ssm项目进行打包，然后观察打包结果中最终生成的内容是否为Maven中配置的内容。\n\n上面的属性管理就已经完成，但是有一个问题没有解决，因为不只是maven_02_ssm项目需要有属性被父工程管理，如果有多个项目需要配置，该如何实现呢?\n方式一:\n&lt;build&gt;\n    &lt;resources&gt;\n        &lt;!--设置资源目录，并设置能够解析$&#123;&#125;--&gt;\n        &lt;resource&gt;\n            &lt;directory&gt;..&#x2F;maven_02_ssm&#x2F;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;\n            &lt;filtering&gt;true&lt;&#x2F;filtering&gt;\n        &lt;&#x2F;resource&gt;\n        &lt;resource&gt;\n            &lt;directory&gt;..&#x2F;maven_03_pojo&#x2F;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;\n            &lt;filtering&gt;true&lt;&#x2F;filtering&gt;\n        &lt;&#x2F;resource&gt;\n        ...\n    &lt;&#x2F;resources&gt;\n&lt;&#x2F;build&gt;\n\n可以配，但是如果项目够多的话，这个配置也是比较繁琐\n方式二:\n&lt;build&gt;\n    &lt;resources&gt;\n        &lt;!--\n\t\t\t$&#123;project.basedir&#125;: 当前项目所在目录,子项目继承了父项目，\n\t\t\t相当于所有的子项目都添加了资源目录的过滤\n\t\t--&gt;\n        &lt;resource&gt;\n            &lt;directory&gt;$&#123;project.basedir&#125;&#x2F;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;\n            &lt;filtering&gt;true&lt;&#x2F;filtering&gt;\n        &lt;&#x2F;resource&gt;\n    &lt;&#x2F;resources&gt;\n&lt;&#x2F;build&gt;\n\n**说明:**打包的过程中如果报如下错误:\n\n原因就是Maven发现你的项目为web项目，就会去找web项目的入口web.xml[配置文件配置的方式]，发现没有找到，就会报错。\n解决方案1：在maven_02_ssm项目的src\\main\\webapp\\WEB-INF\\添加一个web.xml文件\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_3_1.xsd&quot;\n         version&#x3D;&quot;3.1&quot;&gt;\n&lt;&#x2F;web-app&gt;\n\n上面我们所使用的都是Maven的自定义属性，除了${project.basedir},它属于Maven的内置系统属性。\n在Maven中的属性分为:\n\n自定义属性（常用）\n内置属性\nSetting属性\nJava系统属性\n环境变量属性\n\n\n具体如何查看这些属性:\n在cmd命令行中输入mvn help:system\n\n具体使用，就是使用 $&#123;key&#125;来获取，key为等号左边的，值为等号右边的，比如获取红线的值，对应的写法为 $&#123;java.runtime.name&#125;。\n版本管理在我们jar包的版本定义中，有两个工程版本用的比较多:\n\nSNAPSHOT（快照版本）\n项目开发过程中临时输出的版本，称为快照版本\n快照版本会随着开发的进展不断更新\n\n\nRELEASE（发布版本）\n项目开发到一定阶段里程碑后，向团队外部发布较为稳定的版本，这种版本所对应的构件文件是稳定的\n即便进行功能的后续开发，也不会改变当前发布版本内容，这种版本称为发布版本\n\n\n\n除了上面的工程版本，我们还经常能看到一些发布版本:\n\nalpha版:内测版，bug多不稳定内部版本不断添加新功能\nbeta版:公测版，不稳定(比alpha稳定些)，bug相对较多不断添加新功能\n纯数字版\n\n多环境配置与应用多环境开发\n\n我们平常都是在自己的开发环境进行开发，\n当开发完成后，需要把开发的功能部署到测试环境供测试人员进行测试使用，\n等测试人员测试通过后，我们会将项目部署到生成环境上线使用。\n这个时候就有一个问题是，不同环境的配置是不相同的，如不可能让三个环境都用一个数据库，所以就会有三个数据库的url配置，\n我们在项目中如何配置?\n要想实现不同环境之间的配置切换又该如何来实现呢?\n\nmaven提供配置多种环境的设定，帮助开发者在使用过程中快速切换环境。具体实现步骤:\n步骤1:父工程配置多个环境,并指定默认激活环境&lt;profiles&gt;\n    &lt;!--开发环境--&gt;\n    &lt;profile&gt;\n        &lt;id&gt;env_dep&lt;&#x2F;id&gt;\n        &lt;properties&gt;\n            &lt;jdbc.url&gt;jdbc:mysql:&#x2F;&#x2F;127.1.1.1:3306&#x2F;ssm_db&lt;&#x2F;jdbc.url&gt;\n        &lt;&#x2F;properties&gt;\n        &lt;!--设定是否为默认启动环境--&gt;\n        &lt;activation&gt;\n            &lt;activeByDefault&gt;true&lt;&#x2F;activeByDefault&gt;\n        &lt;&#x2F;activation&gt;\n    &lt;&#x2F;profile&gt;\n    &lt;!--生产环境--&gt;\n    &lt;profile&gt;\n        &lt;id&gt;env_pro&lt;&#x2F;id&gt;\n        &lt;properties&gt;\n            &lt;jdbc.url&gt;jdbc:mysql:&#x2F;&#x2F;127.2.2.2:3306&#x2F;ssm_db&lt;&#x2F;jdbc.url&gt;\n        &lt;&#x2F;properties&gt;\n    &lt;&#x2F;profile&gt;\n    &lt;!--测试环境--&gt;\n    &lt;profile&gt;\n        &lt;id&gt;env_test&lt;&#x2F;id&gt;\n        &lt;properties&gt;\n            &lt;jdbc.url&gt;jdbc:mysql:&#x2F;&#x2F;127.3.3.3:3306&#x2F;ssm_db&lt;&#x2F;jdbc.url&gt;\n        &lt;&#x2F;properties&gt;\n    &lt;&#x2F;profile&gt;\n&lt;&#x2F;profiles&gt;\n\n所以总结来说，对于多环境切换只需要两步即可:\n\n父工程中定义多环境\n&lt;profiles&gt;\n\t&lt;profile&gt;\n    \t&lt;id&gt;环境名称&lt;&#x2F;id&gt;\n        &lt;properties&gt;\n        \t&lt;key&gt;value&lt;&#x2F;key&gt;\n        &lt;&#x2F;properties&gt;\n        &lt;activation&gt;\n        \t&lt;activeByDefault&gt;true&lt;&#x2F;activeByDefault&gt;\n        &lt;&#x2F;activation&gt;\n    &lt;&#x2F;profile&gt;\n    ...\n&lt;&#x2F;profiles&gt;\n\n使用多环境(构建过程)\nmvn 指令 -P 环境定义ID[环境定义中获取]\n\n跳过测试\n应用场景\n功能更新中并且没有开发完毕\n快速打包\n……\n\n\n\n前面在执行install指令的时候，Maven都会按照顺序从上往下依次执行，每次都会执行test,\n对于test来说有它存在的意义，\n\n可以确保每次打包或者安装的时候，程序的正确性，假如测试已经通过在我们没有修改程序的前提下再次执行打包或安装命令，由于顺序执行，测试会被再次执行，就有点耗费时间了。\n功能开发过程中有部分模块还没有开发完毕，测试无法通过，但是想要把其中某一部分进行快速打包，此时由于测试环境失败就会导致打包失败。\n\n遇到上面这些情况的时候，我们就想跳过测试执行下面的构建命令，具体实现方式有很多：\n方式一:IDEA工具实现跳过测试\n图中的按钮为Toggle &#39;Skip Tests&#39; Mode,\nToggle翻译为切换的意思，也就是说在测试与不测试之间进行切换。\n点击一下，出现测试画横线的图片，如下:\n\n说明测试已经被关闭，再次点击就会恢复。\n这种方式最简单，但是有点”暴力”，会把所有的测试都跳过，如果我们想更精细的控制哪些跳过哪些不跳过，就需要使用配置插件的方式。\n方式二:配置插件实现跳过测试在父工程中的pom.xml中添加测试插件配置\n&lt;build&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            &lt;artifactId&gt;maven-surefire-plugin&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;2.12.4&lt;&#x2F;version&gt;\n            &lt;configuration&gt;\n                &lt;skipTests&gt;false&lt;&#x2F;skipTests&gt;\n                &lt;!--排除掉不参与测试的内容--&gt;\n                &lt;excludes&gt;\n                    &lt;exclude&gt;**&#x2F;BookServiceTest.java&lt;&#x2F;exclude&gt;\n                &lt;&#x2F;excludes&gt;\n            &lt;&#x2F;configuration&gt;\n        &lt;&#x2F;plugin&gt;\n    &lt;&#x2F;plugins&gt;\n&lt;&#x2F;build&gt;\n\nskipTests:如果为true，则跳过所有测试，如果为false，则不跳过测试\nexcludes：哪些测试类不参与测试，即排除，针对skipTests为false来设置的\nincludes: 哪些测试类要参与测试，即包含,针对skipTests为true来设置的\n方式三:命令行跳过测试\n使用Maven的命令行，mvn 指令 -D skipTests\n注意事项:\n\n执行的项目构建指令必须包含测试生命周期，否则无效果。例如执行compile生命周期，不经过test生命周期。\n该命令可以不借助IDEA，直接使用cmd命令行进行跳过测试，需要注意的是cmd要在pom.xml所在目录下进行执行。\n\n私服私服简介及使用\n\n私服是一台独立的服务器，用于解决团队内部的资源共享与资源同步问题\n\n搭建Maven私服的方式有很多，我们来介绍其中一种使用量比较大的实现方式:\n\nNexus\nSonatype公司的一款maven私服产品\n下载地址：https://help.sonatype.com/repomanager3/download\n\n\n\n使用cmd进入到解压目录下的nexus-3.30.1-01\\bin,执行如下命令:\nnexus.exe &#x2F;run nexus\n\n至此私服就已经安装成功。如果要想修改一些基础配置信息，可以使用:\n\n修改基础配置信息\n安装路径下etc目录中nexus-default.properties文件保存有nexus基础配置信息，例如默认访问端口。\n\n\n修改服务器运行配置信息\n安装路径下bin目录中nexus.vmoptions文件保存有nexus服务器启动对应的配置信息，例如默认占用内存空间。\n\n\n\n私服仓库分类\n本地仓库访问私服配置步骤1:私服上配置仓库\n步骤2:配置本地Maven对私服的访问权限&lt;servers&gt;\n    &lt;server&gt;\n        &lt;id&gt;itheima-snapshot&lt;&#x2F;id&gt;\n        &lt;username&gt;admin&lt;&#x2F;username&gt;\n        &lt;password&gt;admin&lt;&#x2F;password&gt;\n    &lt;&#x2F;server&gt;\n    &lt;server&gt;\n        &lt;id&gt;itheima-release&lt;&#x2F;id&gt;\n        &lt;username&gt;admin&lt;&#x2F;username&gt;\n        &lt;password&gt;admin&lt;&#x2F;password&gt;\n    &lt;&#x2F;server&gt;\n&lt;&#x2F;servers&gt;\n\n步骤3:配置私服的访问路径&lt;mirrors&gt;\n    &lt;mirror&gt;\n        &lt;!--配置仓库组的ID--&gt;\n        &lt;id&gt;maven-public&lt;&#x2F;id&gt;\n        &lt;!--*代表所有内容都从私服获取--&gt;\n        &lt;mirrorOf&gt;*&lt;&#x2F;mirrorOf&gt;\n        &lt;!--私服仓库组maven-public的访问路径--&gt;\n        &lt;url&gt;http:&#x2F;&#x2F;localhost:8081&#x2F;repository&#x2F;maven-public&#x2F;&lt;&#x2F;url&gt;\n    &lt;&#x2F;mirror&gt;\n&lt;&#x2F;mirrors&gt;\n\n为了避免阿里云Maven私服地址的影响，建议先将之前配置的阿里云Maven私服镜像地址注释掉，等练习完后，再将其恢复。\n资源上传与下载本地仓库与私服已经建立了连接，接下来我们就需要往私服上上传资源和下载资源，具体的实现步骤为:\n步骤1:配置工程上传私服的具体位置 &lt;!--配置当前工程保存在私服中的具体位置--&gt;\n&lt;distributionManagement&gt;\n    &lt;repository&gt;\n        &lt;!--和maven&#x2F;settings.xml中server中的id一致，表示使用该id对应的用户名和密码--&gt;\n        &lt;id&gt;itheima-release&lt;&#x2F;id&gt;\n         &lt;!--release版本上传仓库的具体地址--&gt;\n        &lt;url&gt;http:&#x2F;&#x2F;localhost:8081&#x2F;repository&#x2F;itheima-release&#x2F;&lt;&#x2F;url&gt;\n    &lt;&#x2F;repository&gt;\n    &lt;snapshotRepository&gt;\n        &lt;!--和maven&#x2F;settings.xml中server中的id一致，表示使用该id对应的用户名和密码--&gt;\n        &lt;id&gt;itheima-snapshot&lt;&#x2F;id&gt;\n        &lt;!--snapshot版本上传仓库的具体地址--&gt;\n        &lt;url&gt;http:&#x2F;&#x2F;localhost:8081&#x2F;repository&#x2F;itheima-snapshot&#x2F;&lt;&#x2F;url&gt;\n    &lt;&#x2F;snapshotRepository&gt;\n&lt;&#x2F;distributionManagement&gt;\n\n步骤2:发布资源到私服\n或者执行Maven命令\nmvn deploy\n\n注意:\n要发布的项目都需要配置distributionManagement标签，要么在自己的pom.xml中配置，要么在其父项目中配置，然后子项目中继承父项目即可。\n\n","slug":"Maven","date":"2022-05-18T08:50:49.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"f83fade08690f69bc32eef72fe024ed9","title":"JDBC总结","content":"JDBC快速入门\t(JDBC.pdf)1、编写代码步骤1、创建工程,导入驱动jar包\n jar包\n2、注册驱动Class.forName(&quot;com.mysql.jdbc.Driver&quot;);\n\n3、获取连接Connection conn &#x3D; DriverMannager.getConnection(url,username,password);\n\n4、定义SQL语句String sql &#x3D; &quot;&quot;;\n\n5、获取执行SQL的对象Statement stmt &#x3D; conn.createStatement();\n\n6、执行SQL语句stmt.executeUpdate(sql);  \n&#x2F;&#x2F;此方法会执行sql语句并返回受影响的行数。可以用\nint count &#x3D; stmt.executeUpdate(sql)接受返回值;\n\n7、处理返回结果8、释放资源stmt.close();\nconn.cloes();\n\n例\nAPI详解1、DriverManager1、注册驱动*** MYSQL 5之后的驱动包，可以省略注册驱动的步骤***\n\n这个方法可以完成驱动的注册，但是实际开发中一般不会使用这个方法完成驱动的注册\n原因：\n如果需要注册驱动，就会使用，DriverManager.registerDriver(new Driver()); ,但是查看源代码发现，在代码中一段静态代码块，静态代码块已经调用了注册驱动的方法。\n\n如果再手动调用该方法注册驱动，就会导致驱动被注册两次。实际开发中一般户次爱用;\nClass.forName(&quot;com.mysql.jdbc.Driver&quot;);\n\n2、获得与数据库的连接\n这个方法就是用来获得与数据库连接的方法，这个方法中的三个参数为 与数据库连接的路径(url)，与数据库连接的用户名(user)，与数据库连接的密码(password)。\n主要是url的写法：\njdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;db1\n\njdbc:mysql:&#x2F;&#x2F;ip地址:端口号&#x2F;数据库名称?参数键值对1&amp;参数键值对2...\n\nlocalhost           :连接的MySQL数据库服务器的主机ip地址。（连接是本机就可以写成localhost），如果连接不是本机的，就需要写上连接主机的IP地址。\nurl如果连接的是本机的路径，可以简化为如下格式：\njdbc:mysql:&#x2F;&#x2F;&#x2F;db1\n配置useSSL &#x3D; false 参数，禁用安全连接方式，解决警告提示\n2、Connection1、获取执行SQL对象普通执行SQL对象\nStatement createStatement();\n\n 预编译SQL的执行SQL对象；防止SQL注入\nPreparedStatement prepareStatement(sql);\n\n执行存储过程的对象\nCallableStatement prepareCall(sql)\n\n2、事务管理MYSQL事务管理开启事务：  begin;&#x2F;start transaction;\n提交事务：  commit;\n回滚事务：  rollback;\n\nMYSQL默认自动提交事务\n\nJDBC事务管理Connection接口中定义了3个对应的方法\n开启事务：setAutoCommit(bollean autoCommit): true为自动提交事务；false为手动提交事务，即为开启事务\n提交事务：commit()\n回滚事务：rollback()\n\n例：\npackage com.itheima.jdbc;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n&#x2F;**\n * JDBC API 详解：Connection\n *&#x2F;\npublic class JDBCDemo3_Connection &#123;\n\n    public static void main(String[] args) throws Exception &#123;\n        &#x2F;&#x2F;1. 注册驱动\n        &#x2F;&#x2F;Class.forName(&quot;com.mysql.jdbc.Driver&quot;);\n        &#x2F;&#x2F;2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写\n        String url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;db1?useSSL&#x3D;false&quot;;\n        String username &#x3D; &quot;root&quot;;\n        String password &#x3D; &quot;1234&quot;;\n        Connection conn &#x3D; DriverManager.getConnection(url, username, password);\n        &#x2F;&#x2F;3. 定义sql\n        String sql1 &#x3D; &quot;update account set money &#x3D; 3000 where id &#x3D; 1&quot;;\n        String sql2 &#x3D; &quot;update account set money &#x3D; 3000 where id &#x3D; 2&quot;;\n        &#x2F;&#x2F;4. 获取执行sql的对象 Statement\n        Statement stmt &#x3D; conn.createStatement();\n\n        try &#123;\n            &#x2F;&#x2F; 开启事务\n            conn.setAutoCommit(false);\n            &#x2F;&#x2F;5. 执行sql\n            int count1 &#x3D; stmt.executeUpdate(sql1);&#x2F;&#x2F;受影响的行数\n            &#x2F;&#x2F;6. 处理结果\n            System.out.println(count1);\n            int i &#x3D; 3&#x2F;0;\n            &#x2F;&#x2F;5. 执行sql\n            int count2 &#x3D; stmt.executeUpdate(sql2);&#x2F;&#x2F;受影响的行数\n            &#x2F;&#x2F;6. 处理结果\n            System.out.println(count2);\n\n            &#x2F;&#x2F; 提交事务\n            conn.commit();\n        &#125; catch (Exception throwables) &#123;\n            &#x2F;&#x2F; 回滚事务\n            conn.rollback();\n            throwables.printStackTrace();\n        &#125;\n\n\n\n        &#x2F;&#x2F;7. 释放资源\n        stmt.close();\n        conn.close();\n    &#125;\n&#125;\n\n3、Statement1、执行SQL语句int executeUpdate(sql):执行DML、DDL语句\n返回值（1）DML语句影响的行数（2）DDL语句执行后，执行成功也可能返回0\n\nResultSet executeQuery(sql):执行DQL语句\n返回值：Result结果集对象\n\n4、ResultSet封装了DQL查询语句的结果ResultSet stmt.executeQuery(sql); 执行DQL语句，返回ResultSet对象\n\n获取查询结果boolean next(): (1)将光标从当前位置向前移动一行 (2)判断当前行是否为有效行\n返回值 true：有效行，当前行有数据   false：无效行，当前行没有数据\n\nxxx getXxx(参数):获取数据\nxxx：数据类型，如 ： int getInt(参数) String getString(参数)\n参数：int： 列的编号，从1开始\n\t string：列的名称\n\n使用步骤1、游标向下移动一行，并判断该行是否有数据：next()\n2 、获取数据：getXxx(参数)\n&#x2F;&#x2F;循环判断游标是否是最后一行末尾\nwhile(rs.next())\n&#123;\n\t&#x2F;&#x2F;获取数据\n\trs.getXxx(参数);\n&#125;\n\n5、PreparedStatement作用：预编译SQL语句并执行，防止SQL注入问题如：用户名随便写，密码写成’ or ‘ 1 ‘ &#x3D; ‘1\n用法：1、获取PreparedStatement对象&#x2F;&#x2F;SQL语句中的参数值，使用？占位符替代\nString sql &#x3D; &quot;select * from user where username &#x3D; ? and password &#x3D; ？&quot;;\n&#x2F;&#x2F;通过Connection对象获取，并传入对应的SQL语句\nPreparedStatement pstmt &#x3D; conn.prepareStatement(sql);\n\n2、设置参数值PreparedStatement对象:setXxx(参数1,参数2):给？赋值\nXxx:数据类型，如setInt(参数1,参数2)\n参数：\n参数1：？的位置编号，从1开始\n参数2：？的值\n\n3、执行SQLexecuteUpdate();&#x2F;executeQuery(); :不需要再传递sql\n\n\n\n例public class JDBCDemo7_PreparedStatement &#123;\n\n    @Test\n    public void testPreparedStatement() throws  Exception &#123;\n       &#x2F;&#x2F;2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写\n       String url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;db1?useSSL&#x3D;false&quot;;\n       String username &#x3D; &quot;root&quot;;\n       String password &#x3D; &quot;1234&quot;;\n       Connection conn &#x3D; DriverManager.getConnection(url, username, password);\n\n       &#x2F;&#x2F; 接收用户输入 用户名和密码\n        String name &#x3D; &quot;zhangsan&quot;;\n        String pwd &#x3D; &quot;&#39; or &#39;1&#39; &#x3D; &#39;1&quot;;\n\n        &#x2F;&#x2F; 定义sql\n        String sql &#x3D; &quot;select * from tb_user where username &#x3D; ? and password &#x3D; ?&quot;;\n\n        &#x2F;&#x2F; 获取pstmt对象\n        PreparedStatement pstmt &#x3D; conn.prepareStatement(sql);\n\n        &#x2F;&#x2F; 设置？的值\n        pstmt.setString(1,name);\n        pstmt.setString(2,pwd);\n\n        &#x2F;&#x2F; 执行sql\n        ResultSet rs &#x3D; pstmt.executeQuery();\n\n        &#x2F;&#x2F; 判断登录是否成功\n        if(rs.next())&#123;\n            System.out.println(&quot;登录成功~&quot;);\n        &#125;else&#123;\n            System.out.println(&quot;登录失败~&quot;);\n        &#125;\n\n        &#x2F;&#x2F;7. 释放资源\n        rs.close();\n        pstmt.close();\n        conn.close();\n    &#125;\n\n好处：1、预编译SQL，性能更高\n2、防止SQL注入，将敏感字符进行转义\nPreparedStatement预编译功能开启：useServerPrepStmts&#x3D;true\n（参数键值对）应加在URL最后\n配置MySQL执行日志（重启mysql服务后生效）\nlog-output&#x3D;FILE\ngeneral-log&#x3D;1\ngeneral_log_file&#x3D;&quot;D:\\mysql.log&quot;\nslow-query-log&#x3D;1\nslow_query_log_file&#x3D;&quot;D:\\mysql_slow.log&quot;\nlong_query_time&#x3D;2\n\n原理：1、在获取PreparedStatement对象时，将sql语句发送给mysql服务器进行检查，编译（这些步骤很耗时）\n2、执行时就不用再进行这些步骤了，速度更快\n3、如果sql模板一样，则只需要进行一次检查编译\n\n数据库连接池简介\n数据库连接池是个容器，负责分配，，管理数据库连接\n\n它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个\n\n释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏\n\n好处：\n\n资源重用\n\n提升系统响应速度\n\n避免数据库连接遗漏\n\n\n\n\n数据库连接池实现标准接口\n官方（SUN）提供的数据库连接池标准接口，由第三方组织实现此接口。\n功能：获取连接\n\nConnection getConnection()\n\n常见的数据库连接池：\nDBCP\nC3P0\nDruid\n\nDruid（德鲁伊）\nDruid连接池是阿里巴巴开源的数据库连接池项目\n功能强大，性能优秀，是Java语言最好的数据库连接池之一\n\n","slug":"JDBC总结","date":"2022-05-07T02:47:07.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"758e18fa21f3b95498a42a108b10694c","title":"SQL总结","content":"SQL通用语法1.SQL语句可以单行或多行书写，以分号结尾。\n2.MYSQL数据库的SQL语句不区分大小写，关键字建议适用大写。\n3.注释\n （1） 单行注释：– 注释内容（两个横杠一个空格+注释内容） 或 #注释内容（MYSQL特有)\n（2） 多行注释： &#x2F;* 注释 *&#x2F;\n对 MYSQL 的 windows命令1、启动mysql服务net start mysql 启动 mysql 服务\nnet stop mysql 关闭 mysql 服务\n\n2、进入mysql，输入密码：mysql -hlocalhost -uroot -proot 进入mysql数据库，其中-h表示服务器名，localhost表示本地；\n-u为数据库用户名，root是mysql默认用户名；-p为密码，如果设置了密码，可直接在-p后直接输入。\n\nmysql -u root -p;\n\n对数据库的操作1、查看所有数据库mysql&gt; show databases;\n\n2、创建数据库mysql&gt; create database 数据库名称\n如果数据库已经存在，则会报错\n可使用\nmysql&gt; create database if not exists; 数据库名称\n\n3、删除数据库drop database 数据库名称;\ndrop database if exists 数据库名称;\n\n4、使用数据库使用数据库 use 数据库名称;\n\n5、查看当前使用的数据库select database();\n\n对表的操作· 创建（create）\n·查询（retrieve）\n·修改（update）\n·删除（delete）\n1、创建（create）创建表create table 表名(\n\t\t字段名1 数据类型1,\n\t\t字段名2 数据类型2,\n\t\t...\n\t\t字段名n 数据类型n\n);\n\n最后一行末尾不能加逗号\n2、查询（retrieve）查询当前数据库下所有表名称show tables;\n\n查询表结构desc 表名称;\n\n3、修改（update）修改表名alter table 表名 rename to 新的表名;\n\n添加一列alter table 表名 add 列名 数据类型;\n\n修改数据类型alter table 表名 modify 列名 新数据类型;\n\n修改列名和数据类型alter table 表名 change 列名 新列名 新数据类型;\n\n删除列alter table 表名 drop 列名;\n\n\n\n4、删除（delete）删除表drop table 表名;\ndrop table if exists 表名;\n\n对数据的操作添加数据1、给指定列添加数据insert into 表名(列名1,列名2，...)values(值1,值2,...); \n\n2、给全部列添加数据insert into 表名 values(值1,值2,...);\n\n3、批量添加数据insert into 表名(列名1,列名2,...) values(值1,值2,...),(值1,值2,...),(值1,值2,...)...;\n\ninsert into 表名 values(值1,值2,...),(值1,值2,...),(值1,值2,...)...;\n\n修改数据1、修改表数据update 表名 set 列名1&#x3D;值1,列名2&#x3D;值2,...[where 条件];\n\n修改语句如果不加条件，则所有数据都将被修改!\n删除数据1、删除数据delete from 表名 [where 条件];\n\n删除语句如果不加条件，则所有数据都将被删除\n查询数据select\n\t字段列表\nfrom\n\t表名列表\nwhere\n\t条件列表\ngroup by\n\t分组字段\nhaving\n\t分组后条件\norder by\n\t排序字段\nlimit\n\t分页限定\n\n\n\n\n\n\n\n\n约束 \n外键约束\n数据库设计\n\n\n多表查询内连接隐式内连接\nselect 字段列表 from 表1,表2... where 条件;\n\n显式内连接\nselect 字段列表 from 表1 [inner] join 表2 on 条件；\n\n内连接相当于查询A B 交集数据\n外连接左外连接\nselect 字段列表 from 表1 left [outer] join 表2 on 条件；\n右外连接\nselect 字段列表 from 表1 right [outer] join 表2 on 条件；\n\n左外连接 ：相当于查询A表所有数据和交集部分数据\n右外连接 ：相当于查询B表所有数据和交集部分数据\n子查询子查询根据查询结果不同，作用不同;1、单行单列:作为条件值，使用&#x3D;,!&#x3D;,&gt;,&lt;等进行条件判断\nselect 字段列表 from 表 where 字段名 &#x3D; (子查询)；\n\n2、多行单列:作为条件值，使用in等关键字进行条件判断\nselect 字段列表 from 表 where 字段名 in (子查询)；\n\n 3、多行duolie:作为虚拟表\nselect 字段列表 from (子查询) where 条件；\n\n事物1、开启事务start transaction; 或者 begin;\n\n2、提交事务commit;\n\n3、回滚事务rollback;\n\n4、事务的特性\n5.事务提交mysql事务默认自动提交\n-- 查看事物的默认提交方式\nselect @@autocommit;\n-- 1 自动提交 0 手动提交\n-- 修改事务提交方式\nset @@autocommit &#x3D; 0;\n","slug":"SQL总结","date":"2022-04-30T08:59:10.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"a64b935a3dc12ce8d8b93a103ca9afe0","title":"java核心技术卷总结","content":"1.&amp;&amp;和|| 运算符是按照“短路”方式来求值的：如果第一个操作数已经能够确定表达式的值，第二个操作数就不必计算了。2.位移运算符的右操作数要完成模32的运算（除非左操作数是long类型，在这种情况下需要对右操作数模64）。例如，1&lt;&lt;35的值等同于1&lt;&lt;3或8。3.同一个级别的运算符按照从左到右的次序进行计算（但右结合运算符除外）&amp;&amp; 优先级大于 | | 。4.String类的substring方法可以从一个较大的字符串提取出一个子串。例如：    String greeting &#x3D; “Hello”;            String a &#x3D; greeting.substring(0,3);    打印 a 会输出    Hel。    即输出[a,b)。5.检测字符串是否相等string a &#x3D; “ok”;string b &#x3D; “ok”;a.equals(b)；“ok”.equals(“ok”);“ok”.equals(“b”);想要检测两个字符串是否相等，而不区分大小写，可用equalsIgnoreCase方法。“Hello”. equalsIgnoreCase(“hello”);6.一定不要使用&#x3D;&#x3D;来检测两个字符串是否相等!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! &#x3D;&#x3D;只能够确定两个字符串是否存放在同一位置上。当然，如果存放在同一位置上，它们必然相等。但是，完全有可能将内容相同的多个字符串副本放置在不同位置上。如果虚拟机始终将相同的字符串共享，就可以使用&#x3D;&#x3D;运算符检测是否相等。但实际上只有字符串字面量是共享的，而+或substring等操作得到的字符串并不共享。因此，千万不要视同&#x3D;&#x3D;运算符测试字符串的相等性！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！7.检查一个字符串既不是null也不是空串 if(str!&#x3D;null &amp;&amp; str.length()!&#x3D;0)。\n","slug":"java核心技术卷总结","date":"2022-04-25T11:48:12.000Z","categories_index":"","tags_index":"","author_index":"Aurora"}]