[{"id":"cf5277bd1519d645b084515a79fe0c20","title":"java的值传递和引用传递","content":"一、基本类型和引用类型的理解Java中的数据类型分为两种为基本类型和引用类型。\n1、基本类型的变量保存原始值，所以变量就是数据本身。\n  常见的基本类型：byte,short,int,long,char,float,double,Boolean,returnAddress。\n2、引用类型的变量保存引用值，所谓的引用值就是对象所在内存空间的“首地址值”，通过对这个引用值来操作对象。\n  常见的引用类型：类类型，接口类型和数组。\n二、值传递和引用传递的理解1、值传递  在方法的调用过程中，实参把它的实际值传递给形参，此传递过程就是将实参的值复制一份传递到函数中，这样如果在函数中对该值（形参的值）进行了操作将不会影响实参的值。因为是直接复制，所以这种方式在传递大量数据时，运行效率会特别低下。\n2、引用传递  引用传递弥补了值传递的不足，如果传递的数据量很大，直接复过去的话，会占用大量的内存空间，而引用传递就是将对象的地址值传递过去，函数接收的是原始值的首地址值。在方法的执行过程中，形参和实参的内容相同，指向同一块内存地址，也就是说操作的其实都是源数据，所以方法的执行将会影响到实际对象。\n举例说明：\npublic class Example &#123;\n    String str &#x3D; new String(&quot;hello&quot;);\n    char[] ch &#x3D; &#123;&#39;a&#39;, &#39;b&#39;&#125;;\n    public static void main(String[] args) &#123;\n        Example ex &#x3D; new Example();\n        ex.change(ex.str, ex.ch);\n        System.out.println(ex.str + &quot; and&quot;);\n        System.out.println(ex.ch);\n    &#125;\n\n    public void change(String str, char[] ch) &#123;\n        str &#x3D; &quot;ok&quot;;\n        ch[0] &#x3D; &#39;c&#39;;\n    &#125;\n&#125;\n\n输出是：\nhello and\ncb\n\n过程分析：\n1、为对象分配空间\n\n2、执行change()方法\n执行前实参（黑色）和形参（红色）的指向如下：\n\n因为String是不可变类且为值传递，而ch[]是引用传递，所以方法中的str &#x3D; “ok”,相当于重新创建一个对象并没有改变实参str的值，数组是引用传递，直接改变，所以执行完方法后，指向关系如下：\n\n3.结论通过上面的分析我们可以得出以下结论：\n基本数据类型传值，对形参的修改不会影响实参；引用类型传引用，形参和实参指向同一个内存地址（同一个对象），所以对参数的修改会影响到实际的对象。String, Integer, Double等immutable的类型特殊处理，可以理解为传值，最后的操作不会修改实参对象。\n哈希表中的特殊情况只要是哈希表中的原生类型，如Integer，String，尽管他们平时是引用传递，但在哈希表中是按值传递！！！\n非原生类型，按值传递，如自己定义的类型。\n","slug":"java的值传递和引用传递","date":"2022-07-05T08:53:49.000Z","categories_index":"","tags_index":"java基础知识","author_index":"Aurora"},{"id":"711e99b247f8f70b0f4cf84df30732b2","title":"Leetcode高频题总结","content":"","slug":"Leetcode高频题总结-1","date":"2022-07-05T08:53:02.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"711e99b247f8f70b0f4cf84df30732b2","title":"Leetcode高频题总结","content":"剑指Offer18 删除链表的节点class Solution &#123;\n    public ListNode deleteNode(ListNode head, int val) &#123;\n        while(head !&#x3D; null)&#123;\n            if(head.val !&#x3D; val)&#123;\n                break;\n            &#125;\n            head &#x3D; head.next;\n        &#125; &#x2F;&#x2F;找到第一个非空的头结点，用于返回和执行下步操作\n        ListNode pre &#x3D; head;\n        ListNode cur &#x3D; head;\n        while(cur !&#x3D; null)&#123;\n            if(cur.val &#x3D;&#x3D; val)&#123;\n                pre.next &#x3D; cur.next;\n            &#125;else&#123;\n                pre &#x3D; cur;\n            &#125;\n            cur &#x3D; cur.next;\n        &#125;\n        return head;\n    &#125;\n&#125;\n\n24 反转链表class Solution &#123;\n    public ListNode reverseList(ListNode head) &#123;\n        ListNode pre &#x3D; null;\n        ListNode next &#x3D; head;\n        while(next!&#x3D;null)&#123;\n            next &#x3D; head.next;\n            head.next &#x3D; pre;\n            pre &#x3D; head;\n            head &#x3D; next;\n        &#125;\n        return pre;\n    &#125;\n&#125;\n\n","slug":"Leetcode高频题总结","date":"2022-07-05T03:05:06.000Z","categories_index":"","tags_index":"算法与数据结构","author_index":"Aurora"},{"id":"6688690e355db1dd869bd788558b9211","title":"数据结构与算法学习","content":"由于之前并未完整成体系的学习算法，在力扣刷100道题后\n感觉到算法知识不成体系，决定看左程云的体系学习班学习算法\n学习路线\n搞定1,2,3差不多达到面试水平\n杂记子问题规模一样的递归可以用Master公式求时间复杂度\nT(N) &#x3D; a * T(N&#x2F;b) + O(N ^ d);\na:会有几次调用代码\nb:每次调用规模的大小\n\n如果 log（b , a) &lt; d 时间复杂度为： O(N^d)\n如果log (b , a) &gt; d 时间复杂度为 ： O(N^(log(b,a)))\n如果log（b , a）&#x3D;&#x3D; d 时间复杂度为：O(N^d * log(2,n)))注：log(b,a) 指以b为地a为指数\n\n基础的数据结构实现栈和队列用数组实现队列&#x2F;&#x2F; 给定一个长度被限制数组空间，如何实现队列？\npublic class RingArray&#123;\n    public static class MyQueue&#123;\n        private int[]arr;\n        private int pushi;\n        private int rolli;\n        private int size;\n        private final int limit;\n        \n        public MyQueue(int limit)&#123;\n            arr &#x3D; new int[limit];\n            pushi &#x3D; 0;\n            polli &#x3D; 0;\n            size &#x3D; 0;\n            this.limit &#x3D; limit;\n        &#125;\n        \n        public void push(int value)&#123;\n            if(size &#x3D;&#x3D; limit)&#123;\n                throw new RuntimeException(&quot;队列满了，不能再加了&quot;);\n            &#125;\n            size++;\n            arr[pushi] &#x3D; value;\n            pushi &#x3D; nextIndex(pushi);\n        &#125;\n        \n        public int pop()&#123;\n            if(size &#x3D;&#x3D; 0)&#123;\n                throw new RuntimeException(&quot;队列空了，不能再拿了&quot;);\n            &#125;\n            int ans &#x3D; arr[rolli];\n            rolli &#x3D; nextIndex(rolli);\n            return ans;\n        &#125;\n        \n        public boolean isEmpty()&#123;\n            return size &#x3D;&#x3D; 0;\n        &#125;\n        \n        private int nextIndex(int i)&#123;\n            return i &lt; limit - 1 ? i + 1: 0;\n        &#125;\n    &#125;\n&#125;\n\n数组实现一个特殊的栈，可实时返回栈中最小值&#x2F;&#x2F;在基本功能上，再实现返回栈中最小元素的功能，且pop、push、getMin操作的时间复杂度是O(1).\n\n&#x2F;&#x2F;思路：维护一个栈和一个最小值栈，最小栈中存此时栈中的最小值。\n\npublic class GetMinStack &#123;\n\n\tpublic static class MyStack &#123;\n\t\tprivate Stack&lt;Integer&gt; stackData;\n\t\tprivate Stack&lt;Integer&gt; stackMin;\n\n\t\tpublic MyStack2() &#123;\n\t\t\tthis.stackData &#x3D; new Stack&lt;Integer&gt;();\n\t\t\tthis.stackMin &#x3D; new Stack&lt;Integer&gt;();\n\t\t&#125;\n\n\t\tpublic void push(int newNum) &#123;\n\t\t\tif (this.stackMin.isEmpty()) &#123;\n\t\t\t\tthis.stackMin.push(newNum);\n\t\t\t&#125; else if (newNum &lt; this.getmin()) &#123;\n\t\t\t\tthis.stackMin.push(newNum);\n\t\t\t&#125; else &#123;\n\t\t\t\tint newMin &#x3D; this.stackMin.peek();\n\t\t\t\tthis.stackMin.push(newMin);\n\t\t\t&#125;\n\t\t\tthis.stackData.push(newNum);\n\t\t&#125;\n\n\t\tpublic int pop() &#123;\n\t\t\tif (this.stackData.isEmpty()) &#123;\n\t\t\t\tthrow new RuntimeException(&quot;Your stack is empty.&quot;);\n\t\t\t&#125;\n\t\t\tthis.stackMin.pop();\n\t\t\treturn this.stackData.pop();\n\t\t&#125;\n\n\t\tpublic int getmin() &#123;\n\t\t\tif (this.stackMin.isEmpty()) &#123;\n\t\t\t\tthrow new RuntimeException(&quot;Your stack is empty.&quot;);\n\t\t\t&#125;\n\t\t\treturn this.stackMin.peek();\n\t\t&#125;\n\t&#125;\n\n&#125;\n\n如何用栈实现队列&#x2F;&#x2F; 思路：一个push栈，一个pop栈，把push栈的元素放进pop栈再取出来\n&#x2F;&#x2F; 为保证顺序，1、pop栈不为空时,push栈不能往pop栈里倒元素。2、push栈倒元素需要一次性倒完\n\npublic class TwoStacksImplementQueue &#123;\n\n\tpublic static class TwoStacksQueue &#123;\n\t\tpublic Stack&lt;Integer&gt; stackPush;\n\t\tpublic Stack&lt;Integer&gt; stackPop;\n\n\t\tpublic TwoStacksQueue() &#123;\n\t\t\tstackPush &#x3D; new Stack&lt;Integer&gt;();\n\t\t\tstackPop &#x3D; new Stack&lt;Integer&gt;();\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; push栈向pop栈倒入数据\n\t\tprivate void pushToPop() &#123;\n\t\t\tif (stackPop.empty()) &#123;\n\t\t\t\twhile (!stackPush.empty()) &#123;\n\t\t\t\t\tstackPop.push(stackPush.pop());\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tpublic void add(int pushInt) &#123;\n\t\t\tstackPush.push(pushInt);\n\t\t\tpushToPop();\n\t\t&#125;\n\n\t\tpublic int poll() &#123;\n\t\t\tif (stackPop.empty() &amp;&amp; stackPush.empty()) &#123;\n\t\t\t\tthrow new RuntimeException(&quot;Queue is empty!&quot;);\n\t\t\t&#125;\n\t\t\tpushToPop();\n\t\t\treturn stackPop.pop();\n\t\t&#125;\n\n\t\tpublic int peek() &#123;\n\t\t\tif (stackPop.empty() &amp;&amp; stackPush.empty()) &#123;\n\t\t\t\tthrow new RuntimeException(&quot;Queue is empty!&quot;);\n\t\t\t&#125;\n\t\t\tpushToPop();\n\t\t\treturn stackPop.peek();\n\t\t&#125;\n\t&#125;\n&#125;\n\n如何用队列实现栈&#x2F;&#x2F;实现poll或peek功能是第一个队列中除最后一个元素依次取出加进另一个队列，剩下的那个就是所需要的元素\npublic class Code07_TwoQueueImplementStack &#123;\n\n\tpublic static class TwoQueueStack&lt;T&gt; &#123;\n\t\tpublic Queue&lt;T&gt; queue;\n\t\tpublic Queue&lt;T&gt; help;\n\n\t\tpublic TwoQueueStack() &#123;\n\t\t\tqueue &#x3D; new LinkedList&lt;&gt;();\n\t\t\thelp &#x3D; new LinkedList&lt;&gt;();\n\t\t&#125;\n\n\t\tpublic void push(T value) &#123;\n\t\t\tqueue.offer(value);\n\t\t&#125;\n\n\t\tpublic T poll() &#123;\n\t\t\twhile (queue.size() &gt; 1) &#123;\n\t\t\t\thelp.offer(queue.poll());\n\t\t\t&#125;\n\t\t\tT ans &#x3D; queue.poll();\n\t\t\tQueue&lt;T&gt; tmp &#x3D; queue;\n\t\t\tqueue &#x3D; help;\n\t\t\thelp &#x3D; tmp;\n\t\t\treturn ans;\n\t\t&#125;\n\n\t\tpublic T peek() &#123;\n\t\t\twhile (queue.size() &gt; 1) &#123;\n\t\t\t\thelp.offer(queue.poll());\n\t\t\t&#125;\n\t\t\tT ans &#x3D; queue.poll();\n\t\t\thelp.offer(ans);\n\t\t\tQueue&lt;T&gt; tmp &#x3D; queue;\n\t\t\tqueue &#x3D; help;\n\t\t\thelp &#x3D; tmp;\n\t\t\treturn ans;\n\t\t&#125;\n\n\t\tpublic boolean isEmpty() &#123;\n\t\t\treturn queue.isEmpty();\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n\n排序选择排序0~N-1上找到最小值与下标为0的值交换\n1~N-1上找到最小值与下标为1的值交换\n2~N-1上找到最小值与下标为2的值交换\n······\npublic static void selectionSort(int[] arr) &#123;\n\t\tif (arr &#x3D;&#x3D; null || arr.length &lt; 2) &#123;\n\t\t\treturn;\n\t\t&#125;\n\t\t&#x2F;&#x2F; 0 ~ N-1  找到最小值，在哪，放到0位置上\n\t\t&#x2F;&#x2F; 1 ~ n-1  找到最小值，在哪，放到1 位置上\n\t\t&#x2F;&#x2F; 2 ~ n-1  找到最小值，在哪，放到2 位置上\n\t\tfor (int i &#x3D; 0; i &lt; arr.length - 1; i++) &#123;\n\t\t\tint minIndex &#x3D; i;\n\t\t\tfor (int j &#x3D; i + 1; j &lt; arr.length; j++) &#123; &#x2F;&#x2F; i ~ N-1 上找最小值的下标 \n\t\t\t\tminIndex &#x3D; arr[j] &lt; arr[minIndex] ? j : minIndex;\n\t\t\t&#125;\n\t\t\tswap(arr, i, minIndex);\n\t\t&#125;\n\t&#125;\n\n\tpublic static void swap(int[] arr, int i, int j) &#123;\n\t\tint tmp &#x3D; arr[i];\n\t\tarr[i] &#x3D; arr[j];\n\t\tarr[j] &#x3D; tmp;\n\t&#125;\n\n冒泡排序public static void bubbleSort(int[] arr) &#123;\n\t\tif (arr &#x3D;&#x3D; null || arr.length &lt; 2) &#123;\n\t\t\treturn;\n\t\t&#125;\n\t\t&#x2F;&#x2F; 0 ~ N-1\n\t\t&#x2F;&#x2F; 0 ~ N-2\n\t\t&#x2F;&#x2F; 0 ~ N-3\n\t\tfor (int e &#x3D; arr.length - 1; e &gt; 0; e--) &#123; &#x2F;&#x2F; 0 ~ e\n\t\t\tfor (int i &#x3D; 0; i &lt; e; i++) &#123;\n\t\t\t\tif (arr[i] &gt; arr[i + 1]) &#123;\n\t\t\t\t\tswap(arr, i, i + 1);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F; 交换arr的i和j位置上的值，i和j是一个位置的话，会出错\n\tpublic static void swap(int[] arr, int i, int j) &#123;\n\t\tarr[i] &#x3D; arr[i] ^ arr[j];\n\t\tarr[j] &#x3D; arr[i] ^ arr[j];\n\t\tarr[i] &#x3D; arr[i] ^ arr[j];\n\t&#125;\n\n\n\n\n插入排序public static void insertionSort(int[] arr) &#123;\n\t\tif (arr &#x3D;&#x3D; null || arr.length &lt; 2) &#123;\n\t\t\treturn;\n\t\t&#125;\n\t\t&#x2F;&#x2F; 不只1个数\n\t\tfor (int i &#x3D; 1; i &lt; arr.length; i++) &#123; &#x2F;&#x2F; 0 ~ i 做到有序\n\t\t\tfor (int j &#x3D; i - 1; j &gt;&#x3D; 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) &#123;\n\t\t\t\tswap(arr, j, j + 1);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F; i和j是一个位置的话，会出错\n\tpublic static void swap(int[] arr, int i, int j) &#123;\n\t\tarr[i] &#x3D; arr[i] ^ arr[j];\n\t\tarr[j] &#x3D; arr[i] ^ arr[j];\n\t\tarr[i] &#x3D; arr[i] ^ arr[j];\n\t&#125;\n\n\n\n位运算int a &#x3D; 7;\nint b &#x3D; -a &#x3D; (~a) + 1 &#x3D; -7;\n\n&#x2F;&#x2F; arr中，只有一种数，出现奇数次\npublic static void printOddTimesNum1(int[] arr) &#123;\n\tint eor &#x3D; 0;\n\tfor (int i &#x3D; 0; i &lt; arr.length; i++) &#123;\n\t\teor ^&#x3D; arr[i];\n\t&#125;\n\tSystem.out.println(eor);\n&#125;\n\n&#x2F;&#x2F; arr中，有两种数，出现奇数次\npublic static void printOddTimesNum2(int[] arr) &#123;\n\tint eor &#x3D; 0;\n\tfor (int i &#x3D; 0; i &lt; arr.length; i++) &#123;\n\t\teor ^&#x3D; arr[i];\n\t&#125;\n\t&#x2F;&#x2F; a 和 b是两种数\n\t&#x2F;&#x2F; eor !&#x3D; 0\n\t&#x2F;&#x2F; eor最右侧的1，提取出来\n\t&#x2F;&#x2F; eor :     00110010110111000\n\t&#x2F;&#x2F; rightOne :00000000000001000\n\tint rightOne &#x3D; eor &amp; (-eor); &#x2F;&#x2F; 提取出最右的1\n\t\n\t\n\tint onlyOne &#x3D; 0; &#x2F;&#x2F; eor&#39;\n\tfor (int i &#x3D; 0 ; i &lt; arr.length;i++) &#123;\n\t\t&#x2F;&#x2F;  arr[1] &#x3D;  111100011110000\n\t\t&#x2F;&#x2F; rightOne&#x3D;  000000000010000\n\t\tif ((arr[i] &amp; rightOne) !&#x3D; 0) &#123;\n\t\t\tonlyOne ^&#x3D; arr[i];\n\t\t&#125;\n\t&#125;\n\tSystem.out.println(onlyOne + &quot; &quot; + (eor ^ onlyOne));\n&#125;\n   &#x2F;&#x2F; 输入一定能够保证，数组中所有的数都出现了M次，只有一种数出现了K次\n   &#x2F;&#x2F; 1 &lt;&#x3D; K &lt; M\n   &#x2F;&#x2F; 返回这种数\n   public static int km(int[] arr, int k, int m) &#123;\n       int[] help &#x3D; new int[32];\n       for (int num : arr) &#123;\n           for (int i &#x3D; 0; i &lt; 32; i++) &#123;\n               help[i] +&#x3D; (num &gt;&gt; i) &amp; 1;\n           &#125;\n       &#125;\n       int ans &#x3D; 0;\n       for (int i &#x3D; 0; i &lt; 32; i++) &#123;\n           help[i] %&#x3D; m;\n           if (help[i] !&#x3D; 0) &#123;\n               ans |&#x3D; 1 &lt;&lt; i;\n           &#125;\n       &#125;\n       return ans;\n   &#125;\n\n\n\n\n\n","slug":"数据结构与算法学习","date":"2022-07-02T01:51:23.000Z","categories_index":"","tags_index":"算法与数据结构","author_index":"Aurora"},{"id":"d75b47533ffd84933c1aac3f8bde1caa","title":"前端三件套","content":"HTMLHTML：超文本标记语言超文本：超越了文本的的限制，比普通文本更强大，除了文字信息，还可以定义图片，音频，视频等内容。标记语言：由标签构成的语言\nHTML运行在浏览器上，HTML标签由浏览器来解析\nHTML标签都是预定义好的。例如：使用&lt;img&gt;展示图片\n\nW3C标准：网页主要由三部分组成\n结构：HTML\n表现：CSS\n行为：JavaScript\n\n\n\nHTML结构：\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;&lt;&#x2F;title&gt;\n    &lt;&#x2F;head&gt;\n    &lt;body&gt;\n        \n    &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\n\n\n\n\n \nCSS导入方式：\n1、使用“”引入css样式；\n2、在style标签里写css样式；\n3、在元素标签里使用style属性写css样式。\n具体使用查W3cschool\njs导入方式：\n1、直接引入\n&lt;script&gt;alert(&quot;这是js的内部引入&quot;);&lt;&#x2F;script&gt;\n2、\n定义外部js文件\n&lt;script type&#x3D;”text&#x2F;javascript” src&#x3D;”demo.js”&gt;\n基本语法结尾 ; 可有可无\n使用window.alert()写入警告框\n使用document.write()写入html输出\n使用console.log()写入浏览器控制台\n用var声明变量\nvar test &#x3D; 20;\ntest &#x3D; &quot;张三&quot;\n\nJavascript是一门弱类型语言，变量可以存放不同类型的值\n变量名命名规则：\n\n组成字符可以是任何字母，数组，下划线(_)或美元符号($)\n数字不能开头\n建议使用驼峰命名\n\nECMAScript6新增了let关键字来定义变量，它的用法类似于var，但是所声明的变量，只在let关键字所在的代码块内有效，且不允许重复声明\nECMAScript6新增了const关键字，用来声明一个只读的常量。一旦声明，常量的值就不能改变了\n\n运算符 &#x3D;&#x3D;  和  &#x3D;&#x3D;&#x3D; \nvar age1 &#x3D; 20;\nvar age2 &#x3D; &quot;20&quot;;\nalert(age1 &#x3D;&#x3D; age2) &#x2F;&#x2F;会返回true\nalert(age1 &#x3D;&#x3D;&#x3D; age2) &#x2F;&#x2F;会返回false\n&#x2F;*\n\t&#x3D;&#x3D; ：1.判断类型是否一样，如果不一样，先转换成一样\n    \t2.再判断是否相等\n\t&#x3D;&#x3D;&#x3D;：1.判断类型是否一样，如果不一样，直接返回false\n\t\t2.再判断是否相等\n*&#x2F;\n\n\n\n\n\n类型转换：其他类型转为number：\n\nstring: 按照字符串的字面值，转为数字.如果字面值不是数字，则转为NaN。一般使用parseInt\nboolean: true 转为1，false转为0\n\n其他类型转为boolean：\n\nnumber:0和NaN转为false，其他的数字转为true \nstring:空字符串转为false，其他的字符串转为true \nnull:false \nundefined:false\n\n\n\n对象Array\nString\n自定义对象\nBOMBOM：Browser Object Model 浏览器对象模型。也就是 JavaScript 将浏览器的各个组成部分封装为对象。\n我们要操作浏览器的各个组成部分就可以通过操作 BOM 中的对象来实现。比如：我现在想将浏览器地址栏的地址改为 https://www.itheima.com 就可以通过使用 BOM 中定义的 Location 对象的 href 属性，代码： location.href = &quot;https://itheima.com&quot;; \n BOM 中包含了如下对象：\n\nWindow：浏览器窗口对象\nNavigator：浏览器对象\nScreen：屏幕对象\nHistory：历史记录对象\nLocation：地址栏对象\n\n下图是 BOM 中的各个对象和浏览器的各个组成部分的对应关系\n\nwindow对象\nhistory对象\nloaction对象\nDOMDOM：Document Object Model 文档对象模型。也就是 JavaScript 将 HTML 文档的各个组成部分封装为对象。\nDOM 其实我们并不陌生，之前在学习 XML 就接触过，只不过 XML 文档中的标签需要我们写代码解析，而 HTML 文档是浏览器解析。封装的对象分为\n\nDocument：整个文档对象\nElement：元素对象\nAttribute：属性对象\nText：文本对象\nComment：注释对象\n\n如下图，左边是 HTML 文档内容，右边是 DOM 树\n\n作用：\nJavaScript 通过 DOM， 就能够对 HTML进行操作了\n\n改变 HTML 元素的内容\n改变 HTML 元素的样式（CSS）\n对 HTML DOM 事件作出反应\n添加和删除 HTML 元素\n\nDOM相关概念：\nDOM 是 W3C（万维网联盟）定义了访问 HTML 和 XML 文档的标准。该标准被分为 3 个不同的部分：\n\n核心 DOM：针对任何结构化文档的标准模型。 XML 和 HTML 通用的标准\n\nDocument：整个文档对象\n\nElement：元素对象\n\nAttribute：属性对象\n\nText：文本对象\n\nComment：注释对象\n\n\n\nXML DOM： 针对 XML 文档的标准模型\n\nHTML DOM： 针对 HTML 文档的标准模型\n该标准是在核心 DOM 基础上，对 HTML 中的每个标签都封装成了不同的对象\n\n例如：&lt;img&gt; 标签在浏览器加载到内存中时会被封装成 Image 对象，同时该对象也是 Element 对象。\n例如：&lt;input type=&#39;button&#39;&gt; 标签在浏览器加载到内存中时会被封装成 Button 对象，同时该对象也是 Element 对象。\n\n\n\n获取Element对象HTML 中的 Element 对象可以通过 Document 对象获取，而 Document 对象是通过 window 对象获取。\nDocument 对象中提供了以下获取 Element 元素对象的函数\n\ngetElementById()：根据id属性值获取，返回单个Element对象\ngetElementsByTagName()：根据标签名称获取，返回Element对象数组\ngetElementsByName()：根据name属性值获取，返回Element对象数组\ngetElementsByClassName()：根据class属性值获取，返回Element对象数组\n\n事件监听\n事件：HTML事件是发生在HTML元素身上的“事情”。比如：\n\n按钮被点击\n鼠标移动到元素之上\n按下键盘按键\n\n\n事件监听：Javascript可以在事件被侦测到时执行代码\n\n\n事件绑定方式一：通过 HTML标签中的事件属性进行绑定\nonclick 是 单击事件 的事件属性\n&lt;input type&#x3D;&quot;button&quot; onclick&#x3D;&#39;on()’&gt;\nfunction on()&#123;\n\talert(&quot;我被点了&quot;);\n&#125;\n\n方式二：通过 DOM 元素属性绑定\n&lt;input type&#x3D;&quot;button&quot; id&#x3D;&quot;btn&quot;&gt;\ndocument.getElementById(&quot;btn&quot;).onclick &#x3D; function ()&#123;\n    alert(&quot;我被点了&quot;);\n&#125;\n\n为保证单一职责，建议使用方式二\n常见事件\n","slug":"前端三件套基础入门","date":"2022-06-30T02:44:09.000Z","categories_index":"","tags_index":"前端","author_index":"Aurora"},{"id":"54e1d69dbe01003cc0c2e45b21bc6b3e","title":"Mybatis","content":"入门_MyBatis中文网(Mybatis.pdf)什么是Mybatis？\nMybatis是一款优秀的持久层框架，用于简化JDBC开发\n官网：https://mybatis.org/mybatis-3/zh/index.html\n\n持久层：\n\n负责将数据保存到数据库的那一层代码\n\nJavaEE三层架构：表现层，业务层，持久层\n\n\n框架：\n\n框架就是一个半成品软件，是一套可重用的、通用的、软件基础代码模型\n\n在框架的基础之上构建软件编写更加高效、规范、通用、可扩展\n\n\n\n快速入门\nJDBC写的是硬编码，后期维护很麻烦，无论是增删改查语句的修改，或者是用户名密码的改变，\nMyBatis虽然麻烦，不过很多步骤只做一次，后期维护非常的方便\n解决SQL映射文件的警告提示产生原因：IDEA和数据库没有建立连接，不识别表信息\n解决方法：在IDEA中配置MySQL数据库连接\n\n\nMapper代理开发\n目的\n1.解决原生方式中的硬编码\n2.简化后期执行SQL\n\n步骤\n1.定义与SQL映射文件同名的Mapper接口，并且将Mapper接口和SQL映射文件放置在同一目录下\n2.设置SQL映射文件的namespace属性为Mapper接口全限定名\n3.在Mapper接口中定义方法，方法名就是SQL映射文件中sql语句的id，并保持参数类型和返回值类型一致\n4.编码\n\n通过SqlSession的getMapper方法获取Mapper接口的代理对象\n调用对应方法完成sql的执行\n\n\n细节\n如果Mapper接口名称和SQL映射文件名称相同，并在同一目录下，则可以使用包扫描的方式简化SQL映射文件的加载\n&lt;mappers&gt;\n&lt;!--        加载sql映射文件--&gt;\n&lt;!--        &lt;mapper resource&#x3D;&quot;UserMapper.xml&quot;&#x2F;&gt;--&gt;\n&lt;!--        Mapper代理方式--&gt;\n        &lt;package name&#x3D;&quot;com.itheima.mapper&quot;&#x2F;&gt;\n    &lt;&#x2F;mappers&gt;\n\nMybatis核心配置文件详解\n注解完成增删改查\n注解即在接口方法上直接写SQL语句，不用在xml文件中再配置\n配置文件完成增删改查起别名\n定义&lt;sql&gt;片段\n定义&lt;resultMap&gt;片段\n注意事项\n参数占位符\n\n​      #{}: 执行SQL时，会将#{}占位符替换为?，将来自动设置参数值\n​      ${}: 拼SQL。会存在SQL注入问题\n​      使用时机：\n​      参数传递，都是用#{}\n​      如果要对表名，列名进行动态设置，只能使用${}进行sql拼接\n2.parameterType\n​\t\t用于设置参数类型，该参数可以省略\n3.SQL语句中特殊字符处理\n​\t转义字符\n&lt;![CDATA[内容]]&gt;\n动态SQLif标签：用于判断参数是否有值，使用test属性进行条件判断\n\n存在的问题：第一个条件不需要逻辑运算符\n\n解决方案：\n\n使用恒等式让所有条件格式都一样\n&lt;select id&#x3D;&quot;selectByCondition&quot; resultMap&#x3D;&quot;brandResultMap&quot;&gt;\n        select *\n        from tb_brand\nwhere 1 &#x3D; 1\n        &lt;if test&#x3D;&quot;status !&#x3D; null&quot;&gt;and status &#x3D; #&#123;status&#125;&lt;&#x2F;if&gt;\n        &lt;if test&#x3D;&quot;companyName !&#x3D; null and companyName !&#x3D; &#39;&#39;&quot;&gt;and company_name like #&#123;companyName&lt;&#x2F;if&gt;\n        &lt;if test&#x3D;&quot;brandName !&#x3D; null and brandName !&#x3D; &#39;&#39;&quot;&gt;and brand_name like #&#123;brandName&#125;&lt;&#x2F;if&gt;\n\n    &lt;&#x2F;select&gt;\n\n\n\n&lt;where&gt;标签替换where关键字\n&lt;select id&#x3D;&quot;selectByCondition&quot; resultMap&#x3D;&quot;brandResultMap&quot;&gt;\n        select *\n        from tb_brand\n&lt;where&gt;\n        &lt;if test&#x3D;&quot;status !&#x3D; null&quot;&gt; status &#x3D; #&#123;status&#125;&lt;&#x2F;if&gt;\n        &lt;if test&#x3D;&quot;companyName !&#x3D; null and companyName !&#x3D; &#39;&#39;&quot;&gt;and company_name like #&#123;companyName&lt;&#x2F;if&gt;\n        &lt;if test&#x3D;&quot;brandName !&#x3D; null and brandName !&#x3D; &#39;&#39;&quot;&gt;and brand_name like #&#123;brandName&#125;&lt;&#x2F;if&gt;&lt;&#x2F;where&gt;\n\n    &lt;&#x2F;select&gt;\n\n\n\n\n事务提交自动提交\nSqlSession sqlSession &#x3D; sqlSessionFactory.openSession(true);\n\n手动提交\nSqlSession sqlSession &#x3D; sqlSessionFactory.openSession();\n或\nSqlSession sqlSession &#x3D; sqlSessionFactory.openSession(false);\n\n事务后写sqlSession.commit();\n\n\n\n返回添加数据的主键\n&lt;insert useGeneratedKeys &#x3D; &quot;true&quot; keyProperty &#x3D; &quot;id&quot;&gt; \n\n\n\n\n\n上图（批量删除） 如果接口方法未加param注解，collection属性的值应该为array\n参数传递  \n参数封装\n\nMyBatis 参数封装：\n   单个参数：\n      1. POJO类型：直接使用，属性名 和 参数占位符名称 一致\n      2. Map集合：直接使用，键名 和 参数占位符名称 一致\n      3. Collection：封装为Map集合，可以使用@Param注解，替换Map集合中默认的arg键名\n          map.put(&quot;arg0&quot;,collection集合);\n          map.put(&quot;collection&quot;,collection集合);\n      4. List：封装为Map集合，可以使用@Param注解，替换Map集合中默认的arg键名\n          map.put(&quot;arg0&quot;,list集合);\n          map.put(&quot;collection&quot;,list集合);\n          map.put(&quot;list&quot;,list集合);\n      5. Array：封装为Map集合，可以使用@Param注解，替换Map集合中默认的arg键名\n          map.put(&quot;arg0&quot;,数组);\n          map.put(&quot;array&quot;,数组);\n      6. 其他类型：直接使用\n   多个参数：封装为Map集合,可以使用@Param注解，替换Map集合中默认的arg键名\n      map.put(&quot;arg0&quot;,参数值1)\n      map.put(&quot;param1&quot;,参数值1)\n      map.put(&quot;param2&quot;,参数值2)\n      map.put(&quot;agr1&quot;,参数值2)\n      ---------------@Param(&quot;username&quot;)\n      map.put(&quot;username&quot;,参数值1)\n      map.put(&quot;param1&quot;,参数值1)\n      map.put(&quot;param2&quot;,参数值2)\n      map.put(&quot;agr1&quot;,参数值2)\n\n \n\n\n","slug":"Mybatis","date":"2022-06-07T08:06:27.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"6f4f974e39a23a6637b9ccfa82544a76","title":"Maven","content":"\nMaven是专门用于管理和构建java项目的工具\n\nMaven的功能\n\n1、提供了一套标准化的项目结构\n\n2、提供了一套标准化的构建流程（编译，测试，打包，发布……）\n\n3、提供了一套依赖管理机制\n\n模型\n\n常见命令\ncompile 编译\nclean 清理\ntest 测试\npackage 打包\ninstall 安装\n\nIDEA配置Maven\nMaven坐标详解\n什么是坐标：\n\nMaven中的坐标是资源的唯一标识\n\n使用坐标来定义项目或引入项目中需要的依赖\n\n\n\nMaven坐标的主要组成\n\ngroupld：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima）\nartifactld：定义当前Maven项目名称（通常是模块名称）\nversion：定义当前项目版本号\n\n\n\n\nIDEA创建Maven项目\n依赖管理使用坐标导入jar包1.在pom.xml中编写&lt;dependencies&gt;标签\n2.在&lt;dependencies&gt;标签中 使用&lt;dependency&gt;引入坐标\n3.定义坐标的groupid，artifactld，version\n4.点击刷新按钮，使坐标生效(建议配置自动生效，无需刷新)\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;\n      &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;\n      &lt;version&gt;4.11&lt;&#x2F;version&gt;\n      &lt;scope&gt;test&lt;&#x2F;scope&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;\n      &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;\n      &lt;version&gt;5.1.48&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n  &lt;&#x2F;dependencies&gt;\n\n\n依赖范围 \n","slug":"Maven","date":"2022-05-18T08:50:49.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"f83fade08690f69bc32eef72fe024ed9","title":"JDBC总结","content":"JDBC快速入门\t(JDBC.pdf)1、编写代码步骤1、创建工程,导入驱动jar包\n jar包\n2、注册驱动Class.forName(&quot;com.mysql.jdbc.Driver&quot;);\n\n3、获取连接Connection conn &#x3D; DriverMannager.getConnection(url,username,password);\n\n4、定义SQL语句String sql &#x3D; &quot;&quot;;\n\n5、获取执行SQL的对象Statement stmt &#x3D; conn.createStatement();\n\n6、执行SQL语句stmt.executeUpdate(sql);  \n&#x2F;&#x2F;此方法会执行sql语句并返回受影响的行数。可以用\nint count &#x3D; stmt.executeUpdate(sql)接受返回值;\n\n7、处理返回结果8、释放资源stmt.close();\nconn.cloes();\n\n例\nAPI详解1、DriverManager1、注册驱动*** MYSQL 5之后的驱动包，可以省略注册驱动的步骤***\n\n这个方法可以完成驱动的注册，但是实际开发中一般不会使用这个方法完成驱动的注册\n原因：\n如果需要注册驱动，就会使用，DriverManager.registerDriver(new Driver()); ,但是查看源代码发现，在代码中一段静态代码块，静态代码块已经调用了注册驱动的方法。\n\n如果再手动调用该方法注册驱动，就会导致驱动被注册两次。实际开发中一般户次爱用;\nClass.forName(&quot;com.mysql.jdbc.Driver&quot;);\n\n2、获得与数据库的连接\n这个方法就是用来获得与数据库连接的方法，这个方法中的三个参数为 与数据库连接的路径(url)，与数据库连接的用户名(user)，与数据库连接的密码(password)。\n主要是url的写法：\njdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;db1\n\njdbc:mysql:&#x2F;&#x2F;ip地址:端口号&#x2F;数据库名称?参数键值对1&amp;参数键值对2...\n\nlocalhost           :连接的MySQL数据库服务器的主机ip地址。（连接是本机就可以写成localhost），如果连接不是本机的，就需要写上连接主机的IP地址。\nurl如果连接的是本机的路径，可以简化为如下格式：\njdbc:mysql:&#x2F;&#x2F;&#x2F;db1\n配置useSSL &#x3D; false 参数，禁用安全连接方式，解决警告提示\n2、Connection1、获取执行SQL对象普通执行SQL对象\nStatement createStatement();\n\n 预编译SQL的执行SQL对象；防止SQL注入\nPreparedStatement prepareStatement(sql);\n\n执行存储过程的对象\nCallableStatement prepareCall(sql)\n\n2、事务管理MYSQL事务管理开启事务：  begin;&#x2F;start transaction;\n提交事务：  commit;\n回滚事务：  rollback;\n\nMYSQL默认自动提交事务\n\nJDBC事务管理Connection接口中定义了3个对应的方法\n开启事务：setAutoCommit(bollean autoCommit): true为自动提交事务；false为手动提交事务，即为开启事务\n提交事务：commit()\n回滚事务：rollback()\n\n例：\npackage com.itheima.jdbc;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n&#x2F;**\n * JDBC API 详解：Connection\n *&#x2F;\npublic class JDBCDemo3_Connection &#123;\n\n    public static void main(String[] args) throws Exception &#123;\n        &#x2F;&#x2F;1. 注册驱动\n        &#x2F;&#x2F;Class.forName(&quot;com.mysql.jdbc.Driver&quot;);\n        &#x2F;&#x2F;2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写\n        String url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;db1?useSSL&#x3D;false&quot;;\n        String username &#x3D; &quot;root&quot;;\n        String password &#x3D; &quot;1234&quot;;\n        Connection conn &#x3D; DriverManager.getConnection(url, username, password);\n        &#x2F;&#x2F;3. 定义sql\n        String sql1 &#x3D; &quot;update account set money &#x3D; 3000 where id &#x3D; 1&quot;;\n        String sql2 &#x3D; &quot;update account set money &#x3D; 3000 where id &#x3D; 2&quot;;\n        &#x2F;&#x2F;4. 获取执行sql的对象 Statement\n        Statement stmt &#x3D; conn.createStatement();\n\n        try &#123;\n            &#x2F;&#x2F; 开启事务\n            conn.setAutoCommit(false);\n            &#x2F;&#x2F;5. 执行sql\n            int count1 &#x3D; stmt.executeUpdate(sql1);&#x2F;&#x2F;受影响的行数\n            &#x2F;&#x2F;6. 处理结果\n            System.out.println(count1);\n            int i &#x3D; 3&#x2F;0;\n            &#x2F;&#x2F;5. 执行sql\n            int count2 &#x3D; stmt.executeUpdate(sql2);&#x2F;&#x2F;受影响的行数\n            &#x2F;&#x2F;6. 处理结果\n            System.out.println(count2);\n\n            &#x2F;&#x2F; 提交事务\n            conn.commit();\n        &#125; catch (Exception throwables) &#123;\n            &#x2F;&#x2F; 回滚事务\n            conn.rollback();\n            throwables.printStackTrace();\n        &#125;\n\n\n\n        &#x2F;&#x2F;7. 释放资源\n        stmt.close();\n        conn.close();\n    &#125;\n&#125;\n\n3、Statement1、执行SQL语句int executeUpdate(sql):执行DML、DDL语句\n返回值（1）DML语句影响的行数（2）DDL语句执行后，执行成功也可能返回0\n\nResultSet executeQuery(sql):执行DQL语句\n返回值：Result结果集对象\n\n4、ResultSet封装了DQL查询语句的结果ResultSet stmt.executeQuery(sql); 执行DQL语句，返回ResultSet对象\n\n获取查询结果boolean next(): (1)将光标从当前位置向前移动一行 (2)判断当前行是否为有效行\n返回值 true：有效行，当前行有数据   false：无效行，当前行没有数据\n\nxxx getXxx(参数):获取数据\nxxx：数据类型，如 ： int getInt(参数) String getString(参数)\n参数：int： 列的编号，从1开始\n\t string：列的名称\n\n使用步骤1、游标向下移动一行，并判断该行是否有数据：next()\n2 、获取数据：getXxx(参数)\n&#x2F;&#x2F;循环判断游标是否是最后一行末尾\nwhile(rs.next())\n&#123;\n\t&#x2F;&#x2F;获取数据\n\trs.getXxx(参数);\n&#125;\n\n5、PreparedStatement作用：预编译SQL语句并执行，防止SQL注入问题如：用户名随便写，密码写成’ or ‘ 1 ‘ &#x3D; ‘1\n用法：1、获取PreparedStatement对象&#x2F;&#x2F;SQL语句中的参数值，使用？占位符替代\nString sql &#x3D; &quot;select * from user where username &#x3D; ? and password &#x3D; ？&quot;;\n&#x2F;&#x2F;通过Connection对象获取，并传入对应的SQL语句\nPreparedStatement pstmt &#x3D; conn.prepareStatement(sql);\n\n2、设置参数值PreparedStatement对象:setXxx(参数1,参数2):给？赋值\nXxx:数据类型，如setInt(参数1,参数2)\n参数：\n参数1：？的位置编号，从1开始\n参数2：？的值\n\n3、执行SQLexecuteUpdate();&#x2F;executeQuery(); :不需要再传递sql\n\n\n\n例public class JDBCDemo7_PreparedStatement &#123;\n\n    @Test\n    public void testPreparedStatement() throws  Exception &#123;\n       &#x2F;&#x2F;2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写\n       String url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;db1?useSSL&#x3D;false&quot;;\n       String username &#x3D; &quot;root&quot;;\n       String password &#x3D; &quot;1234&quot;;\n       Connection conn &#x3D; DriverManager.getConnection(url, username, password);\n\n       &#x2F;&#x2F; 接收用户输入 用户名和密码\n        String name &#x3D; &quot;zhangsan&quot;;\n        String pwd &#x3D; &quot;&#39; or &#39;1&#39; &#x3D; &#39;1&quot;;\n\n        &#x2F;&#x2F; 定义sql\n        String sql &#x3D; &quot;select * from tb_user where username &#x3D; ? and password &#x3D; ?&quot;;\n\n        &#x2F;&#x2F; 获取pstmt对象\n        PreparedStatement pstmt &#x3D; conn.prepareStatement(sql);\n\n        &#x2F;&#x2F; 设置？的值\n        pstmt.setString(1,name);\n        pstmt.setString(2,pwd);\n\n        &#x2F;&#x2F; 执行sql\n        ResultSet rs &#x3D; pstmt.executeQuery();\n\n        &#x2F;&#x2F; 判断登录是否成功\n        if(rs.next())&#123;\n            System.out.println(&quot;登录成功~&quot;);\n        &#125;else&#123;\n            System.out.println(&quot;登录失败~&quot;);\n        &#125;\n\n        &#x2F;&#x2F;7. 释放资源\n        rs.close();\n        pstmt.close();\n        conn.close();\n    &#125;\n\n好处：1、预编译SQL，性能更高\n2、防止SQL注入，将敏感字符进行转义\nPreparedStatement预编译功能开启：useServerPrepStmts&#x3D;true\n（参数键值对）应加在URL最后\n配置MySQL执行日志（重启mysql服务后生效）\nlog-output&#x3D;FILE\ngeneral-log&#x3D;1\ngeneral_log_file&#x3D;&quot;D:\\mysql.log&quot;\nslow-query-log&#x3D;1\nslow_query_log_file&#x3D;&quot;D:\\mysql_slow.log&quot;\nlong_query_time&#x3D;2\n\n原理：1、在获取PreparedStatement对象时，将sql语句发送给mysql服务器进行检查，编译（这些步骤很耗时）\n2、执行时就不用再进行这些步骤了，速度更快\n3、如果sql模板一样，则只需要进行一次检查编译\n\n数据库连接池简介\n数据库连接池是个容器，负责分配，，管理数据库连接\n\n它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个\n\n释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏\n\n好处：\n\n资源重用\n\n提升系统响应速度\n\n避免数据库连接遗漏\n\n\n\n\n数据库连接池实现标准接口\n官方（SUN）提供的数据库连接池标准接口，由第三方组织实现此接口。\n功能：获取连接\n\nConnection getConnection()\n\n常见的数据库连接池：\nDBCP\nC3P0\nDruid\n\nDruid（德鲁伊）\nDruid连接池是阿里巴巴开源的数据库连接池项目\n功能强大，性能优秀，是Java语言最好的数据库连接池之一\n\n","slug":"JDBC总结","date":"2022-05-07T02:47:07.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"758e18fa21f3b95498a42a108b10694c","title":"SQL总结","content":"SQL通用语法1.SQL语句可以单行或多行书写，以分号结尾。\n2.MYSQL数据库的SQL语句不区分大小写，关键字建议适用大写。\n3.注释\n （1） 单行注释：– 注释内容（两个横杠一个空格+注释内容） 或 #注释内容（MYSQL特有)\n（2） 多行注释： &#x2F;* 注释 *&#x2F;\n对 MYSQL 的 windows命令1、启动mysql服务net start mysql 启动 mysql 服务\nnet stop mysql 关闭 mysql 服务\n\n2、进入mysql，输入密码：mysql -hlocalhost -uroot -proot 进入mysql数据库，其中-h表示服务器名，localhost表示本地；\n-u为数据库用户名，root是mysql默认用户名；-p为密码，如果设置了密码，可直接在-p后直接输入。\n\nmysql -u root -p;\n\n对数据库的操作1、查看所有数据库mysql&gt; show databases;\n\n2、创建数据库mysql&gt; create database; 数据库名称\n如果数据库已经存在，则会报错\n可使用\nmysql&gt; create database if not exists; 数据库名称\n\n3、删除数据库drop database 数据库名称;\ndrop database if exists 数据库名称;\n\n4、使用数据库使用数据库 use 数据库名称;\n\n5、查看当前使用的数据库select database();\n\n对表的操作· 创建（create）\n·查询（retrieve）\n·修改（update）\n·删除（delete）\n1、创建（create）创建表create table 表名(\n\t\t字段名1 数据类型1,\n\t\t字段名2 数据类型2,\n\t\t...\n\t\t字段名n 数据类型n\n);\n\n最后一行末尾不能加逗号\n2、查询（retrieve）查询当前数据库下所有表名称show tables;\n\n查询表结构desc 表名称;\n\n3、修改（update）修改表名alter table 表名 rename to 新的表名;\n\n添加一列alter table 表名 add 列名 数据类型;\n\n修改数据类型alter table 表名 modify 列名 新数据类型;\n\n修改列名和数据类型alter table 表名 change 列名 新列名 新数据类型;\n\n删除列alter table 表名 drop 列名;\n\n\n\n4、删除（delete）删除表drop table 表名;\ndrop table if exists 表名;\n\n对数据的操作添加数据1、给指定列添加数据insert into 表名(列名1,列名2，...)values(值1,值2,...); \n\n2、给全部列添加数据insert into 表名 values(值1,值2,...);\n\n3、批量添加数据insert into 表名(列名1,列名2,...) values(值1,值2,...),(值1,值2,...),(值1,值2,...)...;\n\ninsert into 表名 values(值1,值2,...),(值1,值2,...),(值1,值2,...)...;\n\n修改数据1、修改表数据update 表名 set 列名1&#x3D;值1,列名2&#x3D;值2,...[where 条件];\n\n修改语句如果不加条件，则所有数据都将被修改!\n删除数据1、删除数据delete from 表名 [where 条件];\n\n删除语句如果不加条件，则所有数据都将被删除\n查询数据select\n\t字段列表\nfrom\n\t表名列表\nwhere\n\t条件列表\ngroup by\n\t分组字段\nhaving\n\t分组后条件\norder by\n\t排序字段\nlimit\n\t分页限定\n\n\n\n\n\n\n\n\n约束 \n外键约束\n数据库设计\n\n\n多表查询内连接隐式内连接\nselect 字段列表 from 表1,表2... where 条件;\n\n显式内连接\nselect 字段列表 from 表1 [inner] join 表2 on 条件；\n\n内连接相当于查询A B 交集数据\n外连接左外连接\nselect 字段列表 from 表1 left [outer] join 表2 on 条件；\n右外连接\nselect 字段列表 from 表1 right [outer] join 表2 on 条件；\n\n左外连接 ：相当于查询A表所有数据和交集部分数据\n右外连接 ：相当于查询B表所有数据和交集部分数据\n子查询子查询根据查询结果不同，作用不同;1、单行单列:作为条件值，使用&#x3D;,!&#x3D;,&gt;,&lt;等进行条件判断\nselect 字段列表 from 表 where 字段名 &#x3D; (子查询)；\n\n2、多行单列:作为条件值，使用in等关键字进行条件判断\nselect 字段列表 from 表 where 字段名 in (子查询)；\n\n 3、多行duolie:作为虚拟表\nselect 字段列表 from (子查询) where 条件；\n\n事物1、开启事务start transaction; 或者 begin;\n\n2、提交事务commit;\n\n3、回滚事务rollback;\n\n4、事务的特性\n5.事务提交mysql事务默认自动提交\n-- 查看事物的默认提交方式\nselect @@autocommit;\n-- 1 自动提交 0 手动提交\n-- 修改事务提交方式\nset @@autocommit &#x3D; 0;\n","slug":"SQL总结","date":"2022-04-30T08:59:10.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"a64b935a3dc12ce8d8b93a103ca9afe0","title":"java核心技术卷总结","content":"1.&amp;&amp;和|| 运算符是按照“短路”方式来求值的：如果第一个操作数已经能够确定表达式的值，第二个操作数就不必计算了。2.位移运算符的右操作数要完成模32的运算（除非左操作数是long类型，在这种情况下需要对右操作数模64）。例如，1&lt;&lt;35的值等同于1&lt;&lt;3或8。3.同一个级别的运算符按照从左到右的次序进行计算（但右结合运算符除外）&amp;&amp; 优先级大于 | | 。4.String类的substring方法可以从一个较大的字符串提取出一个子串。例如：    String greeting &#x3D; “Hello”;            String a &#x3D; greeting.substring(0,3);    打印 a 会输出    Hel。    即输出[a,b)。5.检测字符串是否相等string a &#x3D; “ok”;string b &#x3D; “ok”;a.equals(b)；“ok”.equals(“ok”);“ok”.equals(“b”);想要检测两个字符串是否相等，而不区分大小写，可用equalsIgnoreCase方法。“Hello”. equalsIgnoreCase(“hello”);6.一定不要使用&#x3D;&#x3D;来检测两个字符串是否相等!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! &#x3D;&#x3D;只能够确定两个字符串是否存放在同一位置上。当然，如果存放在同一位置上，它们必然相等。但是，完全有可能将内容相同的多个字符串副本放置在不同位置上。如果虚拟机始终将相同的字符串共享，就可以使用&#x3D;&#x3D;运算符检测是否相等。但实际上只有字符串字面量是共享的，而+或substring等操作得到的字符串并不共享。因此，千万不要视同&#x3D;&#x3D;运算符测试字符串的相等性！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！7.检查一个字符串既不是null也不是空串 if(str!&#x3D;null &amp;&amp; str.length()!&#x3D;0)。\n","slug":"java核心技术卷总结","date":"2022-04-25T11:48:12.000Z","categories_index":"","tags_index":"","author_index":"Aurora"}]