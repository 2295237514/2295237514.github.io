[{"id":"7d9c89a385e4c0812895a5fe3ae29a80","title":"计算机操作系统原理+代码开发实战","content":"hello world\n","slug":"计算机操作系统原理-代码开发实战","date":"2022-09-08T22:35:28.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"0b1381c4a63c09e41167c5168339035a","title":"JVM","content":"定义： Java Virtual Machine - java程序的运行环境 (java二进制字节码的运行环境)\n好处：\n\n一次编写，到处运行\n自动内存管理，垃圾回收功能\n数据下标越界检查\n多态\n\n比较：\n​\tJRE: Java Runtime Enviroment（）\n\n常见的JVM:\n\n学习路线：\n\n内存结构程序计数器\nProgram Counter Register 程序计数器（寄存器）\n\n作用：​\t用于保存下一条JVM指令的执行地址地址\n特点：​\t1.是线程私有的:\n\nCPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码\n\n程序计数器是每个线程所私有的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令\n\n\n​\t2.不会存在内存溢出\n虚拟机栈定义：\n每个线程运行时所需要的内存，称为虚拟机栈\n每个栈由多个栈帧组成，对应着每次方法调用时所占用的内存\n每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法\n\n 问题辨析：\n1.垃圾回收是否涉及栈内存？\n\n不涉及，因为虚拟机栈是有一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。\n\n2.栈内存的分配越大越好吗？\n\n不是，因为物理内存是一定的，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越来越少\n\n3.方法内的局部变量是否是线程安全的？\n\n如果方法内局部变量没有逃离方法的作用范围，则是线程安全的\n如果局部变量引用了对象，并逃离了方法的作用范围，则需要考虑线程安全问题\n\n栈内存溢出Java.lang.stackOverflowError 栈内存溢出\n\n栈帧过多导致栈内存溢出（无限递归）\n栈帧过大导致内存溢出\n\n线程运行诊断CPU占用过高\n\nLinux环境下运行某些程序的时候，可能导致CPU的占用过高，这是需要定位占用CPU过高的线程\nps H -en pid, tid, %cpu | grep 刚才通过top查到的进程号 通过ps命令进一步查看是哪个线程占用CPU过高\njstack 进程id 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来对比定位，注意jstack查找出的线程id是16禁止的，需要转换\n\n\n\n迟迟得不到结果\n\n可能发生了死锁\n\n本地方法栈一些带有native关键字的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法\n堆定义通过new关键字，创建的对象都会使用堆内存\n特点\n他是线程共享的，堆中对象都需要考虑线程安全的问题\n有垃圾回收机制\n\n堆内存溢出java.lang.OutofMemoryError ：java heap space\n堆内存诊断1.jps工具\n\n查看当前系统中有哪些java进程\n\n2.jmap工具\n\n查看堆内存占用情况\n\n3.jconsole工具\n\n图形界面的，多功能的监测工具，可以连续监测\n\n4.jvirsalvm\n方法区定义方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。\n\n方法区内存溢出\n1.8以前会导致永久代内存溢出\n1.8之后会导致元空间内存溢出\n\n通过反编译来查看类的信息\n获得对应类的.class文件\n\n在JDK对应的bin目录下运行cmd，也可以在IDEA控制台输入\n\n输入 javac 对应类的绝对路径\nF:\\JAVA\\JDK8.0\\bin&gt;javac F:\\Thread_study\\src\\com\\nyima\\JVM\\day01\\Main.javaCopy\n\n输入完成后，对应的目录下就会出现类的.class文件\n\n\n\n在控制台输入 javap -v 类的绝对路径\njavap -v F:\\Thread_study\\src\\com\\nyima\\JVM\\day01\\Main.classCopy\n\n然后能在控制台看到反编译以后类的信息了\n\n\n运行时常量池\n常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息\n运行时常量池，常量池是*.class文件中的，当该类被加载，他的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址\n\n","slug":"JVM","date":"2022-07-28T00:37:05.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"5bf9428aa95fdc2b26bf23a606aad789","title":"SSM","content":"spring官网\nSpring\nSpring Framework是Spring生态圈中最基础的项目，是其他项目的根基\n\n\n学习路线\n核心容器的核心概念\n代码书写现状\n\n代码耦合度高\n\n\n解决方案\n\n使用对象时，在程序中不要主动使用new产生对象，转换为由外部提供对象\n\n\nIoC(Inversion of Control) 控制反转\n\n对象的创建控制权由程序转移到外部，这种思想称为控制反转\n目标：解耦\n\n\nSpring技术对IoC思想进行了实现\n\nSpring提供了一个容器，称为IoC容器，用来充当IoC思想的外部\nIoC容器负责对象的创建、初始化等一系列工作，被创建或被管理的对象在IoC容器中统称为Bean\n\n\nDI(Dependency Injection)依赖注入\n\n在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入\n\n\n\n\n本节总结：\n\n目标：充分解耦\n在IoC容器中管理bean（IoC）\n在IoC容器内将有依赖关系的bean进行关系绑定（DI）\n\n\n最终效果\n使用对象时不仅可以直接从IoC容器中获取，并且获取的bean已经绑定了所有的依赖关系\n\n\n\nIoC入门案例思路分析 1.管理什么？(Service与Dao)\n2.如何将被管理的对象告知IoC容器？(配置)\n3.被管理的对象交给IoC容器，如何获取到IoC容器？(接口)\n4.IoC容器得到后，如何从容器中获取bean？(接口方法)\n5.使用Spring时怎么导入坐标(pom.xml)\n使用步骤：\n1.导jar包\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;5.2.10.RELEASE&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n2.定义spring管理的类（接口）\n3.创建Spirng配置文件，配置对应类作为Spring管理的bean\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;\n\n    &lt;bean id&#x3D;&quot;bookDaoBean&quot; class&#x3D;&quot;com.itheima.dao.impl.BookDaoImpl&quot;&#x2F;&gt;\n    &lt;bean id&#x3D;&quot;bookServiceBean&quot; class&#x3D;&quot;com.itheima.service.impl.BookServiceImpl&quot;&#x2F;&gt;\n&lt;&#x2F;beans&gt;\n\n注意事项：bean定义式id属性在同一个上下文中不能重复\n4.初始化IoC容器，通过容器获取bean\nApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);\n\n需要获取的对象的类型 bookDao &#x3D; (需要获取的对象类型)applicationContext.getBean(&quot;bookDaoBean&quot;);\n\napplicationContext.getBean(“”)获取的是一个Object类型的对象，应对其进行强制类型转换\nDI入门案例1.基于IoC管理bean\n2.Service中使用new形式创建的Dao对象是否保留？(否)\n3.Service中需要的Dao对象如何进入到Service中？(提供方法)\n4.Service与Dao间的关系如何描述？(配置)\n使用步骤：\n1.删除使用new的形式创建对象的代码\nprivate BookDao bookDao &#x3D; new BookDaoImpl();\npublic void save(){    System.out.println(“book service 。。。”);    bookDao.save();}\n2.提供依赖对象对应的setter方法\npublic class BookServiceImpl implements BookService &#123;\n\n    private BookDao bookDao;\n\n    public void save()&#123;\n        System.out.println(&quot;book service 。。。。。。&quot;);\n        bookDao.save();\n    &#125;\n\n    public void setBookDao(BookDao bookDao) &#123;\n        this.bookDao &#x3D; bookDao;\n    &#125;\n&#125;\n\n3.配置service与dao之间的关系\n&lt;bean id&#x3D;&quot;bookServiceBean&quot; class&#x3D;&quot;com.itheima.service.impl.BookServiceImpl&quot;&gt;\n        &lt;property name&#x3D;&quot;bookDao&quot; ref&#x3D;&quot;bookDaoBean&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n&#x2F;&#x2F; property 标签中 name是 id&#x3D;&quot;bookServiceBean&quot;对象里属性的名称   ref则是bean对象的名称\n\nbean基础配置别名配置姓名：name\n类型：属性\n所属：bean标签\n范例\n&lt;bean id&#x3D;&quot;bookServiceBean&quot; name&#x3D;&quot;FirstBean,SecondBean&quot; class&#x3D;&quot;com.itheima.service.impl.BookServiceImpl&quot;&gt;\n        &lt;property name&#x3D;&quot;bookDao&quot; ref&#x3D;&quot;bookDaoBean&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n\n注意事项\n获取bean无论是通过id还是name获取，如果无法获取到，将抛出异常NoSuchBeanDefinitionException\nNoSuchBeanDefinitionException: No bean named ‘bookServiceImpl’ available\nbean作用范围说明\n可见，Spring默认给我们创建的bean是一个单例模式，\n我们可以通过在 bean标签中设置属性 scope&#x3D;”prototype”来讲bean设置成非单例\n\n适合交给容器进行管理的bean\n表现层对象\n业务层对象\n数据层对象\n工具对象\n\n\n不适合交给容器进行管理的bean\n封装实体的域对象\n\n\n\n单例bean与原型bean的区别单例bean：如果一个bean被声明为单例的时候，在处理多次请求的时候在Spring容器里只实例化出一个bean，后续的请求都公用这个对象，这个对象会保存在一个map里面。当有请求来的时候会先从缓存(map)里查看有没有，有的话直接使用这个对象，没有的话才实例化一个新的对象，所以这是个单例的。（ThreadLocal ）创建完后，后面都会复用这个bean\n原型(prototype)bean来说当每次请求来的时候直接实例化新的bean，没有缓存以及从缓存查的过程。\n结论：\n单例的bean只有第一次创建新的bean 后面都会复用该bean，所以不会频繁创建对象。\n原型的bean每次都会新创建\n单例bean的优势由于不会每次都新创建新对象所以有一下几个性能上的优势：\n1.减少了新生成实例的消耗新生成实例消耗包括两方面，第一，Spring会通过反射或者cglib来生成bean实例这都是耗性能的操作，其次给对象分配内存也会涉及复杂算法。\n2.减少jvm垃圾回收由于不会给每个请求都新生成bean实例，所以自然回收的对象少了。\n3.可以快速获取到bean因为单例的获取bean操作除了第一次生成之外其余的都是从缓存里获取的所以很快。\n单例bean的劣势单例的bean一个很大的劣势就是他不能做到线程安全！！！尤其是高并发情况下。\n由于所有请求都共享一个bean实例，所以这个bean要是有状态的一个bean的话可能在并发场景下出现问题，而原型的bean则不会有这样问题（但也有例外，比如他被单例bean依赖），因为给每个请求都新创建实例。\nbean实例化的三种方式构造方法（常用）\nbean本质上就是对象，创建bean使用构造方法完成\n\npublic class BookDaoImpl implements BookDao &#123;\n\n&#x2F;&#x2F;    private BookDaoImpl()&#123;\n&#x2F;&#x2F;        System.out.println(&quot;book dao struct is running......&quot;);\n&#x2F;&#x2F;    &#125;\n    public void save() &#123;\n        System.out.println(&quot;BookDao 我他吗来啦&quot;);\n    &#125;\n&#125;\n\n\n\n\n提供可访问的构造方法\n\n&lt;bean id&#x3D;&quot;bookDaoBean&quot; class&#x3D;&quot;com.itheima.dao.impl.BookDaoImpl&quot;&#x2F;&gt;\n\n静态工厂（了解）\n实例工厂\nFactoryBean（实用）\nbean生命周期\n生命周期：从创建到销毁的完整过程\nbean生命周期控制：在bean创建后到销毁前做一些事情\n\n\n接口控制（了解）\n\nbean生命周期\n初始化容器\n1.创建对象（内存分配）\n2.执行构造方法\n3.执行属性注入（set操作）\n4.执行bean初始化方法\n\n使用bean\n1.执行业务操作\n\n关闭&#x2F;销毁容器\n1.执行bean销毁方法\n\n\nbean销毁时机\n容器关闭前触发bean的销毁\n\n关闭容器方式：\n\n手工关闭容器\nConfigurableApplicationContext接口close（）方法\n\n注册关闭钩子，在虚拟机退出前先关闭容器再退出虚拟机\nConfigurableApplicationContext接口registerShutdownHook（）操作\n\n\n\n\n依赖注入方式\n思考：向一个类中传递数据的方式有几种？\n\n普通方法（set方法）\n构造方法\n\n\n思考：依赖注入描述了在容器中简历bean与bean之间依赖关系的过程，如果bean运行需要的是数据或字符串呢？\n\nsetter注入\n\n简单类型\n\n\n引用类型\n\n\n\n\n构造器注入\n\n简单类型\n\n\n引用类型\n\n\n\n\n\n依赖注入方式选择1.强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现\n2.可选依赖使用setter注入进行，灵活性强\n3.Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨\n4.如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入\n5.实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入\n6.自己开发的模块推荐使用setter注入\n自动装配\nIoC容器根据bean所以来的资源在容器中自动查找并注入到bean中的过程称为自动装配\n\n自动装配方式\n\n按类型（常用）\n按名称\n按构造方法\n不启用自动装配\n\n\n配种中使用bean标签autowire\n\n\n\n\n自动装配用于引用类型依赖注入，不能对简单类型进行操作\n使用按类型装配时(byType)必须保障容器中想同类型的bean唯一，推荐使用\n使用按名称装配时(byName)必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用\n自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效\n\n集合注入数组，List，Set，Map,Properties\nbean所依赖的实现类\npublic class BookDaoImpl implements BookDao &#123;\n\n    private int[] array;\n\n    private List&lt;String&gt; list;\n\n    private Set&lt;String&gt; set;\n\n    private Map&lt;String,String&gt; map;\n\n    private Properties properties;\n\n\n\n\n    public void setArray(int[] array) &#123;\n        this.array &#x3D; array;\n    &#125;\n\n    public void setList(List&lt;String&gt; list) &#123;\n        this.list &#x3D; list;\n    &#125;\n\n    public void setSet(Set&lt;String&gt; set) &#123;\n        this.set &#x3D; set;\n    &#125;\n\n    public void setMap(Map&lt;String, String&gt; map) &#123;\n        this.map &#x3D; map;\n    &#125;\n\n    public void setProperties(Properties properties) &#123;\n        this.properties &#x3D; properties;\n    &#125;\n\n\n\n\n    public void save() &#123;\n        System.out.println(&quot;book dao save ...&quot;);\n\n        System.out.println(&quot;遍历数组:&quot; + Arrays.toString(array));\n\n        System.out.println(&quot;遍历List&quot; + list);\n\n        System.out.println(&quot;遍历Set&quot; + set);\n\n        System.out.println(&quot;遍历Map&quot; + map);\n\n        System.out.println(&quot;遍历Properties&quot; + properties);\n    &#125;\n&#125;\n\napplicationContext.xml\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;\n    &lt;bean id&#x3D;&quot;bookDao&quot; class&#x3D;&quot;com.itheima.dao.impl.BookDaoImpl&quot;&gt;\n        &lt;!--数组注入--&gt;\n        &lt;property name&#x3D;&quot;array&quot;&gt;\n            &lt;array&gt;\n                &lt;value&gt;100&lt;&#x2F;value&gt;\n                &lt;value&gt;200&lt;&#x2F;value&gt;\n                &lt;value&gt;300&lt;&#x2F;value&gt;\n            &lt;&#x2F;array&gt;\n        &lt;&#x2F;property&gt;\n        &lt;!--list集合注入--&gt;\n        &lt;property name&#x3D;&quot;list&quot;&gt;\n            &lt;list&gt;\n                &lt;value&gt;itcast&lt;&#x2F;value&gt;\n                &lt;value&gt;itheima&lt;&#x2F;value&gt;\n                &lt;value&gt;boxuegu&lt;&#x2F;value&gt;\n                &lt;value&gt;chuanzhihui&lt;&#x2F;value&gt;\n            &lt;&#x2F;list&gt;\n        &lt;&#x2F;property&gt;\n        &lt;!--set集合注入--&gt;\n        &lt;property name&#x3D;&quot;set&quot;&gt;\n            &lt;set&gt;\n                &lt;value&gt;itcast&lt;&#x2F;value&gt;\n                &lt;value&gt;itheima&lt;&#x2F;value&gt;\n                &lt;value&gt;boxuegu&lt;&#x2F;value&gt;\n                &lt;value&gt;boxuegu&lt;&#x2F;value&gt;\n            &lt;&#x2F;set&gt;\n        &lt;&#x2F;property&gt;\n        &lt;!--map集合注入--&gt;\n        &lt;property name&#x3D;&quot;map&quot;&gt;\n            &lt;map&gt;\n                &lt;entry key&#x3D;&quot;country&quot; value&#x3D;&quot;china&quot;&#x2F;&gt;\n                &lt;entry key&#x3D;&quot;province&quot; value&#x3D;&quot;henan&quot;&#x2F;&gt;\n                &lt;entry key&#x3D;&quot;city&quot; value&#x3D;&quot;kaifeng&quot;&#x2F;&gt;\n            &lt;&#x2F;map&gt;\n        &lt;&#x2F;property&gt;\n        &lt;!--Properties注入--&gt;\n        &lt;property name&#x3D;&quot;properties&quot;&gt;\n            &lt;props&gt;\n                &lt;prop key&#x3D;&quot;country&quot;&gt;china&lt;&#x2F;prop&gt;\n                &lt;prop key&#x3D;&quot;province&quot;&gt;henan&lt;&#x2F;prop&gt;\n                &lt;prop key&#x3D;&quot;city&quot;&gt;kaifeng&lt;&#x2F;prop&gt;\n            &lt;&#x2F;props&gt;\n        &lt;&#x2F;property&gt;\n    &lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;\n\n\n第三方资源配置管理\n导入druid坐标\n&lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;1.1.16&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n\n配置数据源对象作为spring管理的bean\n&lt;bean class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;\n        &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;spring_db&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n加载properties文件由于上次学习将数据库的用户名，密码，全配置在applicationContext.xml之中，非常的危险，故应该使用properties文件记录数据库信息\n1.开启context命名空间\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xsi:schemaLocation&#x3D;&quot;\n            http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n            http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n            http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context\n            http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd\n            &quot;&gt;\n    &lt;!--  将含有beans的代码复制一份并用context替换beans--&gt;\n\n\n\n2.使用context空间加载properties文件\n&lt;context:property-placeholder location&#x3D;&quot;classpath*:*.properties&quot; system-properties-mode&#x3D;&quot;NEVER&quot;&#x2F;&gt;\n\n\n\n\n使用属性占位符${}读取properties文件中的属性\n\n&lt;bean class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;\n        &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;$&#123;jdbc.Driver&#125;&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n4.自己配置的 jdbc.properties文件内容\njdbc.driver&#x3D;com.mysql.jdbc.Driver\njdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;spring_db\njdbc.username&#x3D;root\njdbc.password&#x3D;root\n\n\n容器创建容器\n获取bean\n容器类结构层次\nBeanFactory\n类路径加载配置文件\n\n\n核心容器总结\nBeanFactory是IoC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载\nApplicationContext接口是Spring容器的核心接口，初始化时bean立即加载\nApplicationContext接口提供基础的bean操作相关方法，通过其他接口扩展其功能\nApplicationContext接口常用初始化类\nClassPathXmlApplicationContext\nFileSystemXmlApplicationContext\n\n\n\nbean相关\n依赖注入相关\n注解开发注解开发定义bean\n\n同时这几个注解后面也可以添加一些参数，比如比较常用的一个是注解的括号中加value属性，来表示这个组件在容器中的ID，如果不设置value值时，默认的ID是类名的全称（第一个字母小写）。\n在这里有一点需要注意：事实上Spring并没有能力识别一个组件到底是不是它所标记的类型，即使将@Respository注解用在一个表述层控制器组件上面也不会产生任何错误，所以@Respository、@Service、@Controller这几个注解仅仅是为了让开发人员自己明确当前的组件扮演的角色。方便将组件加入到容器中去。\n纯注解开发\nSpring3.0升级了纯注解开发模式，使用java类替代配置文件，开启了Spring快速开发赛道\n\n读取Spring核心配置文件初始化容器对象切换为读取Java配置类初始化容器对象\n&#x2F;&#x2F;加载配置文件初始化容器\nApplicationContext ctx &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);\n&#x2F;&#x2F;加载配置类初始化容器    \nApplicationContext ctx &#x3D; new AnnotationConfigApplicationContext(SpringConfig.class);\n\n\n\n\n\n\n\nJava类替代Spring核心配置文件\n\n\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xsi:schemaLocation&#x3D;&quot;\n        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;\n\n    &lt;context:component-scan base-package&#x3D;&quot;com.itheima&quot;&#x2F;&gt;\n\n&lt;&#x2F;beans&gt;\n\n\n&#x2F;&#x2F;配置文件被替换为\n\n\n&#x2F;&#x2F;声明当前类为Spring配置类\n@Configuration\n&#x2F;&#x2F;设置bean扫描路径，多个路径书写为字符串数组格式\n@ComponentScan(&#123;&quot;com.itheima.service&quot;,&quot;com.itheima.dao&quot;&#125;)\npublic class SpringConfig &#123;\n&#125;\n\n\n\n@Configuration注解用于设定当前类为配置类\n\n@ComponentScan注解用于设定扫描路径，次注解只能添加一次，多个数据请用数组格式\n@ComponentScan(&#123;&quot;com.itheima.service&quot;,&quot;com.itheima.dao&quot;&#125;)\n\n注解开发小结1.定义bean\n\n@Component\n@Controller\n@Service\n@Repository\n\n\n&lt;context:component-scan&#x2F;&gt;\n\n2.纯注解开发\n\n@Configuration\n@ComponentScan\nAnnotationConfigApplicationContext\n\nbean作用范围与生命周期管理\n使用@Scope定义bean作用范围\n\n@Repository\n@Scope(&quot;singleton&quot;)\npublic class BookDaoImpl implements BookDao&#123;\n&#125;\n\n使用@PostConstruct、@PreDestroy定义bean生命周期\n@Repository\n@Scope(&quot;singleton&quot;)\npublic class BookDaoImpl implements BookDao&#123;\n\tpublic BookDaoImpl()&#123;\n\t\tSystem.out.println(&quot;book dao constructor ...&quot;);\n\t&#125;\n    @PostConstruct\n    public void init()&#123;\n        System.out.println(&quot;book init ...&quot;);\n    &#125;\n    @PreDestroy\n    public void destroy()&#123;\n        System.out.println(&quot;book destroy ...&quot;)\n    &#125;\n&#125;\n\n依赖注入\n使用@Autowired注解开发自动装配模式(按类型)\n\n@Service\npublic class bookServiceImpl implements BookService&#123;\n\t@Autowired\n\tprivate BookDao bookDao;\n\t\n\tpublic void save()&#123;\n\t\tSystem.out.println(&quot;book service save ...&quot;);\n\t\tbookDao.save();\n\t&#125;\n&#125;\n\n\n注意：自动装配基于反射设计创建对象并暴力反射对应属性为私有属性初始化数据，隐藏无需提供setter方法\n注意：自动装配建议使用无参构造方法创建对象(默认)，如果不提供对应构造对象，请提供唯一的构造方法\n\n\n\n使用@Qualifier注解开启指定名称装配bean\n\n@Service\npublic class BookServiceImpl implements BookService &#123;\n    &#x2F;&#x2F;@Autowired：注入引用类型，自动装配模式，默认按类型装配\n    @Autowired\n    &#x2F;&#x2F;@Qualifier：自动装配bean时按bean名称装配\n    @Qualifier(&quot;bookDao&quot;)\n    private BookDao bookDao;\n\n    public void save() &#123;\n        System.out.println(&quot;book service save ...&quot;);\n        bookDao.save();\n    &#125;\n&#125;\n\n\n注意：@Qualifier注解无法单独使用，必须配合@Autowired注解使用\n\n\n\n使用@Value实现简单类型注入\n\n@Repository(&quot;bookDao&quot;)\npublic class BookDaoImpl implements BookDao &#123;\n    &#x2F;&#x2F;@Value：注入简单类型（无需提供set方法）\n    @Value(&quot;Hello World&quot;)\n    private String name;\n\n    public void save() &#123;\n        System.out.println(&quot;book dao save ...&quot; + name);\n    &#125;\n&#125;\n\n\n加载properties文件\n使用@PropertySource注解加载properties文件\n\n@Configuration\n@ComponentScan(&quot;com.itheima&quot;)\n@PropertySource(&quot;classpath:jdbc.properties&quot;)\npublic class SpringConfig&#123;\n&#125;\n\n\n注意：路径仅支持单一文件配置，多文件请使用数组格式配置，不允许使用通配符*\n\n第三方bean第三方bean管理\n使用@bean配置第三方bean\n\n@Configuration\npublic class SpringConfig &#123;\n\n    @Bean\n    public DataSource dataSource()&#123;\n        DruidDataSource ds &#x3D; new DruidDataSource();\n        ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);\n      \tds.setUrl(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;spring_db&quot;);\n        ds.setUsername(&quot;root&quot;);\n        ds.setPassword(&quot;1234&quot;);\n        return ds;\n    &#125;\n&#125;\n\n\n\n建议使用方式一，因为方式二看不出你用过哪些配置类\n第三方bean依赖注入\n简单类型依赖注入\n\npublic class JdbcConfig &#123;\n    &#x2F;&#x2F;1.定义一个方法获得要管理的对象\n    @Value(&quot;com.mysql.jdbc.Driver&quot;)\n    private String driver;\n    @Value(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;spring_db&quot;)\n    private String url;\n    @Value(&quot;root&quot;)\n    private String userName;\n    @Value(&quot;root&quot;)\n    private String password;\n    &#x2F;&#x2F;2.添加@Bean，表示当前方法的返回值是一个bean\n    &#x2F;&#x2F;@Bean修饰的方法，形参根据类型自动装配\n    @Bean\n    public DataSource dataSource(BookDao bookDao)&#123;\n        System.out.println(bookDao);\n        DruidDataSource ds &#x3D; new DruidDataSource();\n        ds.setDriverClassName(driver);\n        ds.setUrl(url);\n        ds.setUsername(userName);\n        ds.setPassword(password);\n        return ds;\n    &#125;\n&#125;\n\n\n引用类型依赖注入\n\n@Bean\n   public DataSource dataSource(BookDao bookDao)&#123;\n       System.out.println(bookDao);\n       DruidDataSource ds &#x3D; new DruidDataSource();\n       ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);\n       ds.setUrl(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;spring_db&quot;);\n       ds.setUsername(&quot;root&quot;);\n       ds.setPassword(&quot;1234&quot;);\n       return ds;\n   &#125;\n\n引用类型注入只需要为bean定义方法设置形参即可，容器会根据类型自动装配对象\n注解开发总结XML配置对比注解配置\nSpring整合mybatis\n![](https://raw.githubusercontent.com/2295237514/image/main/20220802102956.png\n\nSpring应该管理的bean是SqlsessionFactory\n\n\nSpring整合junit&#x2F;&#x2F;设置类运行器\n@RunWith(SpringJUnit4ClassRunner.class)\n&#x2F;&#x2F;设置Spring环境对应的配置类\n@ContextConfiguration(classes &#x3D; SpringConfig.class)\npublic class AccountServiceTest &#123;\n    &#x2F;&#x2F;支持自动装配注入bean\n    @Autowired\n    private AccountService accountService;\n    @Test\n    public void testFindById()&#123;\n        System.out.println(accountService.findById(1));\n\n    &#125;\n&#125;\n\nAOP\nAOP(Aspect Oriented Programming)面向切面编程，一种编程范式，指导开发者如何组织程序结构\n\nOOP（Object Oriented Programming）面向对象编程\n\n\n作用：在不惊动原始设计的基础上为其进行功能增强\n\nSpring理念：无入侵式&#x2F;无侵入式\n\n\nAOP核心概念\n连接点(JoinPoint):程序执行过程中的任意位置，粒度为执行方法、抛出异常、设置变量等\n在SpringAop中，理解为方法的执行\n\n\n切入点（Pointcut）：匹配连接点的式子\n在SpringAOP中，一个切入点可以只描述一个具体方法，也可以匹配多个方法\n一个具体方法\n匹配多个方法：所有的save方法，所有的get开头的方法，所有以D奥结尾的接口中的任意方法，所有带有一个参数的方法\n\n\n\n\n通知（Advice）：在切入点处执行的操作，也就是共性功能\n在SpringAOP中，功能最终以方法的形式呈现\n\n\n通知类：定义通知的类\n切面(Aspect)：描述通知与切入点的对应关系\n目标对象（Target）：原始功能去掉共性功能对应的类产生的对象，这种对象是无法完成最终工作的\n代理（Proxy）：目标对象无法直接完成工作，需要对其进行功能回填，通过原始对象的代理对象实现\n\nAOP入门案例思路分析开发模式：XML 或 注解\n思路分析：\n1.导入坐标（pom.xml）\n2.制作连接点方法（原始操作，Dao接口与实现类）\n3.制作共性功能（通知类与通知）\n4.定义切入点\n5.绑定切入点与通知关系（切面）\n步骤1.导入aop相关坐标\n&lt;dependency&gt;\n      &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt;\n      &lt;artifactId&gt;aspectjweaver&lt;&#x2F;artifactId&gt;\n      &lt;version&gt;1.9.4&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n\n2.定义dao接口与实现类\npublic interface BookDao &#123;\n    public void save();\n    public void update();\n&#125;\n\n@Repository\npublic class BookDaoImpl implements BookDao &#123;\n\n    public void save() &#123;\n        System.out.println(System.currentTimeMillis());\n        System.out.println(&quot;book dao save ...&quot;);\n    &#125;\n\n    public void update()&#123;\n        System.out.println(&quot;book dao update ...&quot;);\n    &#125;\n&#125;\n\n3.定义通知类和切入点\n说明：切入点定义依托一个不具有实际意义的方法进行，即无参数，无返回值，方法体无实际逻辑,\n4.最后绑定切入点与通知关系，并指定通知添加到原始连接点的具体执行位置\n5.定义通知类受Spring容器管理，并定义当前类为切面类\n@Component\n&#x2F;&#x2F;设置当前类为切面类类\n@Aspect\npublic class MyAdvice &#123;\n    &#x2F;&#x2F;设置切入点，要求配置在方法上方\n    @Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)\n    private void pt()&#123;&#125;\n\n    &#x2F;&#x2F;设置在切入点pt()的前面运行当前操作（前置通知）\n    &#x2F;&#x2F; @Before(&quot;pt()&quot;)\n    public void method()&#123;\n        System.out.println(System.currentTimeMillis());\n    &#125;\n&#125;\n\n6.开启Spring对AOP注解驱动支持\n@Configuration\n@ComponentScan(&quot;com.itheima&quot;)\n&#x2F;&#x2F;开启注解开发AOP功能\n@EnableAspectJAutoProxy\npublic class SpringConfig &#123;\n&#125;\n\nAOP工作流程1.Spring容器启动\n2.读取所有切面配置中的切入点\n3.初始化bean，判定bean对应的类中的方法是否匹配到任意切入点\n\n匹配失败，创建对象\n匹配成功，创建原始对象(目标对象)的代理对象\n\n4.获取bean执行方法\n\n获取bean，调用方法并执行，完成操作\n获取的bean是代理对象时，根据代理对象的运行模式运行原始方法与增强的内容，完成操作\n\nAOP切入点表达式\n切入点：要进行增强的方法\n切入点表达式：要进行增强的方法的描述方法\n\n\n\n切入点表达式标准格式：动作关键字(访问修饰符 返回值 包名.类&#x2F;接口名.方法名(参数)异常名)\n\nexecution(public User com.itheima.service.UserService.findById(int))\n\n\n动作关键字：描述切入点的行为动作，例如execution表示执行到指定切入点\n访问修饰符：public，private等，可以省略\n返回值\n包名\n类&#x2F;接口名\n方法名\n参数\n异常名：方法定义中抛出指定异常，可以省略\n\n\n*****：必有最少一个\n..:可以没有，也可以有任意个\n书写技巧\n所有代码按照规范标准开发，否则以下技巧全部失效\n\n描述切入点通常描述接口，而不描述实现类\n\n访问控制修饰符针对接口开发均采用public描述(可省略访问控制修饰符描述)\n\n返回值类型对于增删改类使用精准类型加速匹配，对于查询类使用*通配快速描述\n\n包名书写尽量不使用**..*匹配，效率过低，常用做单个包描述匹配，或精准匹配\n\n接口名&#x2F;类型书写名称与模块相关的采用*匹配，例如UserService书写成*Service，绑定业务层接口\n\n方法名书写以动词进行精准匹配，名次采用*匹配，例如getById书写成getBy*\n\n参数规则较为复杂，根据业务方法灵活调整\n\n通常不适用异常作为匹配规则\n\n\nAOP通知类型\nAOP通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置\n\nAOP通知共分为5种类型\n\n前置通知 @Before\n后置通知 @After\n环绕通知（重点） @Around\n\n\n\n返回后通知（了解）@AfterReturning\n抛出异常后通知（了解）@AfterThrowing\n\n\n\n案例：测量业务层接口执行效率@Component\n@Aspect\npublic class ProjectAdvice &#123;\n    &#x2F;&#x2F;匹配业务层的所有方法\n    @Pointcut(&quot;execution(* com.itheima.service.*Service.*(..))&quot;)\n    private void servicePt()&#123;&#125;\n\n    &#x2F;&#x2F;设置环绕通知，在原始操作的运行前后记录执行时间\n    @Around(&quot;ProjectAdvice.servicePt()&quot;)\n    public void runSpeed(ProceedingJoinPoint pjp) throws Throwable &#123;\n        &#x2F;&#x2F;获取执行的签名对象\n        Signature signature &#x3D; pjp.getSignature();\n        String className &#x3D; signature.getDeclaringTypeName();\n        String methodName &#x3D; signature.getName();\n\n        long start &#x3D; System.currentTimeMillis();\n        for (int i &#x3D; 0; i &lt; 10000; i++) &#123;\n           pjp.proceed();\n        &#125;\n        long end &#x3D; System.currentTimeMillis();\n        System.out.println(&quot;万次执行：&quot;+ className+&quot;.&quot;+methodName+&quot;----&gt;&quot; +(end-start) + &quot;ms&quot;);\n    &#125;\n&#125;\n\nAOP通知获取数据\n获取切入点方法的参数、\nJoinPoint：适用于前置、后置、返回后、抛出异常后通知\nProceedJoinPoint：适用于环绕通知\n\n\n\n获取切入点方法返回值\n返回后通知\n环绕通知\n\n\n\n获取切入点方法运行异常信息\n抛出异常后通知\n环绕通知\n\n\n\n\nAOP总结\n概念：AOP面向切面编程，一种编程范式\n\n作用：在不惊动原始设计的基础上为方法进行功能增强\n\n核心概念：\n\n代理：SpringAOP的核心本质是采用代理模式实现的\n\n连接点：在SpringAOP中，理解为任意方法的执行\n\n切入点：匹配连接点的式子，也是具有共性功能的方法描述\n\n切入点表达式标准格式：动作关键字（访问修饰符  返回值  包名.类&#x2F;接口名.方法名（参数）异常名）\n\nexecution(* com.itheima.service.*Service.*(..))\n\n\n切入点表达式描述通配符：\n\n作用：用于快速描述，范围描述\n*：匹配任意符号（常用）\n..：匹配多个连续的任意符号(常用)\n+：匹配子类类型\n\n\n切入点表达式书写技巧\n1.按标准规范开发\n2.查询操作的返回值建议使用*匹配\n3.减少使用..的形式描述包\n4.对接口进行描述，使用*表示模块名，例如UserService的匹配描述为*Service\n5.方法名书写保留动词，例如get,使用*表示名词，例如getById匹配描述为*getBy*\n6.参数根据实际情况灵活调整\n\n\n\n通知：若干个方法的共性功能，在切入点处执行，具体体现为一个方法\n\n环绕通知：\n环绕通知依赖形参ProceedingJoinPoint才能实现对原始方法的调用\n环绕通知可以隔离原始方法的调用执行\n环绕通知返回值设置为Object类型\n环绕通知中可以对原始方法调用过程中出现的异常进行处理\n\n\n\n\n切面：描述通知与切入点的对应关系\n\n目标对象：被代理的原始对象称为目标对象\n\n\n\n\n事务\nSpirng事务作用：在数据层或业务层保障一系列的数据库操作同成功同失败\n\n案例：银行账户转账1.在业务层接口上添加Spring事务管理\npublic interface AccountService&#123;\n\t@Transactional\n\tpublic void transfer(String out,String in,Double money);\n&#125;\n\n注意事项\n\nSpring注解式事务通常添加在业务层接口中而不会添加到业务层实现类中，降低耦合\n\n注解式事务可以添加到业务方法上表示当前方法开启事务，也可以添加到接口上表示当前接口所有方法开启事务\n\n\n2.设置事务管理器\n@Bean\npublic PlatformTransactionManager transactionManager(DataSource dataSource)&#123;\n\tDataSourceTransactionManager ptm &#x3D; new DataSourceTransactionManager();\n\tptm.setDataSource(dataSource);\n    return ptm;\n&#125;\n\n注意事项\n\n事务管理器要根据实现技术进行选择\n\nMyBatis框架使用的是JDBC事务\n\n\n3.开启注解式事务驱动\n@Configuration\n@ComponentScan(&quot;com.itheima&quot;)\n@PropertySource(&quot;classpath:jdbc.properties&quot;)\n@Import(&#123;JdbcConfig.class,MybatisConfig.class&#125;)\n&#x2F;&#x2F;开启注解式事务驱动\n@EnableTransactionManagement\npublic class SpringConfig &#123;\n&#125;\n\nSpring事务角色\n事务管理员：发起事务方，在Spring中通常指代业务层开启事务的方法\n事务协调员：加入事务方，在Spring中通常代指数据层方法，也可以是业务层方法\n\n事务相关配置\n有些异常默认事务不回滚，如IOEXCEPTION需手动设置\troolbackFor属性\n案例：转账业务追加日志1.在业务层接口上添加Spring事务，设置事务传播行为REQUIRES_NEW(需要新事物)\n@Service\npublic class LogServiceImpl implements LogService &#123;\n\n    @Autowired\n    private LogDao logDao;\n\t\n    @Transactional(propagation &#x3D; Propagation.REQUIRES_NEW)\n    public void log(String out,String in,Double money ) &#123;\n        logDao.log(&quot;转账操作由&quot;+out+&quot;到&quot;+in+&quot;,金额：&quot;+money);\n    &#125;\n&#125;\n\n事务传播行为\nSpringMVC\nSpringMVC技术与Servlet技术功能等同，均属于web层开发技术\nSpringMVC是一种基于java实现MVC模型的轻量级Web框架\n优点\n使用简单，开发便捷（相比于Servlet）\n灵活性强\n\n\n\n学习目标：\n1.掌握基于SpringMVC获取请求参数与响应json数据操作\n2.熟练应用基于REST风格的请求路径设置与参数传递\n3.能够根据实际业务简历前后端开发通讯协议并进行实现\n4.基于SSM整合技术开发任意业务模块功能\nSpringMVC入门案例1.使用SpringMVC技术需要先导入SpringMVC坐标与Servlet坐标\n&lt;dependency&gt;\n      &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;\n      &lt;artifactId&gt;javax.servlet-api&lt;&#x2F;artifactId&gt;\n      &lt;version&gt;3.1.0&lt;&#x2F;version&gt;\n      &lt;scope&gt;provided&lt;&#x2F;scope&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n      &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n      &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;\n      &lt;version&gt;5.2.10.RELEASE&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n2.创建SpringMVC控制器类（等同于Servlet功能）\n@Controller\npublic class UserController &#123;\n\n    @RequestMapping(&quot;&#x2F;save&quot;)\n    @ResponseBody\n    public String save()&#123;\n        System.out.println(&quot;user save ...&quot;);\n        return &quot;&#123;&#39;info&#39;:&#39;springmvc&#39;&#125;&quot;;\n    &#125;\n&#125;\n\n3.初始化SpringMVC环境（同Spring环境），设定SpringMVC加载对应的bean\n@Configuration\n@ComponentScan(&quot;com.itheima.controller&quot;)\npublic class SpringMvcConfig&#123;\n\n&#125;\n\n\n知识点1：@Controller\n\n\n\n\n名称\n@Controller\n\n\n\n类型\n类注解\n\n\n位置\nSpringMVC控制器类定义上方\n\n\n作用\n设定SpringMVC的核心控制器bean\n\n\n\n知识点2：@RequestMapping\n\n\n\n\n名称\n@RequestMapping\n\n\n\n类型\n类注解或方法注解\n\n\n位置\nSpringMVC控制器类或方法定义上方\n\n\n作用\n设置当前控制器方法请求访问路径\n\n\n相关属性\nvalue(默认)，请求访问路径\n\n\n\n知识点3：@ResponseBody\n\n\n\n\n名称\n@ResponseBody\n\n\n\n类型\n类注解或方法注解\n\n\n位置\nSpringMVC控制器类或方法定义上方\n\n\n作用\n设置当前控制器方法响应内容为当前返回值，无需解析\n\n\n注意事项\n\nSpringMVC是基于Spring的，在pom.xml只导入了spring-webmvcjar包的原因是它会自动依赖spring相关坐标\nAbstractDispatcherServletInitializer类是SpringMVC提供的快速初始化Web3.0容器的抽象类\nAbstractDispatcherServletInitializer提供了三个接口方法供用户实现\ncreateServletApplicationContext方法，创建Servlet容器时，加载SpringMVC对应的bean并放入WebApplicationContext对象范围中，而WebApplicationContext的作用范围为ServletContext范围，即整个web容器范围\ngetServletMappings方法，设定SpringMVC对应的请求映射路径，即SpringMVC拦截哪些请求\ncreateRootApplicationContext方法，如果创建Servlet容器时需要加载非SpringMVC对应的bean,使用当前方法进行，使用方式和createServletApplicationContext相同。\ncreateServletApplicationContext用来加载SpringMVC环境\ncreateRootApplicationContext用来加载Spring环境\n\n\n\n入门案例工作流程分析\n启动服务器初始化过程\n1.服务器启动，执行ServletContainerInitConfig类，初始化web容器\n2.执行createServletApplicationContext方法，创建了WebApplicationContext对象\n3.加载SpringMvcConfig\n4.执行@ComponentScan加载对应的bean\n5.加载UserController，每个@RequestMapping的名称对应一个具体的方法\n6.执行getServletMappings方法，定义所有的请求都通过SpringMVC\n\n单次请求过程\n1.发送请求localhost&#x2F;save\n2.web容器发现所有请求都经过SpringMVC，将请求交给SpringMVC处理\n3.解析请求路径&#x2F;save\n4.由&#x2F;save匹配执行对应的方法save()\n5.执行save()\n6.检测到有@ResponseBody直接将save()方法的返回值作为响应体返回给请求方\n\n\nbean加载控制\n方式一:修改Spring配置类，设定扫描范围为精准范围。\n@Configuration\n@ComponentScan(&#123;&quot;com.itheima.service&quot;,&quot;comitheima.dao&quot;&#125;)\npublic class SpringConfig &#123;\n&#125;\n\n方式二:修改Spring配置类，设定扫描范围为com.itheima,排除掉controller包中的bean\n@Configuration\n@ComponentScan(value&#x3D;&quot;com.itheima&quot;,\n    excludeFilters&#x3D;@ComponentScan.Filter(\n    \ttype &#x3D; FilterType.ANNOTATION,\n        classes &#x3D; Controller.class\n    )\n)\npublic class SpringConfig &#123;\n&#125;\n\n\nexcludeFilters属性：设置扫描加载bean时，排除的过滤规则\n\n\nbean的加载格式：\npublic class ServletContainersInitConfig extends AbstractDispatcherServletInitializer &#123;\n    protected WebApplicationContext createServletApplicationContext() &#123;\n        AnnotationConfigWebApplicationContext ctx &#x3D; new AnnotationConfigWebApplicationContext();\n        ctx.register(SpringMvcConfig.class);\n        return ctx;\n    &#125;\n    protected String[] getServletMappings() &#123;\n        return new String[]&#123;&quot;&#x2F;&quot;&#125;;\n    &#125;\n    protected WebApplicationContext createRootApplicationContext() &#123;\n      AnnotationConfigWebApplicationContext ctx &#x3D; new AnnotationConfigWebApplicationContext();\n        ctx.register(SpringConfig.class);\n        return ctx;\n    &#125;\n&#125;\n\n对于上述的配置方式，Spring还提供了一种更简单的配置方式，可以不用再去创建AnnotationConfigWebApplicationContext对象，不用手动register对应的配置类，如何实现?\n简化开发的格式\npublic class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123;\n\n    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;\n        return new Class[]&#123;SpringConfig.class&#125;;\n    &#125;\n\n    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;\n        return new Class[]&#123;SpringMvcConfig.class&#125;;\n    &#125;\n\n    protected String[] getServletMappings() &#123;\n        return new String[]&#123;&quot;&#x2F;&quot;&#125;;\n    &#125;\n&#125;\n\n请求与响应请求映射路径优化映射路径\n@Controller\n@RequestMapping(&quot;&#x2F;user&quot;)\npublic class UserController &#123;\n\n    @RequestMapping(&quot;&#x2F;save&quot;)\n    @ResponseBody\n    public String save()&#123;\n        System.out.println(&quot;user save ...&quot;);\n        return &quot;&#123;&#39;module&#39;:&#39;user save&#39;&#125;&quot;;\n    &#125;\n    \n    @RequestMapping(&quot;&#x2F;delete&quot;)\n    @ResponseBody\n    public String save()&#123;\n        System.out.println(&quot;user delete ...&quot;);\n        return &quot;&#123;&#39;module&#39;:&#39;user delete&#39;&#125;&quot;;\n    &#125;\n&#125;\n\n@Controller\n@RequestMapping(&quot;&#x2F;book&quot;)\npublic class BookController &#123;\n\n    @RequestMapping(&quot;&#x2F;save&quot;)\n    @ResponseBody\n    public String save()&#123;\n        System.out.println(&quot;book save ...&quot;);\n        return &quot;&#123;&#39;module&#39;:&#39;book save&#39;&#125;&quot;;\n    &#125;\n&#125;\n\n注意:\n\n当类上和方法上都添加了@RequestMapping注解，前端发送请求的时候，要和两个注解的value值相加匹配才能访问到。\n@RequestMapping注解value属性前面加不加/都可以\n\n请求参数\nGet请求\nPost请求\n\n\n\nPost请求中文乱码处理\n\n为web容器添加过滤器并指定字符集，Spring-web包中提供了专用的字符过滤器\n\n解决方法：配置过滤器\npublic class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123;\n    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;\n        return new Class[0];\n    &#125;\n\n    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;\n        return new Class[]&#123;SpringMvcConfig.class&#125;;\n    &#125;\n\n    protected String[] getServletMappings() &#123;\n        return new String[]&#123;&quot;&#x2F;&quot;&#125;;\n    &#125;\n\n    &#x2F;&#x2F;乱码处理\n    @Override\n    protected Filter[] getServletFilters() &#123;\n        CharacterEncodingFilter filter &#x3D; new CharacterEncodingFilter();\n        filter.setEncoding(&quot;UTF-8&quot;);\n        return new Filter[]&#123;filter&#125;;\n    &#125;\n&#125;\n\n\n发送请求与参数:\nhttp:&#x2F;&#x2F;localhost&#x2F;commonParamDifferentName?name&#x3D;张三&amp;age&#x3D;18\n\n后台接收参数:\n@RequestMapping(&quot;&#x2F;commonParamDifferentName&quot;)\n@ResponseBody\npublic String commonParamDifferentName(String userName , int age)&#123;\n    System.out.println(&quot;普通参数传递 userName &#x3D;&#x3D;&gt; &quot;+userName);\n    System.out.println(&quot;普通参数传递 age &#x3D;&#x3D;&gt; &quot;+age);\n    return &quot;&#123;&#39;module&#39;:&#39;common param different name&#39;&#125;&quot;;\n&#125;\n\n因为前端给的是name,后台接收使用的是userName,两个名称对不上，导致接收数据失败:\n解决方案:使用@RequestParam注解\n@RequestMapping(&quot;&#x2F;commonParamDifferentName&quot;)\n    @ResponseBody\n    public String commonParamDifferentName(@RequestPaam(&quot;name&quot;) String userName , int age)&#123;\n        System.out.println(&quot;普通参数传递 userName &#x3D;&#x3D;&gt; &quot;+userName);\n        System.out.println(&quot;普通参数传递 age &#x3D;&#x3D;&gt; &quot;+age);\n        return &quot;&#123;&#39;module&#39;:&#39;common param different name&#39;&#125;&quot;;\n    &#125;\n\n用集合接收前台参数也需要@RequestParam注解\n\n日期类型参数传递\n类型转换器\njson数据接受请求中json数据1.添加json数据转换相关坐标\n&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;jackson-databind&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.9.0&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n2.设置发送json数据(请求body中添加json数据)\n\n3.开启自动转换json数据的支持\n\n4.设置接收json数据\n&#x2F;&#x2F;使用@RequestBody注解将外部传递的json数组数据映射到形参的集合对象中作为数据\n    @RequestMapping(&quot;&#x2F;listParamForJson&quot;)\n    @ResponseBody\n    public String listParamForJson(@RequestBody List&lt;String&gt; likes)&#123;\n        System.out.println(&quot;list common(json)参数传递 list &#x3D;&#x3D;&gt; &quot;+likes);\n        return &quot;&#123;&#39;module&#39;:&#39;list common for json param&#39;&#125;&quot;;\n    &#125;\n\n@RequestBody一个处理器方法只能使用一次\n\n@RequestBody与@RequestParam区别\n\n区别\n@RequestParam用于接收url地址传参，表单传参\n@RequestBody用于接收json数据\n\n\n应用\n后期开发中，发送json格式数据为主，@RequestBody应用较广\n如果发送非json格式数据，选用@RequestParam接收请求参数\n\n\n\n\n\n\n名称\n@ResponseBody\n\n\n\n类型\n&#x3D;&#x3D;方法\\类注解&#x3D;&#x3D;\n\n\n位置\nSpringMVC控制器方法定义上方和控制类上\n\n\n作用\n设置当前控制器返回值作为响应体,写在类上，该类的所有方法都有该注解功能\n\n\n相关属性\npattern：指定日期时间格式字符串\n\n\n说明:\n\n该注解可以写在类上或者方法上\n写在类上就是该类下的所有方法都有@ReponseBody功能\n当方法上有@ReponseBody注解后\n方法的返回值为字符串，会将其作为文本内容直接响应给前端\n方法的返回值为对象，会将对象转换成JSON响应给前端\n\n\n\n此处又使用到了类型转换，内部还是通过Converter接口的实现类完成的，所以Converter除了前面所说的功能外，它还可以实现:\n\n对象转Json数据(POJO -&gt; json)\n集合转Json数据(Collection -&gt; json)\n\nRest简介\nREST（Representational State Transfer），表现形式状态转换\n\n当我们想表示一个网络资源的时候，可以使用两种方式:\n\n传统风格资源描述形式\nhttp://localhost/user/getById?id=1 查询id为1的用户信息\nhttp://localhost/user/saveUser 保存用户信息\n\n\nREST风格描述形式\nhttp://localhost/user/1 \nhttp://localhost/user\n\n\n\n\n优点：\n隐藏资源的访问行为，无法通过地址得知对资源是何种操作\n书写简化\n\n\n\n\n\n按照REST风格访问资源时使用&#x3D;&#x3D;行为动作&#x3D;&#x3D;区分对资源进行了何种操作\nhttp://localhost/users\t查询全部用户信息 GET（查询）\nhttp://localhost/users/1  查询指定用户信息 GET（查询）\nhttp://localhost/users    添加用户信息    POST（新增&#x2F;保存）\nhttp://localhost/users    修改用户信息    PUT（修改&#x2F;更新）\nhttp://localhost/users/1  删除用户信息    DELETE（删除）\n\n\n根据REST风格对资源进行访问称为RESTful\n\n请求的方式比较多，但是比较常用的就4种，分别是GET,POST,PUT,DELETE。\n按照不同的请求方式代表不同的操作类型。\n\n发送GET请求是用来做查询\n发送POST请求是用来做新增\n发送PUT请求是用来做修改\n发送DELETE请求是用来做删除\n\n注意事项：\n上述行为是约定方式，约定不是规范，可以打破，所以称REST风格，而不是REST规范\n描述模块的名字通常使用负数，也就是可以加s的格式描述，表示此类资源，而非单个资源，例如：users、books、account......\n\n入门案例\n(2)如果有多个参数需要传递该如何编写?\n前端发送请求的时候使用:http://localhost/users/1/tom,路径中的1和tom就是我们想要传递的两个参数。\n后端获取参数，需要做如下修改:\n@Controller\npublic class UserController &#123;\n    &#x2F;&#x2F;设置当前请求方法为DELETE，表示REST风格中的删除操作\n\t@RequestMapping(value &#x3D; &quot;&#x2F;users&#x2F;&#123;id&#125;&#x2F;&#123;name&#125;&quot;,method &#x3D; RequestMethod.DELETE)\n    @ResponseBody\n    public String delete(@PathVariable Integer id,@PathVariable String name) &#123;\n        System.out.println(&quot;user delete...&quot; + id+&quot;,&quot;+name);\n        return &quot;&#123;&#39;module&#39;:&#39;user delete&#39;&#125;&quot;;\n    &#125;\n&#125;\n\n\n关于接收参数，我们学过三个注解@RequestBody、@RequestParam、@PathVariable,这三个注解之间的区别和应用分别是什么?\n\n区别\n@RequestParam用于接收url地址传参或表单传参\n@RequestBody用于接收json数据\n@PathVariable用于接收路径参数，使用{参数名称}描述路径参数\n\n\n应用\n后期开发中，发送请求参数超过1个时，以json格式为主，@RequestBody应用较广\n如果发送非json格式数据，选用@RequestParam接收请求参数\n采用RESTful进行开发，当参数数量较少时，例如1个，可以采用@PathVariable接收请求路径变量，通常用于传递id值\n\n\n\nRESTful快速开发问题1：每个方法的@RequestMapping注解中都定义了访问路径&#x2F;books，重复性太高。\n问题2：每个方法的@RequestMapping注解中都要使用method属性定义请求方式，重复性太高。\n问题3：每个方法响应json都需要加上@ResponseBody注解，重复性太高。\n对于刚才的问题，我们都有对应的解决方案：\n问题1：每个方法的@RequestMapping注解中都定义了访问路径&#x2F;books，重复性太高。\n将@RequestMapping提到类上面，用来定义所有方法共同的访问路径。\n\n问题2：每个方法的@RequestMapping注解中都要使用method属性定义请求方式，重复性太高。\n使用@GetMapping  @PostMapping  @PutMapping  @DeleteMapping代替\n\n问题3：每个方法响应json都需要加上@ResponseBody注解，重复性太高。\n1.将ResponseBody提到类上面，让所有的方法都有@ResponseBody的功能\n2.使用@RestController注解替换@Controller与@ResponseBody注解，简化书写\n\n知识点1：@RestController\n\n\n名称\n@RestController\n\n\n\n类型\n&#x3D;&#x3D;类注解&#x3D;&#x3D;\n\n\n位置\n基于SpringMVC的RESTful开发控制器类定义上方\n\n\n作用\n设置当前控制器类为RESTful风格，等同于@Controller与@ResponseBody两个注解组合功能\n\n\n知识点2：@GetMapping @PostMapping @PutMapping @DeleteMapping\n\n\n名称\n@GetMapping @PostMapping @PutMapping @DeleteMapping\n\n\n\n类型\n&#x3D;&#x3D;方法注解&#x3D;&#x3D;\n\n\n位置\n基于SpringMVC的RESTful开发控制器方法定义上方\n\n\n作用\n设置当前控制器方法请求访问路径与请求动作，每种对应一个请求动作，例如@GetMapping对应GET请求\n\n\n相关属性\nvalue（默认）：请求访问路径\n\n\n案例：基于RESTful页面数据交互编写Controller类并使用RESTful进行配置@RestController\n@RequestMapping(&quot;&#x2F;books&quot;)\npublic class BookController &#123;\n\n    @PostMapping\n    public String save(@RequestBody Book book)&#123;\n        System.out.println(&quot;book save &#x3D;&#x3D;&gt; &quot;+ book);\n        return &quot;&#123;&#39;module&#39;:&#39;book save success&#39;&#125;&quot;;\n    &#125;\n\n \t@GetMapping\n    public List&lt;Book&gt; getAll()&#123;\n        System.out.println(&quot;book getAll is running ...&quot;);\n        List&lt;Book&gt; bookList &#x3D; new ArrayList&lt;Book&gt;();\n\n        Book book1 &#x3D; new Book();\n        book1.setType(&quot;计算机&quot;);\n        book1.setName(&quot;SpringMVC入门教程&quot;);\n        book1.setDescription(&quot;小试牛刀&quot;);\n        bookList.add(book1);\n\n        Book book2 &#x3D; new Book();\n        book2.setType(&quot;计算机&quot;);\n        book2.setName(&quot;SpringMVC实战教程&quot;);\n        book2.setDescription(&quot;一代宗师&quot;);\n        bookList.add(book2);\n\n\n        return bookList;\n    &#125;\n\n&#125;\n\n\nSpringMVC需要将静态资源进行放行。\n\n@Configuration\npublic class SpringMvcSupport extends WebMvcConfigurationSupport &#123;\n    &#x2F;&#x2F;设置静态资源访问过滤，当前类需要设置为配置类，并被扫描加载\n    @Override\n    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;\n        &#x2F;&#x2F;当访问&#x2F;pages&#x2F;????时候，从&#x2F;pages目录下查找内容\n        registry.addResourceHandler(&quot;&#x2F;pages&#x2F;**&quot;).addResourceLocations(&quot;&#x2F;pages&#x2F;&quot;);\n        registry.addResourceHandler(&quot;&#x2F;js&#x2F;**&quot;).addResourceLocations(&quot;&#x2F;js&#x2F;&quot;);\n        registry.addResourceHandler(&quot;&#x2F;css&#x2F;**&quot;).addResourceLocations(&quot;&#x2F;css&#x2F;&quot;);\n        registry.addResourceHandler(&quot;&#x2F;plugins&#x2F;**&quot;).addResourceLocations(&quot;&#x2F;plugins&#x2F;&quot;);\n    &#125;\n&#125;\n\n\n\n该配置类是在config目录下，SpringMVC扫描的是controller包，所以该配置类还未生效，要想生效需要将SpringMvcConfig配置类进行修改\n\n@Configuration\n@ComponentScan(&#123;&quot;com.itheima.controller&quot;,&quot;com.itheima.config&quot;&#125;)\n@EnableWebMvc\npublic class SpringMvcConfig &#123;\n&#125;\n\n或者\n\n@Configuration\n@ComponentScan(&quot;com.itheima&quot;)\n@EnableWebMvc\npublic class SpringMvcConfig &#123;\n&#125;\n\nSSM整合1.创建工程\n2.SSM整合\n\nSpring\n\nSpringConfig\n\n\nMyBatis\n\nMybatisConfig\n\nJdbcConfig\n\njdbc.properties\n\n\n\nSpringMVC\n\nServletConfig\nSpirngMvcConfig\n\n\n\n3.功能模块\n\n表与实现类\ndao(接口+自动代理)\nservice(接口+实现类)\n业务层接口测试(整合JUnit)\n\n\ncontroller\n表现层接口测试(PostMan)\n\n\n\n\n\n\n\n异常处理器\n出现异常现象的常见位置与常见诱因如下：\n\n框架内部抛出的异常：因使用不合规导致\n数据层抛出的异常：因外部服务器故障导致（例如：服务器访问超时）\n业务层抛出的异常：因业务逻辑书写失败导致（例如：遍历业务书写操作，导致索引异常等）\n表现层抛出的异常：因数据收集、校验等规则导致（例如：不匹配的数据类型间导致异常）\n工具类抛出的异常：因工具类书写不严谨不够健壮导致（例如：必要释放的连接长期未释放导致等）\n\n\n所有异常均抛出到表现层处理\n\n对于上面这些问题及解决方案，SpringMVC已经为我们提供了一套解决方案:\n\n对于上面这些问题及解决方案，SpringMVC已经为我们提供了一套解决方案:\n\n异常处理器:\n集中的、统一的处理项目中出现的异常。\n\n\n\n@RestControllerAdvice\npublic class ProjectExceptionAdvice &#123;\n    @ExceptionHandler(Exception.class)\n    public void doException(Exception ex)&#123;\n        System.out.println(&quot;出现异常了&quot;);\n    &#125;\n&#125;\n\n\n\n知识点1：@RestControllerAdvice\n\n\n\n名称\n@RestControllerAdvice\n\n\n\n类型\n&#x3D;&#x3D;类注解&#x3D;&#x3D;\n\n\n位置\nRest风格开发的控制器增强类定义上方\n\n\n作用\n为Rest风格开发的控制器类做增强\n\n\n**说明:**此注解自带@ResponseBody注解与@Component注解，具备对应的功能\n\n知识点2：@ExceptionHandler\n\n\n\n名称\n@ExceptionHandler\n\n\n\n类型\n&#x3D;&#x3D;方法注解&#x3D;&#x3D;\n\n\n位置\n专用于异常处理的控制器方法上方\n\n\n作用\n设置指定异常的处理方案，功能等同于控制器方法，出现异常后终止原始控制器执行,并转入当前方法执行\n\n\n说明：此类方法可以根据处理的异常不同，制作多个方法分别处理对应的异常\n项目异常分类及处理项目异常分类\n\n业务异常（BusinessException）\n\n规范的用户行为产生的异常\n\n用户在页面输入内容的时候未按照指定格式进行数据填写，如在年龄框输入的是字符串\n\n\n不规范的用户行为操作产生的异常\n\n如用户故意传递错误数据\n\n\n\n\n系统异常（SystemException）\n\n项目运行过程中可预计但无法避免的异常\n比如数据库或服务器宕机\n\n\n\n\n其他异常（Exception）\n\n编程人员未预期到的异常，如:用到的文件不存在\n\n\n\n处理方案\n\n业务异常（BusinessException）\n发送对应消息传递给用户，提醒规范操作\n大家常见的就是提示用户名已存在或密码格式不正确等\n\n\n\n\n系统异常（SystemException）\n发送固定消息传递给用户，安抚用户\n系统繁忙，请稍后再试\n系统正在维护升级，请稍后再试\n系统出问题，请联系系统管理员等\n\n\n发送特定消息给运维人员，提醒维护\n可以发送短信、邮箱或者是公司内部通信软件\n\n\n记录日志\n发消息和记录日志对用户来说是不可见的，属于后台程序\n\n\n\n\n其他异常（Exception）\n发送固定消息传递给用户，安抚用户\n发送特定消息给编程人员，提醒维护（纳入预期范围内）\n一般是程序没有考虑全，比如未做非空校验等\n\n\n记录日志\n\n\n\n","slug":"SSM","date":"2022-07-26T08:33:15.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"56c491e94a7396878a3a1e31f971413b","title":"计算机组成原理","content":"第一章1.21.2.1 冯诺依曼计算机的特点：\n计算机有哦运算器，存储器，控制器，输入设备和输出设备五大部件组成\n指令和数据以同等地位存放于存储器中，并可按地址寻访\n指令和数据均用二进制数表示\n指令由操作码和地址码组成，操作码用来表示操作的性质，地址码用来表示操作数在存储器中的位置\n指令在存储器内按顺序存放。通常，指令是顺序执行的，在特定条件下，可根据运算结果或根据设定的条件改变执行顺序\n机器以运算器为中心，输入输出设备与存储期间的数据传送通过运算器完成。\n\n相比于经典的冯诺依曼计算机的最后一个特点，现代的计算机已转化为以存储器为中心\n1.2.2 计算机的硬件框图计算机硬件各部件的功能：\n\n运算器用来完成算术运算和逻辑运算，并将运算的中间结果暂存在运算器内\n存储器用来存放数据和程序\n控制器用来控制，指挥程序和数据的输入，运行以及处理运算结果\n输入设备用来将人们熟悉的信息形式转化为机器能识别的信息形式，常见的有键盘，鼠标等\n输出设备可将机器运算结果转换为人们熟悉的信息形式，如打印机输出，显示器输出等\n\n计算机的五大部件（又称五大子系统）在控制器的统一指挥下，有条不紊的自动工作\n运算器和控制器合起来统称为中央处理器（CPU）\n输入设备与输出设备简称为I&#x2F;O设备\n现代计算机可认为由三大部分组成：CPU，I&#x2F;O设备，主存储器\nCPU和主存储器合起来可称为主机        I&#x2F;O设备又可称为外部设备\n算术逻辑单元（ALU）完成算术逻辑运算\n控制单元（CU）用来结束存储器中的指令，并发出各种操作命令来执行指令\n1.2.3 计算机的工作步骤","slug":"计算机组成原理","date":"2022-07-13T13:29:14.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"2d34257e8e68ae00ecf08b330efedcd5","title":"Web核心","content":"Web概述JavaWeb技术栈\nB&#x2F;S架构：Browser&#x2F;Server，浏览器&#x2F;服务器 架构模式，它的特点是，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web资源，服务器把Web资源发送给浏览器即可\n\n好处：易于维护升级：服务器升级苟，客户端无需任何不输就可以使用到新的版本\n\n\n静态资源：HTML  CSS  JavaScript  图片等。 负责页面展现\n\n动态资源：Servlet  Jsp等。 负责逻辑处理\n\n数据库：负责存储数据\n\n\n\nHTTP\n概念：HyperText  Transfer  Protocol， 超文本传输协议，规定了浏览器和服务器之间数据传输的规则\n\nHTTP协议特点：\n1.基于TCP协议：面向连接，安全\n2.基于请求-响应模型：一次请求对应一次响应\n3.HTTP协议是无状态的协议：对于事务处理没有记忆能力。每次请求-响应都是独立的\n\n缺点：多次请求间不能共享数据       Java中使用会话技术（Cookie、Session）来解决\n有点：速度快\n\n\n\n请求数据格式\n请求数据分为三部分：\n\n1.请求行：请求数据的第一行。其中GET表示请求方式，&#x2F;表示请求资源路径，HTTP&#x2F;1.1表示协议版本\n2.请求头：第二行开始，格式为key：value形式，常见的HTTP请求头有:\nHost: 表示请求的主机名\nUser-Agent: 浏览器版本,例如Chrome浏览器的标识类似Mozilla&#x2F;5.0 ...Chrome&#x2F;79，IE浏览器的标识类似Mozilla&#x2F;5.0 (Windows NT ...)like Gecko；\nAccept：表示浏览器能接收的资源类型，如text&#x2F;*，image&#x2F;*或者*&#x2F;*表示所有；\nAccept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页；\nAccept-Encoding：表示浏览器可以支持的压缩类型，例如gzip, deflate等。\n\n3.请求体：POST请求的最后一部分，存放请求参数\n\n\n响应数据格式\n1.响应行：响应数据的第一行。其中HTTP&#x2F;1.1表示协议版本，200表示响应状态码，OK表示状态码描述\n\n2.响应头：第二行开始，格式为key：value形式，常见的HTTP响应头有:\nContent-Type：表示该响应内容的类型，例如text&#x2F;html，image&#x2F;jpeg；\nContent-Length：表示该响应内容的长度（字节数）；\nContent-Encoding：表示该响应压缩算法，例如gzip；\nCache-Control：指示客户端应如何缓存，例如max-age&#x3D;300表示可以最多缓存300秒\n\n3.响应体：最后一部分。存放相应数据\n\n\n\n一、状态码大类\n\n\n状态码分类\n说明\n\n\n\n1xx\n响应中——临时状态码，表示请求已经接受，告诉客户端应该继续请求或者如果它已经完成则忽略它\n\n\n2xx\n成功——表示请求已经被成功接收，处理已完成\n\n\n3xx\n重定向——重定向到其它地方：它让客户端再发起一个请求以完成整个处理。\n\n\n4xx\n客户端错误——处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等\n\n\n5xx\n服务器端错误——处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等\n\n\n状态码大全：https://cloud.tencent.com/developer/chapter/13553 \n二、常见的响应状态码\n\n\n状态码\n英文描述\n解释\n\n\n\n200\nOK\n客户端请求成功，即处理成功，这是我们最想看到的状态码\n\n\n302\nFound\n指示所请求的资源已移动到由Location响应头给定的 URL，浏览器会自动重新访问到这个页面\n\n\n304\nNot Modified\n告诉客户端，你请求的资源至上次取得后，服务端并未更改，你直接用你本地缓存吧。隐式重定向\n\n\n400\nBad Request\n客户端请求有语法错误，不能被服务器所理解\n\n\n403\nForbidden\n服务器收到请求，但是拒绝提供服务，比如：没有权限访问相关资源\n\n\n404\nNot Found\n请求资源不存在，一般是URL输入有误，或者网站资源被删除了\n\n\n428\nPrecondition Required\n服务器要求有条件的请求，告诉客户端要想访问该资源，必须携带特定的请求头\n\n\n429\nToo Many Requests\n太多请求，可以限制客户端请求某个资源的数量，配合 Retry-After(多长时间后可以请求)响应头一起使用\n\n\n431\n Request Header Fields Too Large\n请求头太大，服务器不愿意处理请求，因为它的头部字段太大。请求可以在减少请求头域的大小后重新提交。\n\n\n405\nMethod Not Allowed\n请求方式有误，比如应该用GET请求方式的资源，用了POST\n\n\n500\nInternal Server Error\n服务器发生不可预期的错误。服务器出异常了，赶紧看日志去吧\n\n\n503\nService Unavailable\n服务器尚未准备好处理请求，服务器刚刚启动，还未初始化好\n\n\n511\nNetwork Authentication Required\n客户端需要进行身份验证才能获得网络访问权限\n\n\nTomcatWeb服务器是一个应用程序（软件），对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作，让开发更加便捷，主要功能是提供网上信息浏览服务 \n作用：\n\n封装HTTP协议操作，简化开发\n可以将web项目部署到服务器中，对外提供网上浏览服务\n\nTomcat是一个轻量级的Web服务器，支持Servlet&#x2F;JSP少量JavaEE规范，也称为Web服务器，Servlet容器\n基本使用\n部署项目\nIDEA中创建Maven Web项目项目结构：\n创建方法1、\n2、\nIDEA集成本地Tomcat\nIDEA中使用Tomcat - Tomcat Maven插件1.pom.xml添加Tomcat插件\n&lt;build&gt;\n    &lt;plugins&gt;\n    \t&lt;!--Tomcat插件 --&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.apache.tomcat.maven&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;tomcat7-maven-plugin&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;2.2&lt;&#x2F;version&gt;\n        &lt;&#x2F;plugin&gt;\n    &lt;&#x2F;plugins&gt;\n&lt;&#x2F;build&gt;\n\n2.使用Maven Helper 插件快速启动项目，选中项目，右键 Run Maven –&gt; tomcat7:run\nServlet\nServlet是java提供的一门动态Web资源开发技术\nServlet是javaEE规范之一，其实就是一个接口，将来我们要定义Servlet类来访问Servlet接口，并由web服务器运行Servlet\n\nServlet快速入门1.创建一个项目，导入Servlet依赖坐标\n&lt;dependency&gt;\n    &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;javax.servlet-api&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;3.1.0&lt;&#x2F;version&gt;\n    &lt;!--\n      此处为什么需要添加该标签?\n      provided指的是在编译和测试过程中有效,最后生成的war包时不会加入\n       因为Tomcat的lib目录中已经有servlet-api这个jar包，如果在生成war包的时候生效就会和Tomcat中的jar包冲突，导致报错\n    --&gt;\n    &lt;scope&gt;provided&lt;&#x2F;scope&gt;\n&lt;&#x2F;dependency&gt;\n\n\n\n2.创建：定义一个类，实现Servlet接口，并重写接口中的所有方法，并在service方法中输入一句话\npackage com.itheima.web;\n\nimport javax.servlet.*;\nimport java.io.IOException;\n\npublic class ServletDemo1 implements Servlet &#123;\n\n    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;\n        System.out.println(&quot;servlet hello world~&quot;);\n    &#125;\n    public void init(ServletConfig servletConfig) throws ServletException &#123;\n\n    &#125;\n\n    public ServletConfig getServletConfig() &#123;\n        return null;\n    &#125;\n\n    public String getServletInfo() &#123;\n        return null;\n    &#125;\n\n    public void destroy() &#123;\n\n    &#125;\n&#125;\n\n\n\n3.配置: 在类上使用@WebServlet注解，配置该Servlet的访问路径\n@WebServlet(&quot;&#x2F;demo1&quot;)\n\n\n\n4.访问:启动Tomcat，浏览器输入URL访问该Servlet\nhttp:&#x2F;&#x2F;localhost:8080&#x2F;web-demo&#x2F;demo1\n\nServlet执行流程Servlet生命周期\n对象的生命周期指一个对象从被创建到被销毁的整个过程\n\nServlet运行在Servlet容器（Web服务器）中，其生命周期由容器来管理，分为4个阶段\n1.加载和实例化：默认情况下，当Servlet第一次被访问时，其容器创建Servlet对象\n\n\n\t\n默认情况，Servlet会在第一次访问被容器创建，但是如果创建Servlet比较耗时的话，\n那么第一个访问的人等待的时间就比较长，用户的体验就比较差，\n那么我们能不能把Servlet的创建放到服务器启动的时候来创建，具体如何来配置?\n\n@WebServlet(urlPatterns &#x3D; &quot;&#x2F;demo1&quot;,loadOnStartup &#x3D; 1)\nloadOnstartup的取值有两类情况\n（1）负整数:第一次访问时创建Servlet对象\n（2）0或正整数:服务器启动时创建Servlet对象，数字越小优先级越高\n\n2.初始化：在Servlet实例化之后，容器将调用Servlet的init()方法来初始化这个对象，完成一些如加载配置文件、创建连接等初始化的工作。该方法只调用一次\n3.请求处理：每次请求Servlet时，Servlet容器都会调用Servlet的service()方法对请求进行处理\n4.服务终止：当需要释放内存或容器关闭时，容器就会调用Servlet实例的destory()方法完成资源的释放。在destory()方法调用之后，容器会释放这个Servlet实例，该实例随后会被java的垃圾收集器所回收\nServlet方法介绍\n初始化方法，在Servlet被创建时执行，只执行一次\n\nvoid init(ServletConfig config) \n\n\n提供服务方法， 每次Servlet被访问，都会调用该方法\n\nvoid service(ServletRequest req, ServletResponse res)\n\n\n销毁方法，当Servlet被销毁时，调用该方法。在内存释放或服务器关闭时销毁Servlet\n\nvoid destroy() \n\n剩下的两个方法是:\n\n获取Servlet信息\n\nString getServletInfo() \n&#x2F;&#x2F;该方法用来返回Servlet的相关信息，没有什么太大的用处，一般我们返回一个空字符串即可\npublic String getServletInfo() &#123;\n    return &quot;&quot;;\n&#125;\n\n\n获取ServletConfig对象\n\nServletConfig getServletConfig()\n\nServlet体系结构\n我们将来开发B&#x2F;S架构的web项目，都是针对HTTP协议，所以我们自定义Servlet，会继承HttpServlet\n\nHttpServlet使用步骤\n\n继承HttpServlet\n重写doGet和doPost方法\n\n\nHttpServlet原理\n获取请求方式，并根据不同的请求方式，调用不同的doXxx方法。\n\n\nServlet urlPattern配置\n优先级：1&gt;2&gt;3&gt;&#x2F;*&gt;&#x2F;\nXML配置Servlet前面对应Servlet的配置，我们都使用的是@WebServlet,这个是Servlet从3.0版本后开始支持注解配置，3.0版本前只支持XML配置文件的配置方法。\n对于XML的配置步骤有两步:\n\n编写Servlet类\n\n在web.xml中配置该Servlet 代码如下：\n&lt;servlet&gt;\n       &lt;!-- servlet的名称，名字任意--&gt;\n       &lt;servlet-name&gt;demo13&lt;&#x2F;servlet-name&gt;\n       &lt;!--servlet的类全名--&gt;\n       &lt;servlet-class&gt;com.itheima.web.ServletDemo13&lt;&#x2F;servlet-class&gt;\n   &lt;&#x2F;servlet&gt;\n  \n   &lt;!-- \n       Servlet 访问路径\n   --&gt;\n   &lt;servlet-mapping&gt;\n       &lt;!-- servlet的名称，要和上面的名称一致--&gt;\n       &lt;servlet-name&gt;demo13&lt;&#x2F;servlet-name&gt;\n       &lt;!-- servlet的访问路径--&gt;\n       &lt;url-pattern&gt;&#x2F;demo13&lt;&#x2F;url-pattern&gt;\n   &lt;&#x2F;servlet-mapping&gt;\n\nRequestRequest继承体系\nRequest获取数据请求参数HTTP请求数据总共分为三部分内容，分别是  请求行、请求头、请求体\nRequest获取请求行数据请求行包含三块内容，分别是请求方式、请求资源路径、HTTP协议及版本\n\n对于这三部分内容，request对象都提供了对应的API方法来获取，具体如下:\n\n获取请求方式GET\n\nString getMethod()\n\n\n获取虚拟目录（项目访问路径）/request-demo\n\nSting getContextPath()\n\n\n获取URL（统一资源定位符）https://localhost:8080/request-demo/req1\n\nStringBuffer getRequestURL()\n\n\n获取URI(统一资源标识符)request-demo/req1\n\nString getRequestURI()\n\n\n获取请求参数(GET方式)username=zhangsan&amp;password=123\n\nSting getQueryString()\n\n例：\n&#x2F;**\n * request 获取请求数据\n *&#x2F;\n@WebServlet(&quot;&#x2F;req1&quot;)\npublic class RequestDemo1 extends HttpServlet &#123;\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        &#x2F;&#x2F; String getMethod()：获取请求方式： GET\n        String method &#x3D; req.getMethod();\n        System.out.println(method);&#x2F;&#x2F;GET\n        &#x2F;&#x2F; String getContextPath()：获取虚拟目录(项目访问路径)：&#x2F;request-demo\n        String contextPath &#x3D; req.getContextPath();\n        System.out.println(contextPath);\n        &#x2F;&#x2F; StringBuffer getRequestURL(): 获取URL(统一资源定位符)：http:&#x2F;&#x2F;localhost:8080&#x2F;request-demo&#x2F;req1\n        StringBuffer url &#x3D; req.getRequestURL();\n        System.out.println(url.toString());\n        &#x2F;&#x2F; String getRequestURI()：获取URI(统一资源标识符)： &#x2F;request-demo&#x2F;req1\n        String uri &#x3D; req.getRequestURI();\n        System.out.println(uri);\n        &#x2F;&#x2F; String getQueryString()：获取请求参数（GET方式）： username&#x3D;zhangsan\n        String queryString &#x3D; req.getQueryString();\n        System.out.println(queryString);\n    &#125;\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n    &#125;\n&#125;\n\n获取请求头数据对于请求头的数据，格式为key: value如下：\n\n所以根据请求头名称获取对应值的方法为:\nString getHeader(String name)\n\n获取请求体数据浏览器在发送GET请求的时候是没有请求体的，所以需要把请求方式变更为POST，请求体中的数据格式如下:\n\n\n获取字节输入流，如果前端发送的是字节数据，比如传递的是文件数据，则使用该方法\n\nServletInputStream getInputStream()\n该方法可以获取字节\n\n\n获取字符输入流，如果前端发送的是纯文本数据，则使用该方法\n\nBufferedReader getReader()\n\n\n\n具体实现的步骤如下:\n1.准备一个页面，在页面中添加form表单,用来发送post请求\n2.在Servlet的doPost方法中获取请求体数据\n3.在doPost方法中使用request的getReader()或者getInputStream()来获取\n4.访问测试\n获取请求参数的通用方式\n\n获取所有参数Map集合\n\nMap&lt;String,String[]&gt; getParameterMap()\n\n\n根据名称获取参数值（数组）\n\nString[] getParameterValues(String name)\n\n\n根据名称获取参数值(单个值)\n\nString getParameter(String name)\n\npublic class RequestDemo1 extends HttpServlet &#123;\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n       &#x2F;&#x2F;采用request提供的获取请求参数的通用方式来获取请求参数\n       &#x2F;&#x2F;编写其他的业务代码...\n    &#125;\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        this.doGet(req,resp);\n    &#125;\n&#125;\n\n请求参数中文乱码处理\n请求参数如果存在中文数据，则会乱码\n\n解决方案：\n\nPOST:设置输入流的编码\nreq.setCharacterEncoding(&quot;UTF-8&quot;);\n\n通用方式（GET&#x2F;POST）：先编码，再解码\nnew String(username.getBytes(&quot;ISO-8859-\t1&quot;),&quot;UTF-8&quot;);\n\n\n\nRequest请求转发\n请求转发：一种在服务器的内部资源跳转方式\n\n\n\n实现方式：\nreq.getRequestDispatcher(&quot;资源B路径&quot;).forward(req,resp);\n\n请求转发资源间共享数据:使用Request对象\n\nvoid setAttribute(String name, Object o)：存储数据到request域中\nObject getAttribute(String name)：根据key，获取值\nvoid removAttribute(String name)：根据key，删除该键值对\n\n\n请求转发特点：\n\n浏览器地址栏领不发生变化\n只能转发到当前服务器的内部资源\n一次请求，可以在转发的资源间使用requset共享数据\n\n\n\nResponseResponse设置响应数据功能介绍\n响应数据分为3部分：\n\n响应行：\nHTTP&#x2F;1.1 200 OK\n\nvoid setStatus(int sc): 设置响应状态码\n\n响应头：\nContent-Type:text&#x2F;html\n\nvoid setHeader(String name, String value):设置响应头键值对\n\n响应体：\n&lt;html&gt;\n\t&lt;head&gt;\n\t\n\t&lt;head&gt;\n\t\n\t&lt;body&gt;\n\t\n\t&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\nprintWriter getWriter(): 获取字符输出流\nServletOutputStream getOutputStream():获取字节输出流\n\n\n\n\nResponse完成重定向\n重定向：一种资源跳转方式\n\n​\t\n资源路径问题\n建议动态获取虚拟目录：String contextPath &#x3D; request.getContextPath();\n重定向：response.sendRedirect(contextPath + “&#x2F;resp2”);\nResponse响应字符数据\n使用：\n1.通过Response对象获取字符输入流\nPrintWriter writer &#x3D; response.getWriter();\n\n2.写数据\nwriter.write(&quot;aaa&quot;);\n\n注意：\n\n该流不需要关闭，随着响应结束，Response对象销毁，由服务器关闭\n\n中文数据乱码：原因通过获取的字符输出流默认编码：ISO-8859-1\nresp.setContentType(&quot;text&#x2F;html;charset&#x3D;utf-8&quot;);\n\n\n\nResponse响应字节数据\n使用：\n1.通过Response对象获取字符输入流\nServletOutputStream outputStream &#x3D; resp.getOutputStream();\n\n2.写数据\noutputStream.write(字节数据);\n\nIOUtils工具类使用\n1.导入坐标\n&lt;dependency&gt;\n\t&lt;groupid&gt;commons-io&lt;&#x2F;groupid&gt;\n    &lt;artifactld&gt;commons-io&lt;&#x2F;artifactld&gt;\n    &lt;version&gt;2.6&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n2.使用\nIOUtils.copy(输入流，输出流);\n\nSqlSessionFactory代码优化String resource &#x3D; &quot;org&#x2F;mybatis&#x2F;example&#x2F;mybatis-config.xml&quot;;\nInputStream inputStream &#x3D; Resources.getResourceAsStream(resource);\nSqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);\n\n问题： \n​\t1.代码重复：       解决（工具类)\n​\t2.SqlSessionFactory工厂只创建一次，不要重复创建：  解决（静态代码块）\n我创建的工具类：\npackage com.itheima.util;\n\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\npublic class SqlSessionFactoryUtils &#123;\n    private static  SqlSessionFactory sqlSessionFactory;\n\n    static &#123;\n        &#x2F;&#x2F;静态代码块会随着类的加载自动执行，且只执行一次\n        try &#123;\n            String resource &#x3D; &quot;mybatis-config.xml&quot;;\n            InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);\n            SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);\n        &#125; catch (IOException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n    public static SqlSessionFactory getSqlSessionFactory()&#123;\n        return sqlSessionFactory;\n    &#125;\n&#125;\n\nJSP\nJava Server Pages ，Java服务端页面\n一种动态的网页技术，其中既可以定义HTML,JS,CSS等静态内容，还可以定义Java代码的动态内容\nJSP &#x3D; HTML + Java\n作用：简化开发，避免了在Servlet中直接输出HTML标签\n\n快速入门\n缺点\nEL表达式\n用于简化JSP页面内的Java代码\n\n主要功能：获取数据\n\n语法：${expression}\n$&#123;brands&#125;\n\n获取域中存储key为brands的数据\n\nJavaWeb中的四大域对象：\n\npage:当前页面有效\nrequest:当前请求有效\nsession:当前会话有效\napplication:当前应用有效\n\n\n\n*el表达式获取数据，会依次从这4个域中寻找，直到找到为止\nJSTL标签\nJSP标签库（Jsp Standarded Tag Library），使用标签取代JSP页面上的Java代码\n\n\n\nMVC模式和三层架构MVC\nMVC是一种分层开发模式，其中：\n\nM:Model，业务模型，处理业务\nV:View，视图，页面展示\nC：Controller，控制器，处理请求，调用模型和视图\n\n\nMVC好处\n\n职责单一，互不影响\n有利于分工协作\n有利于组件重用\n\n\n\n三层架构\n案例\n会话跟踪技术\n会话：用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应\n会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自同一浏览器，以便在同义词绘画的多次请求间共享数据\nHTTP协议是无状态的，每次浏览器向服务器请求时，服务器都会将该请求视为新的请求，因此我们需要会话跟踪技术来实现会话内数据共享\n实现方式：\n客户端会话跟踪技术：Cookie\n服务端会话跟踪技术：Session\n\n\n\nCookieCookie:客户端会话技术，将数据保存到客户端，以后每次请求都携带Cookie数据进行访问\nCookie基本使用发送Cookie1.创建Cookie对象，设置数据\nCookie cookie &#x3D; new Cookie(&quot;key&quot;,&quot;value&quot;);\n\n2.发送Cookie到客户端：使用response对象\nresponse.addCookie(cookie);\n\n获取Cookie3.获取客户端携带的所有Cookie，使用request对象\nCookie[] cookies &#x3D; request.getCookies();\n\n4.遍历数组，获取每一个Cookie对象：for\n5.使用Cookie对象方法获取数据\ncookie.getName();\n\ncookie.getValue();\n\nCookie原理\nCookie使用细节\nCookie存活时间：\n\n​\t-默认情况下，Cookie存储爱浏览器内存中，当浏览器关闭，内存释放，则Cookie被销毁\n​\tsetMaxAge（int seconds）：设置Cookie存活时间\n​\t\t1.正数：将Cookie写入浏览器所爱电脑的硬盘，持久化存储，到时见自动删除\n​\t\t2.负数：默认值，Cookie在当前浏览器内存中，当浏览器关闭，则Cookie被销毁\n​\t\t2.零：删除对应Cookie\n\nCookie存储中文\nCookie不能直接存储中文\n如需要存储，则需要进行转码：URL编码，使用时再解码\n\n\nSessionSession：服务端会话跟踪技术，将数据保存到服务端\nJavaEE提供HttpSession接口，来实现一次会话的多次请求间数据共享功能\nSession基本使用1.获取Session对象：\nHttpSession session &#x3D; request.getSession();\n\n2.Session对象功能：\n(1) void setAttribute(String name, Object o): 存储数据到session域中\n(2)Object getAttribute(String name):根据key，获取值\n(3)void removeAttribute(String name):根据key，删除该键值对\nSession原理\nSession是基于Cookie实现的\n\n在一次会话的多次请求之间获取的session对象是同一个\n\n\n\nSession使用细节\nSession钝化，活化：\n\n钝化：在服务器正常关闭后，Tomcat会自动将Session数据写入硬盘的文件\n活化：再次启动服务器后，从文件中加载到Session中\n\n\nSession销毁： \n\n默认情况下，无操作，30分钟自动销毁\n&lt;session-config&gt;\n\t&lt;session-timeout&gt;30&lt;&#x2F;session-timeout&gt;\n&lt;session-config&gt;\t\n\n调用Session对象的invalidate()方法\n\n\n\n\n小结\nCookie和Session都是来完成一次会话内多次请求建数据共享的\n区别：\n存储位置：Cookie是将数据存储在客户端，Session将数据存储在服务端\n安全性：Cookie不安全，Session安全\n数据大小：Cookie最大3KB，Session无大小限制\n存储时间：Cookie可以长期存储，Session默认30分钟\n服务器性能：Cookie不占服务器资源，Session占用服务器资源\n\n\n\nFilter\n概念：Filter表示过滤器，是Javaweb三大组件（Servlet，Filter，Listener）之一\n过滤器可以把对资源的请求拦截下来，从未实现一些特殊的功能\n过滤器一般完成一些通用的操作，比如：权限控制，统一编码处理，敏感字符处理等等……\n\n快速入门\n执行流程\n使用细节拦截路径配置\nFilter可以根据需求，配置不同的拦截资源路径\n@WebFilter(“&#x2F;*”)\npublic class FilterDemo\n\n拦截具体的资源：&#x2F;index.jsp: 只有访问index.jsp时才会被拦截\n目录拦截：&#x2F;user&#x2F;*:访问&#x2F;user下的所有资源，都会被拦截\n后缀名拦截：*.jsp：访问后缀名为jsp的资源，都会被拦截\n拦截所有：&#x2F;*：访问所有的资源，都会被拦截\n\n\n\n过滤器链\n一个Web应用，可以配置多个过滤器，这多个过滤器称为过滤器链\n\n\n\n注解配置的Filter，优先级按照过滤器类名（字符串）的自然排序\n\nListener\n概念：Listener是监听器，是JavaWeb三大组件(Servlet,Filter,Listener)之一\n\n监听器可以监听就是在application，session，request三个对象创建，销毁或者往其中添加修改删除属性时自动执行代码的功能组件\n\nListener分类：JavaWeb提供了8个监听器\n\n\n\n\nAJAX\n概念：异步的Javascript和XML\n\nAJAX作用：\n1.与服务器进行数据交换：通过AJAX可以给服务器发送请求，并获取服务器响应的数据\n\n使用了AJAX和服务器进行通信，就可以使用HTML+AJAX来替换JSP页面了\n\n2.异步交互：可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术，如：搜索联想，用户名是否可用校验，等等……\n异步和同步\n\n\nAJAX快速入门\nAxios异步框架\nAxios对原生的AJAX进行封装，简化书写\n官网：http://www.axios-http.cn\n\n将js文件 &#x2F;放到项目的webapp目录下\n\n引入 axios 的 js 文件\n&lt;script src&#x3D;&quot;js&#x2F;axios-0.18.0.js&quot;&gt;&lt;&#x2F;script&gt;\n\n使用axios 发送请求，并获取响应结果\n\n发送 get 请求\naxios(&#123;\n    method:&quot;get&quot;,\n    url:&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;ajax-demo1&#x2F;aJAXDemo1?username&#x3D;zhangsan&quot;\n&#125;).then(function (resp)&#123;\n    alert(resp.data);\n&#125;)\n\n发送 post 请求\naxios(&#123;\n    method:&quot;post&quot;,\n    url:&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;ajax-demo1&#x2F;aJAXDemo1&quot;,\n    data:&quot;username&#x3D;zhangsan&quot;\n&#125;).then(function (resp)&#123;\n    alert(resp.data);\n&#125;);\n\n整体页面代码如下：\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n\n&lt;script src&#x3D;&quot;js&#x2F;axios-0.18.0.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script&gt;\n    &#x2F;&#x2F;1. get\n   &#x2F;* axios(&#123;\n        method:&quot;get&quot;,\n        url:&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;ajax-demo&#x2F;axiosServlet?username&#x3D;zhangsan&quot;\n    &#125;).then(function (resp) &#123;\n        alert(resp.data);\n    &#125;)*&#x2F;\n\n    &#x2F;&#x2F;2. post  在js中&#123;&#125; 表示一个js对象，而这个js对象中有三个属性\n    axios(&#123;\n        method:&quot;post&quot;,\n        url:&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;ajax-demo&#x2F;axiosServlet&quot;,\n        data:&quot;username&#x3D;zhangsan&quot;\n    &#125;).then(function (resp) &#123;\n        alert(resp.data);\n    &#125;)\n&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n请求别名方式入门案例中的 get 请求代码可以改为如下：\naxios.get(&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;ajax-demo&#x2F;axiosServlet?username&#x3D;zhangsan&quot;).then(function (resp) &#123;\n    alert(resp.data);\n&#125;);\n\n入门案例中的 post 请求代码可以改为如下：\naxios.post(&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;ajax-demo&#x2F;axiosServlet&quot;,&quot;username&#x3D;zhangsan&quot;).then(function (resp) &#123;\n    alert(resp.data);\n&#125;)\n\nJSON\nJavaScript Object Notation。 JavaScript对象表示法\n\n由于其语法简单，层次结构鲜明，现多用于作为数据载体，在网络中进行数据传输\n\n\nJSON基础语法\nJSON数据和JAVA对象的转换\nFastjson 是阿里巴巴提供的一个Java语言编写的高性能功能完善的 JSON 库，是目前Java语言中最快的 JSON 库，可以实现 Java 对象和 JSON 字符串的相互转换。\n\n导入坐标\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.2.62&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\nJava对象转JSON\nString jsonStr &#x3D; JSON.toJSONString(obj);\n\n将 Java 对象转换为 JSON 串，只需要使用 Fastjson 提供的 JSON 类中的 toJSONString() 静态方法即可。\n\nJSON字符串转Java对象\nUser user &#x3D; JSON.parseObject(jsonStr, User.class);\n\n将 json 转换为 Java 对象，只需要使用 Fastjson 提供的 JSON 类中的 parseObject() 静态方法即可。\n\n\nVUE\n免除原生JavaScript中的DOM操作，简化书写\n基于MVVM(Model-View-ViewModel)思想，实现数据的双向绑定，将编程的关注点放在数据上\n官网：https：&#x2F;&#x2F;cn.vuejs.org\n\n\nVue快速入门1.新建HTML页面，引入Vue.js文件\n&lt;script src&#x3D;&quot;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n\n2.在JS代码区域，创建Vue和新对象，进行数据绑定\nnew Vue(&#123;\n\tel:&quot;#app&quot;,\n\tdata()&#123;\n\t\treturn &#123;\n\t\t\tusername:&quot;&quot;\n\t\t&#125;\n\t&#125;\n&#125;)\n\n3.编写视图\n&lt;div&gt;\n    &lt;input name&#x3D;&quot;username&quot; v-model&#x3D;&quot;username&quot;&gt;\n    &#123;&#123;username&#125;&#125;\n&lt;&#x2F;div&gt;\n\n\n\nVue常用指令\n\n\n指令\n作用\n\n\n\nv-bind\n为HTML标签绑定属性值，如设置  href , css样式等\n\n\nv-model\n在表单元素上创建双向数据绑定\n\n\nv-on\n为HTML标签绑定事件\n\n\nv-if\n条件性的渲染某元素，判定为true时渲染,否则不渲染\n\n\nv-else\n\n\n\nv-else-if\n\n\n\nv-show\n根据条件展示某元素，区别在于切换的是display属性的值\n\n\nv-for\n列表渲染，遍历容器的元素或者对象的属性\n\n\n v-show 不展示的原理是给对应的标签添加 display css属性，并将该属性值设置为 none ，这样就达到了隐藏的效果。而 v-if 指令是条件不满足时根本就不会渲染。\nVue生命周期\n\nElement\nElement：是饿了么公司前端开发团队提供的一套基于Vue的网站组件库，用于快速构建网页\n组件：组成网页的部件，例如超链接，按钮，图片，表格等等\n\nElement快速入门 引入Element的css，js文件和vue.js\n&lt;script src&#x3D;&quot;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script src&#x3D;&quot;element-ui&#x2F;lib&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;element-ui&#x2F;lib&#x2F;theme-chalk&#x2F;index.css&quot;&gt;\n\n创建Vue核心对象\n&lt;script&gt;\n    new Vue(&#123;\n        el:&quot;#app&quot;\n    &#125;)\n&lt;&#x2F;script&gt;\n\n官网复制Element组件代码\nElement布局\n","slug":"Web核心","date":"2022-07-06T06:27:05.000Z","categories_index":"","tags_index":"JavaWeb","author_index":"Aurora"},{"id":"cf5277bd1519d645b084515a79fe0c20","title":"java的值传递和引用传递","content":"一、基本类型和引用类型的理解Java中的数据类型分为两种为基本类型和引用类型。\n1、基本类型的变量保存原始值，所以变量就是数据本身。\n  常见的基本类型：byte,short,int,long,char,float,double,Boolean,returnAddress。\n2、引用类型的变量保存引用值，所谓的引用值就是对象所在内存空间的“首地址值”，通过对这个引用值来操作对象。\n  常见的引用类型：类类型，接口类型和数组。\n二、值传递和引用传递的理解1、值传递  在方法的调用过程中，实参把它的实际值传递给形参，此传递过程就是将实参的值复制一份传递到函数中，这样如果在函数中对该值（形参的值）进行了操作将不会影响实参的值。因为是直接复制，所以这种方式在传递大量数据时，运行效率会特别低下。\n2、引用传递  引用传递弥补了值传递的不足，如果传递的数据量很大，直接复过去的话，会占用大量的内存空间，而引用传递就是将对象的地址值传递过去，函数接收的是原始值的首地址值。在方法的执行过程中，形参和实参的内容相同，指向同一块内存地址，也就是说操作的其实都是源数据，所以方法的执行将会影响到实际对象。\n举例说明：\npublic class Example &#123;\n    String str &#x3D; new String(&quot;hello&quot;);\n    char[] ch &#x3D; &#123;&#39;a&#39;, &#39;b&#39;&#125;;\n    public static void main(String[] args) &#123;\n        Example ex &#x3D; new Example();\n        ex.change(ex.str, ex.ch);\n        System.out.println(ex.str + &quot; and&quot;);\n        System.out.println(ex.ch);\n    &#125;\n\n    public void change(String str, char[] ch) &#123;\n        str &#x3D; &quot;ok&quot;;\n        ch[0] &#x3D; &#39;c&#39;;\n    &#125;\n&#125;\n\n输出是：\nhello and\ncb\n\n过程分析：\n1、为对象分配空间\n\n2、执行change()方法\n执行前实参（黑色）和形参（红色）的指向如下：\n\n因为String是不可变类且为值传递，而ch[]是引用传递，所以方法中的str &#x3D; “ok”,相当于重新创建一个对象并没有改变实参str的值，数组是引用传递，直接改变，所以执行完方法后，指向关系如下：\n\n3.结论通过上面的分析我们可以得出以下结论：\n基本数据类型传值，对形参的修改不会影响实参；引用类型传引用，形参和实参指向同一个内存地址（同一个对象），所以对参数的修改会影响到实际的对象。String, Integer, Double等immutable的类型特殊处理，可以理解为传值，最后的操作不会修改实参对象。\n哈希表中的特殊情况只要是哈希表中的原生类型，如Integer，String，尽管他们平时是引用传递，但在哈希表中是按值传递！！！\n非原生类型，按值传递，如自己定义的类型。\n","slug":"java的值传递和引用传递","date":"2022-07-05T08:53:49.000Z","categories_index":"","tags_index":"java基础知识","author_index":"Aurora"},{"id":"711e99b247f8f70b0f4cf84df30732b2","title":"Leetcode高频题总结","content":"剑指Offer18 删除链表的节点class Solution &#123;\n    public ListNode deleteNode(ListNode head, int val) &#123;\n        while(head !&#x3D; null)&#123;\n            if(head.val !&#x3D; val)&#123;\n                break;\n            &#125;\n            head &#x3D; head.next;\n        &#125; &#x2F;&#x2F;找到第一个非空的头结点，用于返回和执行下步操作\n        ListNode pre &#x3D; head;\n        ListNode cur &#x3D; head;\n        while(cur !&#x3D; null)&#123;\n            if(cur.val &#x3D;&#x3D; val)&#123;\n                pre.next &#x3D; cur.next;\n            &#125;else&#123;\n                pre &#x3D; cur;\n            &#125;\n            cur &#x3D; cur.next;\n        &#125;\n        return head;\n    &#125;\n&#125;\n\n24 反转链表class Solution &#123;\n    public ListNode reverseList(ListNode head) &#123;\n        ListNode pre &#x3D; null;\n        ListNode next &#x3D; head;\n        while(next!&#x3D;null)&#123;\n            next &#x3D; head.next;\n            head.next &#x3D; pre;\n            pre &#x3D; head;\n            head &#x3D; next;\n        &#125;\n        return pre;\n    &#125;\n&#125;\n\n65 不用加减乘除做加法&#x2F;*\n思路：\n      首先看十进制是如何做的： 5+7&#x3D;12，三步走 第一步：相加各位的值，不算进位，得到2。\n      第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。\n      第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。 同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111 \n      第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。 \n      第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。 \n      第三步重复上述两步， 各位相加 010^1010&#x3D;1000，进位值为100&#x3D;(010&amp;1010)&lt;&lt;1。 继续重复上述两步：1000^100 &#x3D; 1100，进位值为0，跳出循环，1100为最终结果。\n————————————————\n版权声明：本文为CSDN博主「夏至&amp;未至」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_35571554&#x2F;article&#x2F;details&#x2F;82780288\n*&#x2F;\npublic class Solution &#123;\n    public int Add(int num1,int num2) &#123;\n        while (num2!&#x3D;0) &#123;\n            int temp &#x3D; num1^num2;\n            num2 &#x3D; (num1&amp;num2)&lt;&lt;1;\n            num1 &#x3D; temp;\n        &#125;\n        return num1;\n    &#125;\n&#125;\n\n","slug":"Leetcode高频题总结","date":"2022-07-05T03:05:06.000Z","categories_index":"","tags_index":"算法与数据结构","author_index":"Aurora"},{"id":"6688690e355db1dd869bd788558b9211","title":"数据结构与算法学习","content":"由于之前并未完整成体系的学习算法，在力扣刷100道题后\n感觉到算法知识不成体系，决定看左程云的体系学习班学习算法\n学习路线\n搞定1,2,3差不多达到面试水平\n杂记子问题规模一样的递归可以用Master公式求时间复杂度\nT(N) &#x3D; a * T(N&#x2F;b) + O(N ^ d);\na:会有几次调用代码\nb:每次调用规模的大小\n\n如果 log（b , a) &lt; d 时间复杂度为： O(N^d)\n如果log (b , a) &gt; d 时间复杂度为 ： O(N^(log(b,a)))\n如果log（b , a）&#x3D;&#x3D; d 时间复杂度为：O(N^d * log(2,n)))注：log(b,a) 指以b为地a为指数\n\n基础的数据结构实现栈和队列用数组实现队列&#x2F;&#x2F; 给定一个长度被限制数组空间，如何实现队列？\npublic class RingArray&#123;\n    public static class MyQueue&#123;\n        private int[]arr;\n        private int pushi;\n        private int rolli;\n        private int size;\n        private final int limit;\n        \n        public MyQueue(int limit)&#123;\n            arr &#x3D; new int[limit];\n            pushi &#x3D; 0;\n            polli &#x3D; 0;\n            size &#x3D; 0;\n            this.limit &#x3D; limit;\n        &#125;\n        \n        public void push(int value)&#123;\n            if(size &#x3D;&#x3D; limit)&#123;\n                throw new RuntimeException(&quot;队列满了，不能再加了&quot;);\n            &#125;\n            size++;\n            arr[pushi] &#x3D; value;\n            pushi &#x3D; nextIndex(pushi);\n        &#125;\n        \n        public int pop()&#123;\n            if(size &#x3D;&#x3D; 0)&#123;\n                throw new RuntimeException(&quot;队列空了，不能再拿了&quot;);\n            &#125;\n            int ans &#x3D; arr[rolli];\n            rolli &#x3D; nextIndex(rolli);\n            return ans;\n        &#125;\n        \n        public boolean isEmpty()&#123;\n            return size &#x3D;&#x3D; 0;\n        &#125;\n        \n        private int nextIndex(int i)&#123;\n            return i &lt; limit - 1 ? i + 1: 0;\n        &#125;\n    &#125;\n&#125;\n\n数组实现一个特殊的栈，可实时返回栈中最小值&#x2F;&#x2F;在基本功能上，再实现返回栈中最小元素的功能，且pop、push、getMin操作的时间复杂度是O(1).\n\n&#x2F;&#x2F;思路：维护一个栈和一个最小值栈，最小栈中存此时栈中的最小值。\n\npublic class GetMinStack &#123;\n\n\tpublic static class MyStack &#123;\n\t\tprivate Stack&lt;Integer&gt; stackData;\n\t\tprivate Stack&lt;Integer&gt; stackMin;\n\n\t\tpublic MyStack2() &#123;\n\t\t\tthis.stackData &#x3D; new Stack&lt;Integer&gt;();\n\t\t\tthis.stackMin &#x3D; new Stack&lt;Integer&gt;();\n\t\t&#125;\n\n\t\tpublic void push(int newNum) &#123;\n\t\t\tif (this.stackMin.isEmpty()) &#123;\n\t\t\t\tthis.stackMin.push(newNum);\n\t\t\t&#125; else if (newNum &lt; this.getmin()) &#123;\n\t\t\t\tthis.stackMin.push(newNum);\n\t\t\t&#125; else &#123;\n\t\t\t\tint newMin &#x3D; this.stackMin.peek();\n\t\t\t\tthis.stackMin.push(newMin);\n\t\t\t&#125;\n\t\t\tthis.stackData.push(newNum);\n\t\t&#125;\n\n\t\tpublic int pop() &#123;\n\t\t\tif (this.stackData.isEmpty()) &#123;\n\t\t\t\tthrow new RuntimeException(&quot;Your stack is empty.&quot;);\n\t\t\t&#125;\n\t\t\tthis.stackMin.pop();\n\t\t\treturn this.stackData.pop();\n\t\t&#125;\n\n\t\tpublic int getmin() &#123;\n\t\t\tif (this.stackMin.isEmpty()) &#123;\n\t\t\t\tthrow new RuntimeException(&quot;Your stack is empty.&quot;);\n\t\t\t&#125;\n\t\t\treturn this.stackMin.peek();\n\t\t&#125;\n\t&#125;\n\n&#125;\n\n如何用栈实现队列&#x2F;&#x2F; 思路：一个push栈，一个pop栈，把push栈的元素放进pop栈再取出来\n&#x2F;&#x2F; 为保证顺序，1、pop栈不为空时,push栈不能往pop栈里倒元素。2、push栈倒元素需要一次性倒完\n\npublic class TwoStacksImplementQueue &#123;\n\n\tpublic static class TwoStacksQueue &#123;\n\t\tpublic Stack&lt;Integer&gt; stackPush;\n\t\tpublic Stack&lt;Integer&gt; stackPop;\n\n\t\tpublic TwoStacksQueue() &#123;\n\t\t\tstackPush &#x3D; new Stack&lt;Integer&gt;();\n\t\t\tstackPop &#x3D; new Stack&lt;Integer&gt;();\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; push栈向pop栈倒入数据\n\t\tprivate void pushToPop() &#123;\n\t\t\tif (stackPop.empty()) &#123;\n\t\t\t\twhile (!stackPush.empty()) &#123;\n\t\t\t\t\tstackPop.push(stackPush.pop());\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tpublic void add(int pushInt) &#123;\n\t\t\tstackPush.push(pushInt);\n\t\t\tpushToPop();\n\t\t&#125;\n\n\t\tpublic int poll() &#123;\n\t\t\tif (stackPop.empty() &amp;&amp; stackPush.empty()) &#123;\n\t\t\t\tthrow new RuntimeException(&quot;Queue is empty!&quot;);\n\t\t\t&#125;\n\t\t\tpushToPop();\n\t\t\treturn stackPop.pop();\n\t\t&#125;\n\n\t\tpublic int peek() &#123;\n\t\t\tif (stackPop.empty() &amp;&amp; stackPush.empty()) &#123;\n\t\t\t\tthrow new RuntimeException(&quot;Queue is empty!&quot;);\n\t\t\t&#125;\n\t\t\tpushToPop();\n\t\t\treturn stackPop.peek();\n\t\t&#125;\n\t&#125;\n&#125;\n\n如何用队列实现栈&#x2F;&#x2F;实现poll或peek功能是第一个队列中除最后一个元素依次取出加进另一个队列，剩下的那个就是所需要的元素\npublic class Code07_TwoQueueImplementStack &#123;\n\n\tpublic static class TwoQueueStack&lt;T&gt; &#123;\n\t\tpublic Queue&lt;T&gt; queue;\n\t\tpublic Queue&lt;T&gt; help;\n\n\t\tpublic TwoQueueStack() &#123;\n\t\t\tqueue &#x3D; new LinkedList&lt;&gt;();\n\t\t\thelp &#x3D; new LinkedList&lt;&gt;();\n\t\t&#125;\n\n\t\tpublic void push(T value) &#123;\n\t\t\tqueue.offer(value);\n\t\t&#125;\n\n\t\tpublic T poll() &#123;\n\t\t\twhile (queue.size() &gt; 1) &#123;\n\t\t\t\thelp.offer(queue.poll());\n\t\t\t&#125;\n\t\t\tT ans &#x3D; queue.poll();\n\t\t\tQueue&lt;T&gt; tmp &#x3D; queue;\n\t\t\tqueue &#x3D; help;\n\t\t\thelp &#x3D; tmp;\n\t\t\treturn ans;\n\t\t&#125;\n\n\t\tpublic T peek() &#123;\n\t\t\twhile (queue.size() &gt; 1) &#123;\n\t\t\t\thelp.offer(queue.poll());\n\t\t\t&#125;\n\t\t\tT ans &#x3D; queue.poll();\n\t\t\thelp.offer(ans);\n\t\t\tQueue&lt;T&gt; tmp &#x3D; queue;\n\t\t\tqueue &#x3D; help;\n\t\t\thelp &#x3D; tmp;\n\t\t\treturn ans;\n\t\t&#125;\n\n\t\tpublic boolean isEmpty() &#123;\n\t\t\treturn queue.isEmpty();\n\t\t&#125;\n\t&#125;\n&#125;\n\n堆public class Heap &#123;\n\n\tpublic static class MyMaxHeap &#123;\n\t\tprivate int[] heap;\n\t\tprivate final int limit;\n\t\tprivate int heapSize;\n\n\t\tpublic MyMaxHeap(int limit) &#123;\n\t\t\theap &#x3D; new int[limit];\n\t\t\tthis.limit &#x3D; limit;\n\t\t\theapSize &#x3D; 0;\n\t\t&#125;\n\n\t\tpublic boolean isEmpty() &#123;\n\t\t\treturn heapSize &#x3D;&#x3D; 0;\n\t\t&#125;\n\n\t\tpublic boolean isFull() &#123;\n\t\t\treturn heapSize &#x3D;&#x3D; limit;\n\t\t&#125;\n\n\t\tpublic void push(int value) &#123;\n\t\t\tif (heapSize &#x3D;&#x3D; limit) &#123;\n\t\t\t\tthrow new RuntimeException(&quot;heap is full&quot;);\n\t\t\t&#125;\n\t\t\theap[heapSize] &#x3D; value;\n\t\t\t&#x2F;&#x2F; value heapSize\n\t\t\theapInsert(heap, heapSize++);\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; 返回最大值，并且在大根堆中，把最大值删掉\n\t\t&#x2F;&#x2F; 剩下的数，依然保持大根堆组织\n\t\tpublic int pop() &#123;\n\t\t\tint ans &#x3D; heap[0];\n\t\t\tswap(heap, 0, --heapSize);\n\t\t\theapify(heap, 0, heapSize);\n\t\t\treturn ans;\n\t\t&#125;\n\n\t\tprivate void heapInsert(int[] arr, int index) &#123;\n\t\t\t&#x2F;&#x2F; [index] [index-1]&#x2F;2\n\t\t\t&#x2F;&#x2F; index &#x3D;&#x3D; 0\n\t\t\twhile (arr[index] &gt; arr[(index - 1) &#x2F; 2]) &#123;\n\t\t\t\tswap(arr, index, (index - 1) &#x2F; 2);\n\t\t\t\tindex &#x3D; (index - 1) &#x2F; 2;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tprivate void heapify(int[] arr, int index, int heapSize) &#123;\n\t\t\tint left &#x3D; index * 2 + 1;\n\t\t\twhile (left &lt; heapSize) &#123; &#x2F;&#x2F; 如果有左孩子，有没有右孩子，可能有可能没有！\n\t\t\t\t&#x2F;&#x2F; 把较大孩子的下标，给largest\n\t\t\t\tint largest &#x3D; left + 1 &lt; heapSize &amp;&amp; arr[left + 1] &gt; arr[left] ? left + 1 : left;\n\t\t\t\tlargest &#x3D; arr[largest] &gt; arr[index] ? largest : index;\n\t\t\t\tif (largest &#x3D;&#x3D; index) &#123;\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t\t\t&#x2F;&#x2F; index和较大孩子，要互换\n\t\t\t\tswap(arr, largest, index);\n\t\t\t\tindex &#x3D; largest;\n\t\t\t\tleft &#x3D; index * 2 + 1;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tprivate void swap(int[] arr, int i, int j) &#123;\n\t\t\tint tmp &#x3D; arr[i];\n\t\t\tarr[i] &#x3D; arr[j];\n\t\t\tarr[j] &#x3D; tmp;\n\t\t&#125;\n\n\t&#125;\n&#125;\n\n\n\n排序选择排序0~N-1上找到最小值与下标为0的值交换\n1~N-1上找到最小值与下标为1的值交换\n2~N-1上找到最小值与下标为2的值交换\n······\npublic static void selectionSort(int[] arr) &#123;\n\t\tif (arr &#x3D;&#x3D; null || arr.length &lt; 2) &#123;\n\t\t\treturn;\n\t\t&#125;\n\t\t&#x2F;&#x2F; 0 ~ N-1  找到最小值，在哪，放到0位置上\n\t\t&#x2F;&#x2F; 1 ~ n-1  找到最小值，在哪，放到1 位置上\n\t\t&#x2F;&#x2F; 2 ~ n-1  找到最小值，在哪，放到2 位置上\n\t\tfor (int i &#x3D; 0; i &lt; arr.length - 1; i++) &#123;\n\t\t\tint minIndex &#x3D; i;\n\t\t\tfor (int j &#x3D; i + 1; j &lt; arr.length; j++) &#123; &#x2F;&#x2F; i ~ N-1 上找最小值的下标 \n\t\t\t\tminIndex &#x3D; arr[j] &lt; arr[minIndex] ? j : minIndex;\n\t\t\t&#125;\n\t\t\tswap(arr, i, minIndex);\n\t\t&#125;\n\t&#125;\n\n\tpublic static void swap(int[] arr, int i, int j) &#123;\n\t\tint tmp &#x3D; arr[i];\n\t\tarr[i] &#x3D; arr[j];\n\t\tarr[j] &#x3D; tmp;\n\t&#125;\n\n冒泡排序public static void bubbleSort(int[] arr) &#123;\n\t\tif (arr &#x3D;&#x3D; null || arr.length &lt; 2) &#123;\n\t\t\treturn;\n\t\t&#125;\n\t\t&#x2F;&#x2F; 0 ~ N-1\n\t\t&#x2F;&#x2F; 0 ~ N-2\n\t\t&#x2F;&#x2F; 0 ~ N-3\n\t\tfor (int e &#x3D; arr.length - 1; e &gt; 0; e--) &#123; &#x2F;&#x2F; 0 ~ e\n\t\t\tfor (int i &#x3D; 0; i &lt; e; i++) &#123;\n\t\t\t\tif (arr[i] &gt; arr[i + 1]) &#123;\n\t\t\t\t\tswap(arr, i, i + 1);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F; 交换arr的i和j位置上的值，i和j是一个位置的话，会出错\n\tpublic static void swap(int[] arr, int i, int j) &#123;\n\t\tarr[i] &#x3D; arr[i] ^ arr[j];\n\t\tarr[j] &#x3D; arr[i] ^ arr[j];\n\t\tarr[i] &#x3D; arr[i] ^ arr[j];\n\t&#125;\n\n\n\n\n插入排序public static void insertionSort(int[] arr) &#123;\n\t\tif (arr &#x3D;&#x3D; null || arr.length &lt; 2) &#123;\n\t\t\treturn;\n\t\t&#125;\n\t\t&#x2F;&#x2F; 不只1个数\n\t\tfor (int i &#x3D; 1; i &lt; arr.length; i++) &#123; &#x2F;&#x2F; 0 ~ i 做到有序\n\t\t\tfor (int j &#x3D; i - 1; j &gt;&#x3D; 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) &#123;\n\t\t\t\tswap(arr, j, j + 1);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F; i和j是一个位置的话，会出错\n\tpublic static void swap(int[] arr, int i, int j) &#123;\n\t\tarr[i] &#x3D; arr[i] ^ arr[j];\n\t\tarr[j] &#x3D; arr[i] ^ arr[j];\n\t\tarr[i] &#x3D; arr[i] ^ arr[j];\n\t&#125;\n\n归并排序&#x2F;&#x2F; 递归方法实现\n\tpublic static void mergeSort1(int[] arr) &#123;\n\t\tif (arr &#x3D;&#x3D; null || arr.length &lt; 2) &#123;\n\t\t\treturn;\n\t\t&#125;\n\t\tprocess(arr, 0, arr.length - 1);\n\t&#125;\n\n\t&#x2F;&#x2F; 请把arr[L..R]排有序\n\t&#x2F;&#x2F; l...r N\n\t&#x2F;&#x2F; T(N) &#x3D; 2 * T(N &#x2F; 2) + O(N)\n\t&#x2F;&#x2F; O(N * logN)\n\tpublic static void process(int[] arr, int L, int R) &#123;\n\t\tif (L &#x3D;&#x3D; R) &#123; &#x2F;&#x2F; base case\n\t\t\treturn;\n\t\t&#125;\n\t\tint mid &#x3D; L + ((R - L) &gt;&gt; 1);\n\t\tprocess(arr, L, mid);\n\t\tprocess(arr, mid + 1, R);\n\t\tmerge(arr, L, mid, R);\n\t&#125;\n\n\tpublic static void merge(int[] arr, int L, int M, int R) &#123;\n\t\tint[] help &#x3D; new int[R - L + 1];\n\t\tint i &#x3D; 0;\n\t\tint p1 &#x3D; L;\n\t\tint p2 &#x3D; M + 1;\n\t\twhile (p1 &lt;&#x3D; M &amp;&amp; p2 &lt;&#x3D; R) &#123;\n\t\t\thelp[i++] &#x3D; arr[p1] &lt;&#x3D; arr[p2] ? arr[p1++] : arr[p2++];\n\t\t&#125;\n\t\t&#x2F;&#x2F; 要么p1越界了，要么p2越界了\n\t\twhile (p1 &lt;&#x3D; M) &#123;\n\t\t\thelp[i++] &#x3D; arr[p1++];\n\t\t&#125;\n\t\twhile (p2 &lt;&#x3D; R) &#123;\n\t\t\thelp[i++] &#x3D; arr[p2++];\n\t\t&#125;\n\t\tfor (i &#x3D; 0; i &lt; help.length; i++) &#123;\n\t\t\tarr[L + i] &#x3D; help[i];\n\t\t&#125;\n\t&#125;\n\n变形1：给定一个数组，求出每个元素左边比他小的元素之和，再求每个元素左边比他小的元素之和的累加和，要求小于O（N^2）\npublic static int smallSum(int[] arr) &#123;\n\t\tif (arr &#x3D;&#x3D; null || arr.length &lt; 2) &#123;\n\t\t\treturn 0;\n\t\t&#125;\n\t\treturn process(arr, 0, arr.length - 1);\n\t&#125;\n\n\t&#x2F;&#x2F; arr[L..R]既要排好序，也要求小和返回\n\t&#x2F;&#x2F; 所有merge时，产生的小和，累加\n\t&#x2F;&#x2F; 左 排序   merge\n\t&#x2F;&#x2F; 右 排序  merge\n\t&#x2F;&#x2F; merge\n\tpublic static int process(int[] arr, int l, int r) &#123;\n\t\tif (l &#x3D;&#x3D; r) &#123;\n\t\t\treturn 0;\n\t\t&#125;\n\t\t&#x2F;&#x2F; l &lt; r\n\t\tint mid &#x3D; l + ((r - l) &gt;&gt; 1);\n\t\treturn \n\t\t\t\tprocess(arr, l, mid) \n\t\t\t\t+ \n\t\t\t\tprocess(arr, mid + 1, r) \n\t\t\t\t+ \n\t\t\t\tmerge(arr, l, mid, r);\n\t&#125;\n\n\tpublic static int merge(int[] arr, int L, int m, int r) &#123;\n\t\tint[] help &#x3D; new int[r - L + 1];\n\t\tint i &#x3D; 0;\n\t\tint p1 &#x3D; L;\n\t\tint p2 &#x3D; m + 1;\n\t\tint res &#x3D; 0;\n\t\twhile (p1 &lt;&#x3D; m &amp;&amp; p2 &lt;&#x3D; r) &#123;\n\t\t\tres +&#x3D; arr[p1] &lt; arr[p2] ? (r - p2 + 1) * arr[p1] : 0;&#x2F;&#x2F;就多了这一行代码\n\t\t\thelp[i++] &#x3D; arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];\n\t\t&#125;\n\t\twhile (p1 &lt;&#x3D; m) &#123;\n\t\t\thelp[i++] &#x3D; arr[p1++];\n\t\t&#125;\n\t\twhile (p2 &lt;&#x3D; r) &#123;\n\t\t\thelp[i++] &#x3D; arr[p2++];\n\t\t&#125;\n\t\tfor (i &#x3D; 0; i &lt; help.length; i++) &#123;\n\t\t\tarr[L + i] &#x3D; help[i];\n\t\t&#125;\n\t\treturn res;\n\t&#125;\n\n变形2：求逆序对的数量\n给定一个序列有n个数，求n个数中逆序对的个数，逆序对的定义：i &lt; j &amp;&amp; a[i] &gt; a[j]。\nint merge_sort(int a[], int l ,int r)&#123;\n    &#x2F;&#x2F;序列只有一个数\n    if (l &#x3D;&#x3D; r) return 0;\n    &#x2F;&#x2F;递归左边和右边\n    int mid &#x3D; l + r &gt;&gt; 1;\n    int res &#x3D; merge_sort(a, l , mid) + merge_sort(a, mid + 1, r);\n    &#x2F;&#x2F;归并的过程\n    int i &#x3D; l , j &#x3D; mid + 1, k &#x3D; 0;\n    while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r)&#123;\n        if (a[i] &lt;&#x3D; a[j]) t[k++] &#x3D; a[i++];\n        else&#123;\n            t[k++] &#x3D; a[j++];\n            res +&#x3D; mid - i + 1;\n        &#125;\n    &#125;\n    while (i &lt;&#x3D; mid) t[k++] &#x3D; a[i++];\n    while (j &lt;&#x3D; r) t[k++] &#x3D; a[j++];\n    \n    &#x2F;&#x2F;还原数组\n    for (int i &#x3D; 0 , j &#x3D; l ; j &lt;&#x3D; r ; i ++ , j ++) a[j] &#x3D; t[i];\n    \n    return res;\n&#125;\n\n\n变形3：翻转对\nclass Solution &#123;\n   public static int reversePairs(int[] nums) &#123;\n\t\tif (nums &#x3D;&#x3D; null || nums.length &lt; 2) &#123;\n\t\t\treturn 0;\n\t\t&#125;\n\t\treturn process(nums, 0, nums.length - 1);\n\t&#125;\n\n\tpublic static int process(int[] nums, int l, int r) &#123;\n\t\tif (l &#x3D;&#x3D; r) &#123;\n\t\t\treturn 0;\n\t\t&#125;\n\t\t&#x2F;&#x2F; l &lt; r\n\t\tint mid &#x3D; l + ((r - l) &gt;&gt; 1);\n\t\treturn process(nums, l, mid) + process(nums, mid + 1, r) + merge(nums, l, mid, r);\n\t&#125;\n\n\tpublic static int merge(int[] nums, int L, int m, int r) &#123;\n\t\t&#x2F;&#x2F; [L....M] [M+1....R]\n\t\tint ans &#x3D; 0;\n\t\tint windowR &#x3D; m + 1;\n\t\tfor (int i &#x3D; L; i &lt;&#x3D; m; i++) &#123;\n\t\t\twhile (windowR &lt;&#x3D; r &amp;&amp; (long) nums[i] &gt; (long) nums[windowR] * 2) &#123;\n\t\t\t\twindowR++;\n\t\t\t&#125;\n\t\t\tans +&#x3D; windowR - m - 1;\n\t\t&#125;\n\t\tint[] help &#x3D; new int[r - L + 1];\n\t\tint i &#x3D; 0;\n\t\tint p1 &#x3D; L;\n\t\tint p2 &#x3D; m + 1;\n\t\twhile (p1 &lt;&#x3D; m &amp;&amp; p2 &lt;&#x3D; r) &#123;\n\t\t\thelp[i++] &#x3D; nums[p1] &lt;&#x3D; nums[p2] ? nums[p1++] : nums[p2++];\n\t\t&#125;\n\t\twhile (p1 &lt;&#x3D; m) &#123;\n\t\t\thelp[i++] &#x3D; nums[p1++];\n\t\t&#125;\n\t\twhile (p2 &lt;&#x3D; r) &#123;\n\t\t\thelp[i++] &#x3D; nums[p2++];\n\t\t&#125;\n\t\tfor (i &#x3D; 0; i &lt; help.length; i++) &#123;\n\t\t\tnums[L + i] &#x3D; help[i];\n\t\t&#125;\n\t\treturn ans;\n\t&#125;\n&#125;\n\n堆排序public class HeapSort&#123;\n    public static void heapSort(int[] arr) &#123;\n\t\tif (arr &#x3D;&#x3D; null || arr.length &lt; 2) &#123;\n\t\t\treturn;\n\t\t&#125;\n\t\tfor (int i &#x3D; 0; i &lt; arr.length; i++) &#123; &#x2F;&#x2F; O(N)\n\t\t\theapInsert(arr, i); &#x2F;&#x2F; O(logN)\n\t\t&#125;\n\t\t&#x2F;&#x2F; O(N)\n&#x2F;&#x2F;\t\tfor (int i &#x3D; arr.length - 1; i &gt;&#x3D; 0; i--) &#123;\n&#x2F;&#x2F;\t\t\theapify(arr, i, arr.length);\n&#x2F;&#x2F;\t\t&#125;\n\t\tint heapSize &#x3D; arr.length;\n\t\tswap(arr, 0, --heapSize);\n\t\twhile (heapSize &gt; 0) &#123; &#x2F;&#x2F; O(N) \n\t\t\theapify(arr, 0, heapSize); &#x2F;&#x2F; O(logN)\n\t\t\tswap(arr, 0, --heapSize); &#x2F;&#x2F; O(1)\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F; arr[index]刚来的数，往上\n\tpublic static void heapInsert(int[] arr, int index) &#123;\n\t\twhile (arr[index] &gt; arr[(index - 1) &#x2F; 2]) &#123;\n\t\t\tswap(arr, index, (index - 1) &#x2F; 2);\n\t\t\tindex &#x3D; (index - 1) &#x2F; 2;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F; arr[index]位置的数，能否往下移动\n\tpublic static void heapify(int[] arr, int index, int heapSize) &#123;\n\t\tint left &#x3D; index * 2 + 1; &#x2F;&#x2F; 左孩子的下标\n\t\twhile (left &lt; heapSize) &#123; &#x2F;&#x2F; 下方还有孩子的时候\n\t\t\t&#x2F;&#x2F; 两个孩子中，谁的值大，把下标给largest\n\t\t\tint largest &#x3D; left + 1 &lt; heapSize &amp;&amp; arr[left + 1] &gt; arr[left] ? left + 1 : left;\n\t\t\t&#x2F;&#x2F; 父和较大的孩子之间，谁的值大，把下标给largest\n\t\t\tlargest &#x3D; arr[largest] &gt; arr[index] ? largest : index;\n\t\t\tif (largest &#x3D;&#x3D; index) &#123;\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t\tswap(arr, largest, index);\n\t\t\tindex &#x3D; largest;\n\t\t\tleft &#x3D; index * 2 + 1;\n\t\t&#125;\n\t&#125;\n\n\tpublic static void swap(int[] arr, int i, int j) &#123;\n\t\tint tmp &#x3D; arr[i];\n\t\tarr[i] &#x3D; arr[j];\n\t\tarr[j] &#x3D; tmp;\n\t&#125;\n&#125;\n\n\n\n位运算int a &#x3D; 7;\nint b &#x3D; -a &#x3D; (~a) + 1 &#x3D; -7;\n\n&#x2F;&#x2F; arr中，只有一种数，出现奇数次\npublic static void printOddTimesNum1(int[] arr) &#123;\n\tint eor &#x3D; 0;\n\tfor (int i &#x3D; 0; i &lt; arr.length; i++) &#123;\n\t\teor ^&#x3D; arr[i];\n\t&#125;\n\tSystem.out.println(eor);\n&#125;\n\n&#x2F;&#x2F; arr中，有两种数，出现奇数次\npublic static void printOddTimesNum2(int[] arr) &#123;\n\tint eor &#x3D; 0;\n\tfor (int i &#x3D; 0; i &lt; arr.length; i++) &#123;\n\t\teor ^&#x3D; arr[i];\n\t&#125;\n\t&#x2F;&#x2F; a 和 b是两种数\n\t&#x2F;&#x2F; eor !&#x3D; 0\n\t&#x2F;&#x2F; eor最右侧的1，提取出来\n\t&#x2F;&#x2F; eor :     00110010110111000\n\t&#x2F;&#x2F; rightOne :00000000000001000\n\tint rightOne &#x3D; eor &amp; (-eor); &#x2F;&#x2F; 提取出最右的1\n\t\n\t\n\tint onlyOne &#x3D; 0; &#x2F;&#x2F; eor&#39;\n\tfor (int i &#x3D; 0 ; i &lt; arr.length;i++) &#123;\n\t\t&#x2F;&#x2F;  arr[1] &#x3D;  111100011110000\n\t\t&#x2F;&#x2F; rightOne&#x3D;  000000000010000\n\t\tif ((arr[i] &amp; rightOne) !&#x3D; 0) &#123;\n\t\t\tonlyOne ^&#x3D; arr[i];\n\t\t&#125;\n\t&#125;\n\tSystem.out.println(onlyOne + &quot; &quot; + (eor ^ onlyOne));\n&#125;\n   &#x2F;&#x2F; 输入一定能够保证，数组中所有的数都出现了M次，只有一种数出现了K次\n   &#x2F;&#x2F; 1 &lt;&#x3D; K &lt; M\n   &#x2F;&#x2F; 返回这种数\n   public static int km(int[] arr, int k, int m) &#123;\n       int[] help &#x3D; new int[32];\n       for (int num : arr) &#123;\n           for (int i &#x3D; 0; i &lt; 32; i++) &#123;\n               help[i] +&#x3D; (num &gt;&gt; i) &amp; 1;\n           &#125;\n       &#125;\n       int ans &#x3D; 0;\n       for (int i &#x3D; 0; i &lt; 32; i++) &#123;\n           help[i] %&#x3D; m;\n           if (help[i] !&#x3D; 0) &#123;\n               ans |&#x3D; 1 &lt;&lt; i;\n           &#125;\n       &#125;\n       return ans;\n   &#125;\n\n\n\n\n\n","slug":"数据结构与算法学习","date":"2022-07-02T01:51:23.000Z","categories_index":"","tags_index":"算法与数据结构","author_index":"Aurora"},{"id":"d75b47533ffd84933c1aac3f8bde1caa","title":"前端三件套","content":"HTMLHTML：超文本标记语言超文本：超越了文本的的限制，比普通文本更强大，除了文字信息，还可以定义图片，音频，视频等内容。标记语言：由标签构成的语言\nHTML运行在浏览器上，HTML标签由浏览器来解析\nHTML标签都是预定义好的。例如：使用&lt;img&gt;展示图片\n\nW3C标准：网页主要由三部分组成\n结构：HTML\n表现：CSS\n行为：JavaScript\n\n\n\nHTML结构：\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;&lt;&#x2F;title&gt;\n    &lt;&#x2F;head&gt;\n    &lt;body&gt;\n        \n    &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\n\n\n\n\n \nCSS导入方式：\n1、使用“”引入css样式；\n2、在style标签里写css样式；\n3、在元素标签里使用style属性写css样式。\n具体使用查W3cschool\njs导入方式：\n1、直接引入\n&lt;script&gt;alert(&quot;这是js的内部引入&quot;);&lt;&#x2F;script&gt;\n2、\n定义外部js文件\n&lt;script type&#x3D;”text&#x2F;javascript” src&#x3D;”demo.js”&gt;\n基本语法结尾 ; 可有可无\n使用window.alert()写入警告框\n使用document.write()写入html输出\n使用console.log()写入浏览器控制台\n用var声明变量\nvar test &#x3D; 20;\ntest &#x3D; &quot;张三&quot;\n\nJavascript是一门弱类型语言，变量可以存放不同类型的值\n变量名命名规则：\n\n组成字符可以是任何字母，数组，下划线(_)或美元符号($)\n数字不能开头\n建议使用驼峰命名\n\nECMAScript6新增了let关键字来定义变量，它的用法类似于var，但是所声明的变量，只在let关键字所在的代码块内有效，且不允许重复声明\nECMAScript6新增了const关键字，用来声明一个只读的常量。一旦声明，常量的值就不能改变了\n\n运算符 &#x3D;&#x3D;  和  &#x3D;&#x3D;&#x3D; \nvar age1 &#x3D; 20;\nvar age2 &#x3D; &quot;20&quot;;\nalert(age1 &#x3D;&#x3D; age2) &#x2F;&#x2F;会返回true\nalert(age1 &#x3D;&#x3D;&#x3D; age2) &#x2F;&#x2F;会返回false\n&#x2F;*\n\t&#x3D;&#x3D; ：1.判断类型是否一样，如果不一样，先转换成一样\n    \t2.再判断是否相等\n\t&#x3D;&#x3D;&#x3D;：1.判断类型是否一样，如果不一样，直接返回false\n\t\t2.再判断是否相等\n*&#x2F;\n\n\n\n\n\n类型转换：其他类型转为number：\n\nstring: 按照字符串的字面值，转为数字.如果字面值不是数字，则转为NaN。一般使用parseInt\nboolean: true 转为1，false转为0\n\n其他类型转为boolean：\n\nnumber:0和NaN转为false，其他的数字转为true \nstring:空字符串转为false，其他的字符串转为true \nnull:false \nundefined:false\n\n\n\n对象Array\nString\n自定义对象\nBOMBOM：Browser Object Model 浏览器对象模型。也就是 JavaScript 将浏览器的各个组成部分封装为对象。\n我们要操作浏览器的各个组成部分就可以通过操作 BOM 中的对象来实现。比如：我现在想将浏览器地址栏的地址改为 https://www.itheima.com 就可以通过使用 BOM 中定义的 Location 对象的 href 属性，代码： location.href = &quot;https://itheima.com&quot;; \n BOM 中包含了如下对象：\n\nWindow：浏览器窗口对象\nNavigator：浏览器对象\nScreen：屏幕对象\nHistory：历史记录对象\nLocation：地址栏对象\n\n下图是 BOM 中的各个对象和浏览器的各个组成部分的对应关系\n\nwindow对象\nhistory对象\nloaction对象\nDOMDOM：Document Object Model 文档对象模型。也就是 JavaScript 将 HTML 文档的各个组成部分封装为对象。\nDOM 其实我们并不陌生，之前在学习 XML 就接触过，只不过 XML 文档中的标签需要我们写代码解析，而 HTML 文档是浏览器解析。封装的对象分为\n\nDocument：整个文档对象\nElement：元素对象\nAttribute：属性对象\nText：文本对象\nComment：注释对象\n\n如下图，左边是 HTML 文档内容，右边是 DOM 树\n\n作用：\nJavaScript 通过 DOM， 就能够对 HTML进行操作了\n\n改变 HTML 元素的内容\n改变 HTML 元素的样式（CSS）\n对 HTML DOM 事件作出反应\n添加和删除 HTML 元素\n\nDOM相关概念：\nDOM 是 W3C（万维网联盟）定义了访问 HTML 和 XML 文档的标准。该标准被分为 3 个不同的部分：\n\n核心 DOM：针对任何结构化文档的标准模型。 XML 和 HTML 通用的标准\n\nDocument：整个文档对象\n\nElement：元素对象\n\nAttribute：属性对象\n\nText：文本对象\n\nComment：注释对象\n\n\n\nXML DOM： 针对 XML 文档的标准模型\n\nHTML DOM： 针对 HTML 文档的标准模型\n该标准是在核心 DOM 基础上，对 HTML 中的每个标签都封装成了不同的对象\n\n例如：&lt;img&gt; 标签在浏览器加载到内存中时会被封装成 Image 对象，同时该对象也是 Element 对象。\n例如：&lt;input type=&#39;button&#39;&gt; 标签在浏览器加载到内存中时会被封装成 Button 对象，同时该对象也是 Element 对象。\n\n\n\n获取Element对象HTML 中的 Element 对象可以通过 Document 对象获取，而 Document 对象是通过 window 对象获取。\nDocument 对象中提供了以下获取 Element 元素对象的函数\n\ngetElementById()：根据id属性值获取，返回单个Element对象\ngetElementsByTagName()：根据标签名称获取，返回Element对象数组\ngetElementsByName()：根据name属性值获取，返回Element对象数组\ngetElementsByClassName()：根据class属性值获取，返回Element对象数组\n\n事件监听\n事件：HTML事件是发生在HTML元素身上的“事情”。比如：\n\n按钮被点击\n鼠标移动到元素之上\n按下键盘按键\n\n\n事件监听：Javascript可以在事件被侦测到时执行代码\n\n\n事件绑定方式一：通过 HTML标签中的事件属性进行绑定\nonclick 是 单击事件 的事件属性\n&lt;input type&#x3D;&quot;button&quot; onclick&#x3D;&#39;on()’&gt;\nfunction on()&#123;\n\talert(&quot;我被点了&quot;);\n&#125;\n\n方式二：通过 DOM 元素属性绑定\n&lt;input type&#x3D;&quot;button&quot; id&#x3D;&quot;btn&quot;&gt;\ndocument.getElementById(&quot;btn&quot;).onclick &#x3D; function ()&#123;\n    alert(&quot;我被点了&quot;);\n&#125;\n\n为保证单一职责，建议使用方式二\n常见事件\n正则表达式正则对象有两种创建方式：\n\n直接量方式：注意不要加引号\nvar reg &#x3D; &#x2F;正则表达式&#x2F;;\n\n创建 RegExp 对象\nvar reg &#x3D; new RegExp(&quot;正则表达式&quot;);\n\ntest(str) ：判断指定字符串是否符合规则，返回 true或 false\n从上面创建正则对象的格式中可以看出不管哪种方式都需要正则表达式，那么什么是正则表达式呢？\n正则表达式定义了字符串组成的规则。也就是判断指定的字符串是否符合指定的规则，如果符合返回true，如果不符合返回false。\n正则表达式是和语言无关的。很多语言都支持正则表达式，Java语言也支持，只不过正则表达式在不同的语言中的使用方式不同，js 中需要使用正则对象来使用正则表达式。\n正则表达式常用的规则如下：\n\n^：表示开始\n\n$：表示结束\n\n[ ]：代表某个范围内的单个字符，比如： [0-9] 单个数字字符\n\n.：代表任意单个字符，除了换行和行结束符\n\n\\w：代表单词字符：字母、数字、下划线()，相当于 [A-Za-z0-9]\n\n\\d：代表数字字符： 相当于 [0-9]\n\n\n量词：\n\n+：至少一个\n\n*：零个或多个\n\n？：零个或一个\n\n{x}：x个\n\n{m,}：至少m个\n\n{m,n}：至少m个，最多n个\n\n\n","slug":"前端三件套基础入门","date":"2022-06-30T02:44:09.000Z","categories_index":"","tags_index":"前端","author_index":"Aurora"},{"id":"54e1d69dbe01003cc0c2e45b21bc6b3e","title":"Mybatis","content":"入门_MyBatis中文网(Mybatis.pdf)什么是Mybatis？\nMybatis是一款优秀的持久层框架，用于简化JDBC开发\n官网：https://mybatis.org/mybatis-3/zh/index.html\n\n持久层：\n\n负责将数据保存到数据库的那一层代码\n\nJavaEE三层架构：表现层，业务层，持久层\n\n\n框架：\n\n框架就是一个半成品软件，是一套可重用的、通用的、软件基础代码模型\n\n在框架的基础之上构建软件编写更加高效、规范、通用、可扩展\n\n\n\n快速入门\nJDBC写的是硬编码，后期维护很麻烦，无论是增删改查语句的修改，或者是用户名密码的改变，\nMyBatis虽然麻烦，不过很多步骤只做一次，后期维护非常的方便\n解决SQL映射文件的警告提示产生原因：IDEA和数据库没有建立连接，不识别表信息\n解决方法：在IDEA中配置MySQL数据库连接\n\n\nMapper代理开发\n目的\n1.解决原生方式中的硬编码\n2.简化后期执行SQL\n\n步骤\n1.定义与SQL映射文件同名的Mapper接口，并且将Mapper接口和SQL映射文件放置在同一目录下\n2.设置SQL映射文件的namespace属性为Mapper接口全限定名\n3.在Mapper接口中定义方法，方法名就是SQL映射文件中sql语句的id，并保持参数类型和返回值类型一致\n4.编码\n\n通过SqlSession的getMapper方法获取Mapper接口的代理对象\n调用对应方法完成sql的执行\n\n\n细节\n如果Mapper接口名称和SQL映射文件名称相同，并在同一目录下，则可以使用包扫描的方式简化SQL映射文件的加载\n&lt;mappers&gt;\n&lt;!--        加载sql映射文件--&gt;\n&lt;!--        &lt;mapper resource&#x3D;&quot;UserMapper.xml&quot;&#x2F;&gt;--&gt;\n&lt;!--        Mapper代理方式--&gt;\n        &lt;package name&#x3D;&quot;com.itheima.mapper&quot;&#x2F;&gt;\n    &lt;&#x2F;mappers&gt;\n\nMybatis核心配置文件详解\n注解完成增删改查\n注解即在接口方法上直接写SQL语句，不用在xml文件中再配置\n配置文件完成增删改查起别名\n定义&lt;sql&gt;片段\n定义&lt;resultMap&gt;片段\n注意事项\n参数占位符\n\n​      #{}: 执行SQL时，会将#{}占位符替换为?，将来自动设置参数值\n​      ${}: 拼SQL。会存在SQL注入问题\n​      使用时机：\n​      参数传递，都是用#{}\n​      如果要对表名，列名进行动态设置，只能使用${}进行sql拼接\n2.parameterType\n​\t\t用于设置参数类型，该参数可以省略\n3.SQL语句中特殊字符处理\n​\t转义字符\n&lt;![CDATA[内容]]&gt;\n动态SQLif标签：用于判断参数是否有值，使用test属性进行条件判断\n\n存在的问题：第一个条件不需要逻辑运算符\n\n解决方案：\n\n使用恒等式让所有条件格式都一样\n&lt;select id&#x3D;&quot;selectByCondition&quot; resultMap&#x3D;&quot;brandResultMap&quot;&gt;\n        select *\n        from tb_brand\nwhere 1 &#x3D; 1\n        &lt;if test&#x3D;&quot;status !&#x3D; null&quot;&gt;and status &#x3D; #&#123;status&#125;&lt;&#x2F;if&gt;\n        &lt;if test&#x3D;&quot;companyName !&#x3D; null and companyName !&#x3D; &#39;&#39;&quot;&gt;and company_name like #&#123;companyName&lt;&#x2F;if&gt;\n        &lt;if test&#x3D;&quot;brandName !&#x3D; null and brandName !&#x3D; &#39;&#39;&quot;&gt;and brand_name like #&#123;brandName&#125;&lt;&#x2F;if&gt;\n\n    &lt;&#x2F;select&gt;\n\n\n\n&lt;where&gt;标签替换where关键字\n&lt;select id&#x3D;&quot;selectByCondition&quot; resultMap&#x3D;&quot;brandResultMap&quot;&gt;\n        select *\n        from tb_brand\n&lt;where&gt;\n        &lt;if test&#x3D;&quot;status !&#x3D; null&quot;&gt; status &#x3D; #&#123;status&#125;&lt;&#x2F;if&gt;\n        &lt;if test&#x3D;&quot;companyName !&#x3D; null and companyName !&#x3D; &#39;&#39;&quot;&gt;and company_name like #&#123;companyName&lt;&#x2F;if&gt;\n        &lt;if test&#x3D;&quot;brandName !&#x3D; null and brandName !&#x3D; &#39;&#39;&quot;&gt;and brand_name like #&#123;brandName&#125;&lt;&#x2F;if&gt;&lt;&#x2F;where&gt;\n\n    &lt;&#x2F;select&gt;\n\n\n\n\n事务提交自动提交\nSqlSession sqlSession &#x3D; sqlSessionFactory.openSession(true);\n\n手动提交\nSqlSession sqlSession &#x3D; sqlSessionFactory.openSession();\n或\nSqlSession sqlSession &#x3D; sqlSessionFactory.openSession(false);\n\n事务后写sqlSession.commit();\n\n\n\n返回添加数据的主键\n&lt;insert useGeneratedKeys &#x3D; &quot;true&quot; keyProperty &#x3D; &quot;id&quot;&gt; \n\n\n\n\n\n上图（批量删除） 如果接口方法未加param注解，collection属性的值应该为array\n参数传递  \n参数封装\n\nMyBatis 参数封装：\n   单个参数：\n      1. POJO类型：直接使用，属性名 和 参数占位符名称 一致\n      2. Map集合：直接使用，键名 和 参数占位符名称 一致\n      3. Collection：封装为Map集合，可以使用@Param注解，替换Map集合中默认的arg键名\n          map.put(&quot;arg0&quot;,collection集合);\n          map.put(&quot;collection&quot;,collection集合);\n      4. List：封装为Map集合，可以使用@Param注解，替换Map集合中默认的arg键名\n          map.put(&quot;arg0&quot;,list集合);\n          map.put(&quot;collection&quot;,list集合);\n          map.put(&quot;list&quot;,list集合);\n      5. Array：封装为Map集合，可以使用@Param注解，替换Map集合中默认的arg键名\n          map.put(&quot;arg0&quot;,数组);\n          map.put(&quot;array&quot;,数组);\n      6. 其他类型：直接使用\n   多个参数：封装为Map集合,可以使用@Param注解，替换Map集合中默认的arg键名\n      map.put(&quot;arg0&quot;,参数值1)\n      map.put(&quot;param1&quot;,参数值1)\n      map.put(&quot;param2&quot;,参数值2)\n      map.put(&quot;agr1&quot;,参数值2)\n      ---------------@Param(&quot;username&quot;)\n      map.put(&quot;username&quot;,参数值1)\n      map.put(&quot;param1&quot;,参数值1)\n      map.put(&quot;param2&quot;,参数值2)\n      map.put(&quot;agr1&quot;,参数值2)\n\n \n\n\n使用中出现的问题（注意）\n不加@Param注解，取值的时候直接写属性\n\npublic void addUser(User user);\n&lt;insert id&#x3D;&quot;addUser&quot; parameterType&#x3D;&quot;com.xxxx.mybatis.entity.User&quot;&gt;\n    insert into user(id,user_name,name,birthday,age)\n    values (#&#123;id&#125;,#&#123;userName&#125;,#&#123;name&#125;,#&#123;birthday&#125;,#&#123;age&#125;)\n&lt;&#x2F;insert&gt;\n\n\n加了@Param注解，取值必须使用对象.属性的方式\n\npublic void addUser(@Param(&quot;user&quot;) User user);\n&lt;insert id&#x3D;&quot;addUser&quot; parameterType&#x3D;&quot;com.xxxx.mybatis.entity.User&quot;&gt;\n    insert into user(id,user_name,name,birthday,age)\n    values (#&#123;user.id&#125;,#&#123;user.userName&#125;,#&#123;user.name&#125;,#&#123;user.birthday&#125;,#&#123;user.age&#125;)\n&lt;&#x2F;insert&gt;\n","slug":"Mybatis","date":"2022-06-07T08:06:27.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"6f4f974e39a23a6637b9ccfa82544a76","title":"Maven","content":"\nMaven是专门用于管理和构建java项目的工具\n\nMaven的功能\n\n1、提供了一套标准化的项目结构\n\n2、提供了一套标准化的构建流程（编译，测试，打包，发布……）\n\n3、提供了一套依赖管理机制\n\n模型\n\n常见命令\ncompile 编译\nclean 清理\ntest 测试\npackage 打包\ninstall 安装\n\nIDEA配置Maven\nMaven坐标详解\n什么是坐标：\n\nMaven中的坐标是资源的唯一标识\n\n使用坐标来定义项目或引入项目中需要的依赖\n\n\n\nMaven坐标的主要组成\n\ngroupld：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima）\nartifactld：定义当前Maven项目名称（通常是模块名称）\nversion：定义当前项目版本号\n\n\n\n\nIDEA创建Maven项目\n依赖管理使用坐标导入jar包1.在pom.xml中编写&lt;dependencies&gt;标签\n2.在&lt;dependencies&gt;标签中 使用&lt;dependency&gt;引入坐标\n3.定义坐标的groupid，artifactld，version\n4.点击刷新按钮，使坐标生效(建议配置自动生效，无需刷新)\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;\n      &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;\n      &lt;version&gt;4.11&lt;&#x2F;version&gt;\n      &lt;scope&gt;test&lt;&#x2F;scope&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;\n      &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;\n      &lt;version&gt;5.1.48&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n  &lt;&#x2F;dependencies&gt;\n\n\n依赖范围 \n","slug":"Maven","date":"2022-05-18T08:50:49.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"f83fade08690f69bc32eef72fe024ed9","title":"JDBC总结","content":"JDBC快速入门\t(JDBC.pdf)1、编写代码步骤1、创建工程,导入驱动jar包\n jar包\n2、注册驱动Class.forName(&quot;com.mysql.jdbc.Driver&quot;);\n\n3、获取连接Connection conn &#x3D; DriverMannager.getConnection(url,username,password);\n\n4、定义SQL语句String sql &#x3D; &quot;&quot;;\n\n5、获取执行SQL的对象Statement stmt &#x3D; conn.createStatement();\n\n6、执行SQL语句stmt.executeUpdate(sql);  \n&#x2F;&#x2F;此方法会执行sql语句并返回受影响的行数。可以用\nint count &#x3D; stmt.executeUpdate(sql)接受返回值;\n\n7、处理返回结果8、释放资源stmt.close();\nconn.cloes();\n\n例\nAPI详解1、DriverManager1、注册驱动*** MYSQL 5之后的驱动包，可以省略注册驱动的步骤***\n\n这个方法可以完成驱动的注册，但是实际开发中一般不会使用这个方法完成驱动的注册\n原因：\n如果需要注册驱动，就会使用，DriverManager.registerDriver(new Driver()); ,但是查看源代码发现，在代码中一段静态代码块，静态代码块已经调用了注册驱动的方法。\n\n如果再手动调用该方法注册驱动，就会导致驱动被注册两次。实际开发中一般户次爱用;\nClass.forName(&quot;com.mysql.jdbc.Driver&quot;);\n\n2、获得与数据库的连接\n这个方法就是用来获得与数据库连接的方法，这个方法中的三个参数为 与数据库连接的路径(url)，与数据库连接的用户名(user)，与数据库连接的密码(password)。\n主要是url的写法：\njdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;db1\n\njdbc:mysql:&#x2F;&#x2F;ip地址:端口号&#x2F;数据库名称?参数键值对1&amp;参数键值对2...\n\nlocalhost           :连接的MySQL数据库服务器的主机ip地址。（连接是本机就可以写成localhost），如果连接不是本机的，就需要写上连接主机的IP地址。\nurl如果连接的是本机的路径，可以简化为如下格式：\njdbc:mysql:&#x2F;&#x2F;&#x2F;db1\n配置useSSL &#x3D; false 参数，禁用安全连接方式，解决警告提示\n2、Connection1、获取执行SQL对象普通执行SQL对象\nStatement createStatement();\n\n 预编译SQL的执行SQL对象；防止SQL注入\nPreparedStatement prepareStatement(sql);\n\n执行存储过程的对象\nCallableStatement prepareCall(sql)\n\n2、事务管理MYSQL事务管理开启事务：  begin;&#x2F;start transaction;\n提交事务：  commit;\n回滚事务：  rollback;\n\nMYSQL默认自动提交事务\n\nJDBC事务管理Connection接口中定义了3个对应的方法\n开启事务：setAutoCommit(bollean autoCommit): true为自动提交事务；false为手动提交事务，即为开启事务\n提交事务：commit()\n回滚事务：rollback()\n\n例：\npackage com.itheima.jdbc;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n&#x2F;**\n * JDBC API 详解：Connection\n *&#x2F;\npublic class JDBCDemo3_Connection &#123;\n\n    public static void main(String[] args) throws Exception &#123;\n        &#x2F;&#x2F;1. 注册驱动\n        &#x2F;&#x2F;Class.forName(&quot;com.mysql.jdbc.Driver&quot;);\n        &#x2F;&#x2F;2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写\n        String url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;db1?useSSL&#x3D;false&quot;;\n        String username &#x3D; &quot;root&quot;;\n        String password &#x3D; &quot;1234&quot;;\n        Connection conn &#x3D; DriverManager.getConnection(url, username, password);\n        &#x2F;&#x2F;3. 定义sql\n        String sql1 &#x3D; &quot;update account set money &#x3D; 3000 where id &#x3D; 1&quot;;\n        String sql2 &#x3D; &quot;update account set money &#x3D; 3000 where id &#x3D; 2&quot;;\n        &#x2F;&#x2F;4. 获取执行sql的对象 Statement\n        Statement stmt &#x3D; conn.createStatement();\n\n        try &#123;\n            &#x2F;&#x2F; 开启事务\n            conn.setAutoCommit(false);\n            &#x2F;&#x2F;5. 执行sql\n            int count1 &#x3D; stmt.executeUpdate(sql1);&#x2F;&#x2F;受影响的行数\n            &#x2F;&#x2F;6. 处理结果\n            System.out.println(count1);\n            int i &#x3D; 3&#x2F;0;\n            &#x2F;&#x2F;5. 执行sql\n            int count2 &#x3D; stmt.executeUpdate(sql2);&#x2F;&#x2F;受影响的行数\n            &#x2F;&#x2F;6. 处理结果\n            System.out.println(count2);\n\n            &#x2F;&#x2F; 提交事务\n            conn.commit();\n        &#125; catch (Exception throwables) &#123;\n            &#x2F;&#x2F; 回滚事务\n            conn.rollback();\n            throwables.printStackTrace();\n        &#125;\n\n\n\n        &#x2F;&#x2F;7. 释放资源\n        stmt.close();\n        conn.close();\n    &#125;\n&#125;\n\n3、Statement1、执行SQL语句int executeUpdate(sql):执行DML、DDL语句\n返回值（1）DML语句影响的行数（2）DDL语句执行后，执行成功也可能返回0\n\nResultSet executeQuery(sql):执行DQL语句\n返回值：Result结果集对象\n\n4、ResultSet封装了DQL查询语句的结果ResultSet stmt.executeQuery(sql); 执行DQL语句，返回ResultSet对象\n\n获取查询结果boolean next(): (1)将光标从当前位置向前移动一行 (2)判断当前行是否为有效行\n返回值 true：有效行，当前行有数据   false：无效行，当前行没有数据\n\nxxx getXxx(参数):获取数据\nxxx：数据类型，如 ： int getInt(参数) String getString(参数)\n参数：int： 列的编号，从1开始\n\t string：列的名称\n\n使用步骤1、游标向下移动一行，并判断该行是否有数据：next()\n2 、获取数据：getXxx(参数)\n&#x2F;&#x2F;循环判断游标是否是最后一行末尾\nwhile(rs.next())\n&#123;\n\t&#x2F;&#x2F;获取数据\n\trs.getXxx(参数);\n&#125;\n\n5、PreparedStatement作用：预编译SQL语句并执行，防止SQL注入问题如：用户名随便写，密码写成’ or ‘ 1 ‘ &#x3D; ‘1\n用法：1、获取PreparedStatement对象&#x2F;&#x2F;SQL语句中的参数值，使用？占位符替代\nString sql &#x3D; &quot;select * from user where username &#x3D; ? and password &#x3D; ？&quot;;\n&#x2F;&#x2F;通过Connection对象获取，并传入对应的SQL语句\nPreparedStatement pstmt &#x3D; conn.prepareStatement(sql);\n\n2、设置参数值PreparedStatement对象:setXxx(参数1,参数2):给？赋值\nXxx:数据类型，如setInt(参数1,参数2)\n参数：\n参数1：？的位置编号，从1开始\n参数2：？的值\n\n3、执行SQLexecuteUpdate();&#x2F;executeQuery(); :不需要再传递sql\n\n\n\n例public class JDBCDemo7_PreparedStatement &#123;\n\n    @Test\n    public void testPreparedStatement() throws  Exception &#123;\n       &#x2F;&#x2F;2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写\n       String url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;db1?useSSL&#x3D;false&quot;;\n       String username &#x3D; &quot;root&quot;;\n       String password &#x3D; &quot;1234&quot;;\n       Connection conn &#x3D; DriverManager.getConnection(url, username, password);\n\n       &#x2F;&#x2F; 接收用户输入 用户名和密码\n        String name &#x3D; &quot;zhangsan&quot;;\n        String pwd &#x3D; &quot;&#39; or &#39;1&#39; &#x3D; &#39;1&quot;;\n\n        &#x2F;&#x2F; 定义sql\n        String sql &#x3D; &quot;select * from tb_user where username &#x3D; ? and password &#x3D; ?&quot;;\n\n        &#x2F;&#x2F; 获取pstmt对象\n        PreparedStatement pstmt &#x3D; conn.prepareStatement(sql);\n\n        &#x2F;&#x2F; 设置？的值\n        pstmt.setString(1,name);\n        pstmt.setString(2,pwd);\n\n        &#x2F;&#x2F; 执行sql\n        ResultSet rs &#x3D; pstmt.executeQuery();\n\n        &#x2F;&#x2F; 判断登录是否成功\n        if(rs.next())&#123;\n            System.out.println(&quot;登录成功~&quot;);\n        &#125;else&#123;\n            System.out.println(&quot;登录失败~&quot;);\n        &#125;\n\n        &#x2F;&#x2F;7. 释放资源\n        rs.close();\n        pstmt.close();\n        conn.close();\n    &#125;\n\n好处：1、预编译SQL，性能更高\n2、防止SQL注入，将敏感字符进行转义\nPreparedStatement预编译功能开启：useServerPrepStmts&#x3D;true\n（参数键值对）应加在URL最后\n配置MySQL执行日志（重启mysql服务后生效）\nlog-output&#x3D;FILE\ngeneral-log&#x3D;1\ngeneral_log_file&#x3D;&quot;D:\\mysql.log&quot;\nslow-query-log&#x3D;1\nslow_query_log_file&#x3D;&quot;D:\\mysql_slow.log&quot;\nlong_query_time&#x3D;2\n\n原理：1、在获取PreparedStatement对象时，将sql语句发送给mysql服务器进行检查，编译（这些步骤很耗时）\n2、执行时就不用再进行这些步骤了，速度更快\n3、如果sql模板一样，则只需要进行一次检查编译\n\n数据库连接池简介\n数据库连接池是个容器，负责分配，，管理数据库连接\n\n它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个\n\n释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏\n\n好处：\n\n资源重用\n\n提升系统响应速度\n\n避免数据库连接遗漏\n\n\n\n\n数据库连接池实现标准接口\n官方（SUN）提供的数据库连接池标准接口，由第三方组织实现此接口。\n功能：获取连接\n\nConnection getConnection()\n\n常见的数据库连接池：\nDBCP\nC3P0\nDruid\n\nDruid（德鲁伊）\nDruid连接池是阿里巴巴开源的数据库连接池项目\n功能强大，性能优秀，是Java语言最好的数据库连接池之一\n\n","slug":"JDBC总结","date":"2022-05-07T02:47:07.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"758e18fa21f3b95498a42a108b10694c","title":"SQL总结","content":"SQL通用语法1.SQL语句可以单行或多行书写，以分号结尾。\n2.MYSQL数据库的SQL语句不区分大小写，关键字建议适用大写。\n3.注释\n （1） 单行注释：– 注释内容（两个横杠一个空格+注释内容） 或 #注释内容（MYSQL特有)\n（2） 多行注释： &#x2F;* 注释 *&#x2F;\n对 MYSQL 的 windows命令1、启动mysql服务net start mysql 启动 mysql 服务\nnet stop mysql 关闭 mysql 服务\n\n2、进入mysql，输入密码：mysql -hlocalhost -uroot -proot 进入mysql数据库，其中-h表示服务器名，localhost表示本地；\n-u为数据库用户名，root是mysql默认用户名；-p为密码，如果设置了密码，可直接在-p后直接输入。\n\nmysql -u root -p;\n\n对数据库的操作1、查看所有数据库mysql&gt; show databases;\n\n2、创建数据库mysql&gt; create database 数据库名称\n如果数据库已经存在，则会报错\n可使用\nmysql&gt; create database if not exists; 数据库名称\n\n3、删除数据库drop database 数据库名称;\ndrop database if exists 数据库名称;\n\n4、使用数据库使用数据库 use 数据库名称;\n\n5、查看当前使用的数据库select database();\n\n对表的操作· 创建（create）\n·查询（retrieve）\n·修改（update）\n·删除（delete）\n1、创建（create）创建表create table 表名(\n\t\t字段名1 数据类型1,\n\t\t字段名2 数据类型2,\n\t\t...\n\t\t字段名n 数据类型n\n);\n\n最后一行末尾不能加逗号\n2、查询（retrieve）查询当前数据库下所有表名称show tables;\n\n查询表结构desc 表名称;\n\n3、修改（update）修改表名alter table 表名 rename to 新的表名;\n\n添加一列alter table 表名 add 列名 数据类型;\n\n修改数据类型alter table 表名 modify 列名 新数据类型;\n\n修改列名和数据类型alter table 表名 change 列名 新列名 新数据类型;\n\n删除列alter table 表名 drop 列名;\n\n\n\n4、删除（delete）删除表drop table 表名;\ndrop table if exists 表名;\n\n对数据的操作添加数据1、给指定列添加数据insert into 表名(列名1,列名2，...)values(值1,值2,...); \n\n2、给全部列添加数据insert into 表名 values(值1,值2,...);\n\n3、批量添加数据insert into 表名(列名1,列名2,...) values(值1,值2,...),(值1,值2,...),(值1,值2,...)...;\n\ninsert into 表名 values(值1,值2,...),(值1,值2,...),(值1,值2,...)...;\n\n修改数据1、修改表数据update 表名 set 列名1&#x3D;值1,列名2&#x3D;值2,...[where 条件];\n\n修改语句如果不加条件，则所有数据都将被修改!\n删除数据1、删除数据delete from 表名 [where 条件];\n\n删除语句如果不加条件，则所有数据都将被删除\n查询数据select\n\t字段列表\nfrom\n\t表名列表\nwhere\n\t条件列表\ngroup by\n\t分组字段\nhaving\n\t分组后条件\norder by\n\t排序字段\nlimit\n\t分页限定\n\n\n\n\n\n\n\n\n约束 \n外键约束\n数据库设计\n\n\n多表查询内连接隐式内连接\nselect 字段列表 from 表1,表2... where 条件;\n\n显式内连接\nselect 字段列表 from 表1 [inner] join 表2 on 条件；\n\n内连接相当于查询A B 交集数据\n外连接左外连接\nselect 字段列表 from 表1 left [outer] join 表2 on 条件；\n右外连接\nselect 字段列表 from 表1 right [outer] join 表2 on 条件；\n\n左外连接 ：相当于查询A表所有数据和交集部分数据\n右外连接 ：相当于查询B表所有数据和交集部分数据\n子查询子查询根据查询结果不同，作用不同;1、单行单列:作为条件值，使用&#x3D;,!&#x3D;,&gt;,&lt;等进行条件判断\nselect 字段列表 from 表 where 字段名 &#x3D; (子查询)；\n\n2、多行单列:作为条件值，使用in等关键字进行条件判断\nselect 字段列表 from 表 where 字段名 in (子查询)；\n\n 3、多行duolie:作为虚拟表\nselect 字段列表 from (子查询) where 条件；\n\n事物1、开启事务start transaction; 或者 begin;\n\n2、提交事务commit;\n\n3、回滚事务rollback;\n\n4、事务的特性\n5.事务提交mysql事务默认自动提交\n-- 查看事物的默认提交方式\nselect @@autocommit;\n-- 1 自动提交 0 手动提交\n-- 修改事务提交方式\nset @@autocommit &#x3D; 0;\n","slug":"SQL总结","date":"2022-04-30T08:59:10.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"a64b935a3dc12ce8d8b93a103ca9afe0","title":"java核心技术卷总结","content":"1.&amp;&amp;和|| 运算符是按照“短路”方式来求值的：如果第一个操作数已经能够确定表达式的值，第二个操作数就不必计算了。2.位移运算符的右操作数要完成模32的运算（除非左操作数是long类型，在这种情况下需要对右操作数模64）。例如，1&lt;&lt;35的值等同于1&lt;&lt;3或8。3.同一个级别的运算符按照从左到右的次序进行计算（但右结合运算符除外）&amp;&amp; 优先级大于 | | 。4.String类的substring方法可以从一个较大的字符串提取出一个子串。例如：    String greeting &#x3D; “Hello”;            String a &#x3D; greeting.substring(0,3);    打印 a 会输出    Hel。    即输出[a,b)。5.检测字符串是否相等string a &#x3D; “ok”;string b &#x3D; “ok”;a.equals(b)；“ok”.equals(“ok”);“ok”.equals(“b”);想要检测两个字符串是否相等，而不区分大小写，可用equalsIgnoreCase方法。“Hello”. equalsIgnoreCase(“hello”);6.一定不要使用&#x3D;&#x3D;来检测两个字符串是否相等!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! &#x3D;&#x3D;只能够确定两个字符串是否存放在同一位置上。当然，如果存放在同一位置上，它们必然相等。但是，完全有可能将内容相同的多个字符串副本放置在不同位置上。如果虚拟机始终将相同的字符串共享，就可以使用&#x3D;&#x3D;运算符检测是否相等。但实际上只有字符串字面量是共享的，而+或substring等操作得到的字符串并不共享。因此，千万不要视同&#x3D;&#x3D;运算符测试字符串的相等性！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！7.检查一个字符串既不是null也不是空串 if(str!&#x3D;null &amp;&amp; str.length()!&#x3D;0)。\n","slug":"java核心技术卷总结","date":"2022-04-25T11:48:12.000Z","categories_index":"","tags_index":"","author_index":"Aurora"}]