[{"id":"56c491e94a7396878a3a1e31f971413b","title":"计算机组成原理","content":"第一章1.21.2.1 冯诺依曼计算机的特点：\n计算机有哦运算器，存储器，控制器，输入设备和输出设备五大部件组成\n指令和数据以同等地位存放于存储器中，并可按地址寻访\n指令和数据均用二进制数表示\n指令由操作码和地址码组成，操作码用来表示操作的性质，地址码用来表示操作数在存储器中的位置\n指令在存储器内按顺序存放。通常，指令是顺序执行的，在特定条件下，可根据运算结果或根据设定的条件改变执行顺序\n机器以运算器为中心，输入输出设备与存储期间的数据传送通过运算器完成。\n\n相比于经典的冯诺依曼计算机的最后一个特点，现代的计算机已转化为以存储器为中心\n1.2.2 计算机的硬件框图计算机硬件各部件的功能：\n\n运算器用来完成算术运算和逻辑运算，并将运算的中间结果暂存在运算器内\n存储器用来存放数据和程序\n控制器用来控制，指挥程序和数据的输入，运行以及处理运算结果\n输入设备用来将人们熟悉的信息形式转化为机器能识别的信息形式，常见的有键盘，鼠标等\n输出设备可将机器运算结果转换为人们熟悉的信息形式，如打印机输出，显示器输出等\n\n计算机的五大部件（又称五大子系统）在控制器的统一指挥下，有条不紊的自动工作\n运算器和控制器合起来统称为中央处理器（CPU）\n输入设备与输出设备简称为I&#x2F;O设备\n现代计算机可认为由三大部分组成：CPU，I&#x2F;O设备，主存储器\nCPU和主存储器合起来可称为主机        I&#x2F;O设备又可称为外部设备\n算术逻辑单元（ALU）完成算术逻辑运算\n控制单元（CU）用来结束存储器中的指令，并发出各种操作命令来执行指令\n1.2.3 计算机的工作步骤","slug":"计算机组成原理","date":"2022-07-13T13:29:14.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"2d34257e8e68ae00ecf08b330efedcd5","title":"Web核心","content":"Web概述JavaWeb技术栈\nB&#x2F;S架构：Browser&#x2F;Server，浏览器&#x2F;服务器 架构模式，它的特点是，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web资源，服务器把Web资源发送给浏览器即可\n\n好处：易于维护升级：服务器升级苟，客户端无需任何不输就可以使用到新的版本\n\n\n静态资源：HTML  CSS  JavaScript  图片等。 负责页面展现\n\n动态资源：Servlet  Jsp等。 负责逻辑处理\n\n数据库：负责存储数据\n\n\n\nHTTP\n概念：HyperText  Transfer  Protocol， 超文本传输协议，规定了浏览器和服务器之间数据传输的规则\n\nHTTP协议特点：\n1.基于TCP协议：面向连接，安全\n2.基于请求-响应模型：一次请求对应一次响应\n3.HTTP协议是无状态的协议：对于事务处理没有记忆能力。每次请求-响应都是独立的\n\n缺点：多次请求间不能共享数据       Java中使用会话技术（Cookie、Session）来解决\n有点：速度快\n\n\n\n请求数据格式\n请求数据分为三部分：\n\n1.请求行：请求数据的第一行。其中GET表示请求方式，&#x2F;表示请求资源路径，HTTP&#x2F;1.1表示协议版本\n2.请求头：第二行开始，格式为key：value形式，常见的HTTP请求头有:\nHost: 表示请求的主机名\nUser-Agent: 浏览器版本,例如Chrome浏览器的标识类似Mozilla&#x2F;5.0 ...Chrome&#x2F;79，IE浏览器的标识类似Mozilla&#x2F;5.0 (Windows NT ...)like Gecko；\nAccept：表示浏览器能接收的资源类型，如text&#x2F;*，image&#x2F;*或者*&#x2F;*表示所有；\nAccept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页；\nAccept-Encoding：表示浏览器可以支持的压缩类型，例如gzip, deflate等。\n\n3.请求体：POST请求的最后一部分，存放请求参数\n\n\n响应数据格式\n1.响应行：响应数据的第一行。其中HTTP&#x2F;1.1表示协议版本，200表示响应状态码，OK表示状态码描述\n\n2.响应头：第二行开始，格式为key：value形式，常见的HTTP响应头有:\nContent-Type：表示该响应内容的类型，例如text&#x2F;html，image&#x2F;jpeg；\nContent-Length：表示该响应内容的长度（字节数）；\nContent-Encoding：表示该响应压缩算法，例如gzip；\nCache-Control：指示客户端应如何缓存，例如max-age&#x3D;300表示可以最多缓存300秒\n\n3.响应体：最后一部分。存放相应数据\n\n\n\n一、状态码大类\n\n\n状态码分类\n说明\n\n\n\n1xx\n响应中——临时状态码，表示请求已经接受，告诉客户端应该继续请求或者如果它已经完成则忽略它\n\n\n2xx\n成功——表示请求已经被成功接收，处理已完成\n\n\n3xx\n重定向——重定向到其它地方：它让客户端再发起一个请求以完成整个处理。\n\n\n4xx\n客户端错误——处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等\n\n\n5xx\n服务器端错误——处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等\n\n\n状态码大全：https://cloud.tencent.com/developer/chapter/13553 \n二、常见的响应状态码\n\n\n状态码\n英文描述\n解释\n\n\n\n200\nOK\n客户端请求成功，即处理成功，这是我们最想看到的状态码\n\n\n302\nFound\n指示所请求的资源已移动到由Location响应头给定的 URL，浏览器会自动重新访问到这个页面\n\n\n304\nNot Modified\n告诉客户端，你请求的资源至上次取得后，服务端并未更改，你直接用你本地缓存吧。隐式重定向\n\n\n400\nBad Request\n客户端请求有语法错误，不能被服务器所理解\n\n\n403\nForbidden\n服务器收到请求，但是拒绝提供服务，比如：没有权限访问相关资源\n\n\n404\nNot Found\n请求资源不存在，一般是URL输入有误，或者网站资源被删除了\n\n\n428\nPrecondition Required\n服务器要求有条件的请求，告诉客户端要想访问该资源，必须携带特定的请求头\n\n\n429\nToo Many Requests\n太多请求，可以限制客户端请求某个资源的数量，配合 Retry-After(多长时间后可以请求)响应头一起使用\n\n\n431\n Request Header Fields Too Large\n请求头太大，服务器不愿意处理请求，因为它的头部字段太大。请求可以在减少请求头域的大小后重新提交。\n\n\n405\nMethod Not Allowed\n请求方式有误，比如应该用GET请求方式的资源，用了POST\n\n\n500\nInternal Server Error\n服务器发生不可预期的错误。服务器出异常了，赶紧看日志去吧\n\n\n503\nService Unavailable\n服务器尚未准备好处理请求，服务器刚刚启动，还未初始化好\n\n\n511\nNetwork Authentication Required\n客户端需要进行身份验证才能获得网络访问权限\n\n\nTomcatWeb服务器是一个应用程序（软件），对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作，让开发更加便捷，主要功能是提供网上信息浏览服务 \n作用：\n\n封装HTTP协议操作，简化开发\n可以将web项目部署到服务器中，对外提供网上浏览服务\n\nTomcat是一个轻量级的Web服务器，支持Servlet&#x2F;JSP少量JavaEE规范，也称为Web服务器，Servlet容器\n基本使用\n部署项目\nIDEA中创建Maven Web项目项目结构：\n创建方法1、\n2、\nIDEA集成本地Tomcat\nIDEA中使用Tomcat - Tomcat Maven插件1.pom.xml添加Tomcat插件\n&lt;build&gt;\n    &lt;plugins&gt;\n    \t&lt;!--Tomcat插件 --&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.apache.tomcat.maven&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;tomcat7-maven-plugin&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;2.2&lt;&#x2F;version&gt;\n        &lt;&#x2F;plugin&gt;\n    &lt;&#x2F;plugins&gt;\n&lt;&#x2F;build&gt;\n\n2.使用Maven Helper 插件快速启动项目，选中项目，右键 Run Maven –&gt; tomcat7:run\nServlet\nServlet是java提供的一门动态Web资源开发技术\nServlet是javaEE规范之一，其实就是一个接口，将来我们要定义Servlet类来访问Servlet接口，并由web服务器运行Servlet\n\nServlet快速入门1.创建一个项目，导入Servlet依赖坐标\n&lt;dependency&gt;\n    &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;javax.servlet-api&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;3.1.0&lt;&#x2F;version&gt;\n    &lt;!--\n      此处为什么需要添加该标签?\n      provided指的是在编译和测试过程中有效,最后生成的war包时不会加入\n       因为Tomcat的lib目录中已经有servlet-api这个jar包，如果在生成war包的时候生效就会和Tomcat中的jar包冲突，导致报错\n    --&gt;\n    &lt;scope&gt;provided&lt;&#x2F;scope&gt;\n&lt;&#x2F;dependency&gt;\n\n\n\n2.创建：定义一个类，实现Servlet接口，并重写接口中的所有方法，并在service方法中输入一句话\npackage com.itheima.web;\n\nimport javax.servlet.*;\nimport java.io.IOException;\n\npublic class ServletDemo1 implements Servlet &#123;\n\n    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;\n        System.out.println(&quot;servlet hello world~&quot;);\n    &#125;\n    public void init(ServletConfig servletConfig) throws ServletException &#123;\n\n    &#125;\n\n    public ServletConfig getServletConfig() &#123;\n        return null;\n    &#125;\n\n    public String getServletInfo() &#123;\n        return null;\n    &#125;\n\n    public void destroy() &#123;\n\n    &#125;\n&#125;\n\n\n\n3.配置: 在类上使用@WebServlet注解，配置该Servlet的访问路径\n@WebServlet(&quot;&#x2F;demo1&quot;)\n\n\n\n4.访问:启动Tomcat，浏览器输入URL访问该Servlet\nhttp:&#x2F;&#x2F;localhost:8080&#x2F;web-demo&#x2F;demo1\n\nServlet执行流程Servlet生命周期\n对象的生命周期指一个对象从被创建到被销毁的整个过程\n\nServlet运行在Servlet容器（Web服务器）中，其生命周期由容器来管理，分为4个阶段\n1.加载和实例化：默认情况下，当Servlet第一次被访问时，其容器创建Servlet对象\n\n\n\t\n默认情况，Servlet会在第一次访问被容器创建，但是如果创建Servlet比较耗时的话，\n那么第一个访问的人等待的时间就比较长，用户的体验就比较差，\n那么我们能不能把Servlet的创建放到服务器启动的时候来创建，具体如何来配置?\n\n@WebServlet(urlPatterns &#x3D; &quot;&#x2F;demo1&quot;,loadOnStartup &#x3D; 1)\nloadOnstartup的取值有两类情况\n（1）负整数:第一次访问时创建Servlet对象\n（2）0或正整数:服务器启动时创建Servlet对象，数字越小优先级越高\n\n2.初始化：在Servlet实例化之后，容器将调用Servlet的init()方法来初始化这个对象，完成一些如加载配置文件、创建连接等初始化的工作。该方法只调用一次\n3.请求处理：每次请求Servlet时，Servlet容器都会调用Servlet的service()方法对请求进行处理\n4.服务终止：当需要释放内存或容器关闭时，容器就会调用Servlet实例的destory()方法完成资源的释放。在destory()方法调用之后，容器会释放这个Servlet实例，该实例随后会被java的垃圾收集器所回收\nServlet方法介绍\n初始化方法，在Servlet被创建时执行，只执行一次\n\nvoid init(ServletConfig config) \n\n\n提供服务方法， 每次Servlet被访问，都会调用该方法\n\nvoid service(ServletRequest req, ServletResponse res)\n\n\n销毁方法，当Servlet被销毁时，调用该方法。在内存释放或服务器关闭时销毁Servlet\n\nvoid destroy() \n\n剩下的两个方法是:\n\n获取Servlet信息\n\nString getServletInfo() \n&#x2F;&#x2F;该方法用来返回Servlet的相关信息，没有什么太大的用处，一般我们返回一个空字符串即可\npublic String getServletInfo() &#123;\n    return &quot;&quot;;\n&#125;\n\n\n获取ServletConfig对象\n\nServletConfig getServletConfig()\n\nServlet体系结构\n我们将来开发B&#x2F;S架构的web项目，都是针对HTTP协议，所以我们自定义Servlet，会继承HttpServlet\n\nHttpServlet使用步骤\n\n继承HttpServlet\n重写doGet和doPost方法\n\n\nHttpServlet原理\n获取请求方式，并根据不同的请求方式，调用不同的doXxx方法。\n\n\nServlet urlPattern配置\n优先级：1&gt;2&gt;3&gt;&#x2F;*&gt;&#x2F;\nXML配置Servlet前面对应Servlet的配置，我们都使用的是@WebServlet,这个是Servlet从3.0版本后开始支持注解配置，3.0版本前只支持XML配置文件的配置方法。\n对于XML的配置步骤有两步:\n\n编写Servlet类\n\n在web.xml中配置该Servlet 代码如下：\n&lt;servlet&gt;\n       &lt;!-- servlet的名称，名字任意--&gt;\n       &lt;servlet-name&gt;demo13&lt;&#x2F;servlet-name&gt;\n       &lt;!--servlet的类全名--&gt;\n       &lt;servlet-class&gt;com.itheima.web.ServletDemo13&lt;&#x2F;servlet-class&gt;\n   &lt;&#x2F;servlet&gt;\n  \n   &lt;!-- \n       Servlet 访问路径\n   --&gt;\n   &lt;servlet-mapping&gt;\n       &lt;!-- servlet的名称，要和上面的名称一致--&gt;\n       &lt;servlet-name&gt;demo13&lt;&#x2F;servlet-name&gt;\n       &lt;!-- servlet的访问路径--&gt;\n       &lt;url-pattern&gt;&#x2F;demo13&lt;&#x2F;url-pattern&gt;\n   &lt;&#x2F;servlet-mapping&gt;\n\nRequestRequest继承体系\nRequest获取数据请求参数HTTP请求数据总共分为三部分内容，分别是  请求行、请求头、请求体\nRequest获取请求行数据请求行包含三块内容，分别是请求方式、请求资源路径、HTTP协议及版本\n\n对于这三部分内容，request对象都提供了对应的API方法来获取，具体如下:\n\n获取请求方式GET\n\nString getMethod()\n\n\n获取虚拟目录（项目访问路径）/request-demo\n\nSting getContextPath()\n\n\n获取URL（统一资源定位符）https://localhost:8080/request-demo/req1\n\nStringBuffer getRequestURL()\n\n\n获取URI(统一资源标识符)request-demo/req1\n\nString getRequestURI()\n\n\n获取请求参数(GET方式)username=zhangsan&amp;password=123\n\nSting getQueryString()\n\n例：\n&#x2F;**\n * request 获取请求数据\n *&#x2F;\n@WebServlet(&quot;&#x2F;req1&quot;)\npublic class RequestDemo1 extends HttpServlet &#123;\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        &#x2F;&#x2F; String getMethod()：获取请求方式： GET\n        String method &#x3D; req.getMethod();\n        System.out.println(method);&#x2F;&#x2F;GET\n        &#x2F;&#x2F; String getContextPath()：获取虚拟目录(项目访问路径)：&#x2F;request-demo\n        String contextPath &#x3D; req.getContextPath();\n        System.out.println(contextPath);\n        &#x2F;&#x2F; StringBuffer getRequestURL(): 获取URL(统一资源定位符)：http:&#x2F;&#x2F;localhost:8080&#x2F;request-demo&#x2F;req1\n        StringBuffer url &#x3D; req.getRequestURL();\n        System.out.println(url.toString());\n        &#x2F;&#x2F; String getRequestURI()：获取URI(统一资源标识符)： &#x2F;request-demo&#x2F;req1\n        String uri &#x3D; req.getRequestURI();\n        System.out.println(uri);\n        &#x2F;&#x2F; String getQueryString()：获取请求参数（GET方式）： username&#x3D;zhangsan\n        String queryString &#x3D; req.getQueryString();\n        System.out.println(queryString);\n    &#125;\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n    &#125;\n&#125;\n\n获取请求头数据对于请求头的数据，格式为key: value如下：\n\n所以根据请求头名称获取对应值的方法为:\nString getHeader(String name)\n\n获取请求体数据浏览器在发送GET请求的时候是没有请求体的，所以需要把请求方式变更为POST，请求体中的数据格式如下:\n\n\n获取字节输入流，如果前端发送的是字节数据，比如传递的是文件数据，则使用该方法\n\nServletInputStream getInputStream()\n该方法可以获取字节\n\n\n获取字符输入流，如果前端发送的是纯文本数据，则使用该方法\n\nBufferedReader getReader()\n\n\n\n具体实现的步骤如下:\n1.准备一个页面，在页面中添加form表单,用来发送post请求\n2.在Servlet的doPost方法中获取请求体数据\n3.在doPost方法中使用request的getReader()或者getInputStream()来获取\n4.访问测试\n获取请求参数的通用方式\n\n获取所有参数Map集合\n\nMap&lt;String,String[]&gt; getParameterMap()\n\n\n根据名称获取参数值（数组）\n\nString[] getParameterValues(String name)\n\n\n根据名称获取参数值(单个值)\n\nString getParameter(String name)\n\npublic class RequestDemo1 extends HttpServlet &#123;\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n       &#x2F;&#x2F;采用request提供的获取请求参数的通用方式来获取请求参数\n       &#x2F;&#x2F;编写其他的业务代码...\n    &#125;\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        this.doGet(req,resp);\n    &#125;\n&#125;\n\n请求参数中文乱码处理\n请求参数如果存在中文数据，则会乱码\n\n解决方案：\n\nPOST:设置输入流的编码\nreq.setCharacterEncoding(&quot;UTF-8&quot;);\n\n通用方式（GET&#x2F;POST）：先编码，再解码\nnew String(username.getBytes(&quot;ISO-8859-\t1&quot;),&quot;UTF-8&quot;);\n\n\n\nRequest请求转发\n请求转发：一种在服务器的内部资源跳转方式\n\n\n\n实现方式：\nreq.getRequestDispatcher(&quot;资源B路径&quot;).forward(req,resp);\n\n请求转发资源间共享数据:使用Request对象\n\nvoid setAttribute(String name, Object o)：存储数据到request域中\nObject getAttribute(String name)：根据key，获取值\nvoid removAttribute(String name)：根据key，删除该键值对\n\n\n请求转发特点：\n\n浏览器地址栏领不发生变化\n只能转发到当前服务器的内部资源\n一次请求，可以在转发的资源间使用requset共享数据\n\n\n\nResponseResponse设置响应数据功能介绍\n响应数据分为3部分：\n\n响应行：\nHTTP&#x2F;1.1 200 OK\n\nvoid setStatus(int sc): 设置响应状态码\n\n响应头：\nContent-Type:text&#x2F;html\n\nvoid setHeader(String name, String value):设置响应头键值对\n\n响应体：\n&lt;html&gt;\n\t&lt;head&gt;\n\t\n\t&lt;head&gt;\n\t\n\t&lt;body&gt;\n\t\n\t&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\nprintWriter getWriter(): 获取字符输出流\nServletOutputStream getOutputStream():获取字节输出流\n\n\n\n\nResponse完成重定向\n重定向：一种资源跳转方式\n\n​\t\n资源路径问题\n建议动态获取虚拟目录：String contextPath &#x3D; request.getContextPath();\n重定向：response.sendRedirect(contextPath + “&#x2F;resp2”);\nResponse响应字符数据\n使用：\n1.通过Response对象获取字符输入流\nPrintWriter writer &#x3D; response.getWriter();\n\n2.写数据\nwriter.write(&quot;aaa&quot;);\n\n注意：\n\n该流不需要关闭，随着响应结束，Response对象销毁，由服务器关闭\n\n中文数据乱码：原因通过获取的字符输出流默认编码：ISO-8859-1\nresp.setContentType(&quot;text&#x2F;html;charset&#x3D;utf-8&quot;);\n\n\n\nResponse响应字节数据\n使用：\n1.通过Response对象获取字符输入流\nServletOutputStream outputStream &#x3D; resp.getOutputStream();\n\n2.写数据\noutputStream.write(字节数据);\n\nIOUtils工具类使用\n1.导入坐标\n&lt;dependency&gt;\n\t&lt;groupid&gt;commons-io&lt;&#x2F;groupid&gt;\n    &lt;artifactld&gt;commons-io&lt;&#x2F;artifactld&gt;\n    &lt;version&gt;2.6&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n2.使用\nIOUtils.copy(输入流，输出流);\n\nSqlSessionFactory代码优化String resource &#x3D; &quot;org&#x2F;mybatis&#x2F;example&#x2F;mybatis-config.xml&quot;;\nInputStream inputStream &#x3D; Resources.getResourceAsStream(resource);\nSqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);\n\n问题： \n​\t1.代码重复：       解决（工具类)\n​\t2.SqlSessionFactory工厂只创建一次，不要重复创建：  解决（静态代码块）\n我创建的工具类：\npackage com.itheima.util;\n\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\npublic class SqlSessionFactoryUtils &#123;\n    private static  SqlSessionFactory sqlSessionFactory;\n\n    static &#123;\n        &#x2F;&#x2F;静态代码块会随着类的加载自动执行，且只执行一次\n        try &#123;\n            String resource &#x3D; &quot;mybatis-config.xml&quot;;\n            InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);\n            SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);\n        &#125; catch (IOException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n    public static SqlSessionFactory getSqlSessionFactory()&#123;\n        return sqlSessionFactory;\n    &#125;\n&#125;\n\nJSP\nJava Server Pages ，Java服务端页面\n一种动态的网页技术，其中既可以定义HTML,JS,CSS等静态内容，还可以定义Java代码的动态内容\nJSP &#x3D; HTML + Java\n作用：简化开发，避免了在Servlet中直接输出HTML标签\n\n快速入门\n缺点\nEL表达式\n用于简化JSP页面内的Java代码\n\n主要功能：获取数据\n\n语法：${expression}\n$&#123;brands&#125;\n\n获取域中存储key为brands的数据\n\nJavaWeb中的四大域对象：\n\npage:当前页面有效\nrequest:当前请求有效\nsession:当前会话有效\napplication:当前应用有效\n\n\n\n*el表达式获取数据，会依次从这4个域中寻找，直到找到为止\nJSTL标签\nJSP标签库（Jsp Standarded Tag Library），使用标签取代JSP页面上的Java代码\n\n\n\nMVC模式和三层架构MVC\nMVC是一种分层开发模式，其中：\n\nM:Model，业务模型，处理业务\nV:View，视图，页面展示\nC：Controller，控制器，处理请求，调用模型和视图\n\n\nMVC好处\n\n职责单一，互不影响\n有利于分工协作\n有利于组件重用\n\n\n\n三层架构\n案例\n会话跟踪技术\n会话：用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应\n会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自同一浏览器，以便在同义词绘画的多次请求间共享数据\nHTTP协议是无状态的，每次浏览器向服务器请求时，服务器都会将该请求视为新的请求，因此我们需要会话跟踪技术来实现会话内数据共享\n实现方式：\n客户端会话跟踪技术：Cookie\n服务端会话跟踪技术：Session\n\n\n\nCookieCookie:客户端会话技术，将数据保存到客户端，以后每次请求都携带Cookie数据进行访问\nCookie基本使用发送Cookie1.创建Cookie对象，设置数据\nCookie cookie &#x3D; new Cookie(&quot;key&quot;,&quot;value&quot;);\n\n2.发送Cookie到客户端：使用response对象\nresponse.addCookie(cookie);\n\n获取Cookie3.获取客户端携带的所有Cookie，使用request对象\nCookie[] cookies &#x3D; request.getCookies();\n\n4.遍历数组，获取每一个Cookie对象：for\n5.使用Cookie对象方法获取数据\ncookie.getName();\n\ncookie.getValue();\n\nCookie原理\nCookie使用细节\nCookie存活时间：\n\n​\t-默认情况下，Cookie存储爱浏览器内存中，当浏览器关闭，内存释放，则Cookie被销毁\n​\tsetMaxAge（int seconds）：设置Cookie存活时间\n​\t\t1.正数：将Cookie写入浏览器所爱电脑的硬盘，持久化存储，到时见自动删除\n​\t\t2.负数：默认值，Cookie在当前浏览器内存中，当浏览器关闭，则Cookie被销毁\n​\t\t2.零：删除对应Cookie\n\nCookie存储中文\nCookie不能直接存储中文\n如需要存储，则需要进行转码：URL编码，使用时再解码\n\n\nSessionSession：服务端会话跟踪技术，将数据保存到服务端\nJavaEE提供HttpSession接口，来实现一次会话的多次请求间数据共享功能\nSession基本使用1.获取Session对象：\nHttpSession session &#x3D; request.getSession();\n\n2.Session对象功能：\n(1) void setAttribute(String name, Object o): 存储数据到session域中\n(2)Object getAttribute(String name):根据key，获取值\n(3)void removeAttribute(String name):根据key，删除该键值对\nSession原理\nSession是基于Cookie实现的\n\n在一次会话的多次请求之间获取的session对象是同一个\n\n\n\nSession使用细节\nSession钝化，活化：\n\n钝化：在服务器正常关闭后，Tomcat会自动将Session数据写入硬盘的文件\n活化：再次启动服务器后，从文件中加载到Session中\n\n\nSession销毁： \n\n默认情况下，无操作，30分钟自动销毁\n&lt;session-config&gt;\n\t&lt;session-timeout&gt;30&lt;&#x2F;session-timeout&gt;\n&lt;session-config&gt;\t\n\n调用Session对象的invalidate()方法\n\n\n\n\n小结\nCookie和Session都是来完成一次会话内多次请求建数据共享的\n区别：\n存储位置：Cookie是将数据存储在客户端，Session将数据存储在服务端\n安全性：Cookie不安全，Session安全\n数据大小：Cookie最大3KB，Session无大小限制\n存储时间：Cookie可以长期存储，Session默认30分钟\n服务器性能：Cookie不占服务器资源，Session占用服务器资源\n\n\n\nFilter\n概念：Filter表示过滤器，是Javaweb三大组件（Servlet，Filter，Listener）之一\n过滤器可以把对资源的请求拦截下来，从未实现一些特殊的功能\n过滤器一般完成一些通用的操作，比如：权限控制，统一编码处理，敏感字符处理等等……\n\n快速入门\n执行流程\n使用细节拦截路径配置\nFilter可以根据需求，配置不同的拦截资源路径\n@WebFilter(“&#x2F;*”)\npublic class FilterDemo\n\n拦截具体的资源：&#x2F;index.jsp: 只有访问index.jsp时才会被拦截\n目录拦截：&#x2F;user&#x2F;*:访问&#x2F;user下的所有资源，都会被拦截\n后缀名拦截：*.jsp：访问后缀名为jsp的资源，都会被拦截\n拦截所有：&#x2F;*：访问所有的资源，都会被拦截\n\n\n\n过滤器链\n一个Web应用，可以配置多个过滤器，这多个过滤器称为过滤器链\n\n\n\n注解配置的Filter，优先级按照过滤器类名（字符串）的自然排序\n\nListener\n概念：Listener是监听器，是JavaWeb三大组件(Servlet,Filter,Listener)之一\n\n监听器可以监听就是在application，session，request三个对象创建，销毁或者往其中添加修改删除属性时自动执行代码的功能组件\n\nListener分类：JavaWeb提供了8个监听器\n\n\n\n\nAJAX\n概念：异步的Javascript和XML\n\nAJAX作用：\n1.与服务器进行数据交换：通过AJAX可以给服务器发送请求，并获取服务器响应的数据\n\n使用了AJAX和服务器进行通信，就可以使用HTML+AJAX来替换JSP页面了\n\n2.异步交互：可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术，如：搜索联想，用户名是否可用校验，等等……\n异步和同步\n\n\nAJAX快速入门1.编写AjaxServlet，并使用response输出字符串\n\n\n\n","slug":"Web核心","date":"2022-07-06T06:27:05.000Z","categories_index":"","tags_index":"JavaWeb","author_index":"Aurora"},{"id":"cf5277bd1519d645b084515a79fe0c20","title":"java的值传递和引用传递","content":"一、基本类型和引用类型的理解Java中的数据类型分为两种为基本类型和引用类型。\n1、基本类型的变量保存原始值，所以变量就是数据本身。\n  常见的基本类型：byte,short,int,long,char,float,double,Boolean,returnAddress。\n2、引用类型的变量保存引用值，所谓的引用值就是对象所在内存空间的“首地址值”，通过对这个引用值来操作对象。\n  常见的引用类型：类类型，接口类型和数组。\n二、值传递和引用传递的理解1、值传递  在方法的调用过程中，实参把它的实际值传递给形参，此传递过程就是将实参的值复制一份传递到函数中，这样如果在函数中对该值（形参的值）进行了操作将不会影响实参的值。因为是直接复制，所以这种方式在传递大量数据时，运行效率会特别低下。\n2、引用传递  引用传递弥补了值传递的不足，如果传递的数据量很大，直接复过去的话，会占用大量的内存空间，而引用传递就是将对象的地址值传递过去，函数接收的是原始值的首地址值。在方法的执行过程中，形参和实参的内容相同，指向同一块内存地址，也就是说操作的其实都是源数据，所以方法的执行将会影响到实际对象。\n举例说明：\npublic class Example &#123;\n    String str &#x3D; new String(&quot;hello&quot;);\n    char[] ch &#x3D; &#123;&#39;a&#39;, &#39;b&#39;&#125;;\n    public static void main(String[] args) &#123;\n        Example ex &#x3D; new Example();\n        ex.change(ex.str, ex.ch);\n        System.out.println(ex.str + &quot; and&quot;);\n        System.out.println(ex.ch);\n    &#125;\n\n    public void change(String str, char[] ch) &#123;\n        str &#x3D; &quot;ok&quot;;\n        ch[0] &#x3D; &#39;c&#39;;\n    &#125;\n&#125;\n\n输出是：\nhello and\ncb\n\n过程分析：\n1、为对象分配空间\n\n2、执行change()方法\n执行前实参（黑色）和形参（红色）的指向如下：\n\n因为String是不可变类且为值传递，而ch[]是引用传递，所以方法中的str &#x3D; “ok”,相当于重新创建一个对象并没有改变实参str的值，数组是引用传递，直接改变，所以执行完方法后，指向关系如下：\n\n3.结论通过上面的分析我们可以得出以下结论：\n基本数据类型传值，对形参的修改不会影响实参；引用类型传引用，形参和实参指向同一个内存地址（同一个对象），所以对参数的修改会影响到实际的对象。String, Integer, Double等immutable的类型特殊处理，可以理解为传值，最后的操作不会修改实参对象。\n哈希表中的特殊情况只要是哈希表中的原生类型，如Integer，String，尽管他们平时是引用传递，但在哈希表中是按值传递！！！\n非原生类型，按值传递，如自己定义的类型。\n","slug":"java的值传递和引用传递","date":"2022-07-05T08:53:49.000Z","categories_index":"","tags_index":"java基础知识","author_index":"Aurora"},{"id":"711e99b247f8f70b0f4cf84df30732b2","title":"Leetcode高频题总结","content":"剑指Offer18 删除链表的节点class Solution &#123;\n    public ListNode deleteNode(ListNode head, int val) &#123;\n        while(head !&#x3D; null)&#123;\n            if(head.val !&#x3D; val)&#123;\n                break;\n            &#125;\n            head &#x3D; head.next;\n        &#125; &#x2F;&#x2F;找到第一个非空的头结点，用于返回和执行下步操作\n        ListNode pre &#x3D; head;\n        ListNode cur &#x3D; head;\n        while(cur !&#x3D; null)&#123;\n            if(cur.val &#x3D;&#x3D; val)&#123;\n                pre.next &#x3D; cur.next;\n            &#125;else&#123;\n                pre &#x3D; cur;\n            &#125;\n            cur &#x3D; cur.next;\n        &#125;\n        return head;\n    &#125;\n&#125;\n\n24 反转链表class Solution &#123;\n    public ListNode reverseList(ListNode head) &#123;\n        ListNode pre &#x3D; null;\n        ListNode next &#x3D; head;\n        while(next!&#x3D;null)&#123;\n            next &#x3D; head.next;\n            head.next &#x3D; pre;\n            pre &#x3D; head;\n            head &#x3D; next;\n        &#125;\n        return pre;\n    &#125;\n&#125;\n\n65 不用加减乘除做加法&#x2F;*\n思路：\n      首先看十进制是如何做的： 5+7&#x3D;12，三步走 第一步：相加各位的值，不算进位，得到2。\n      第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。\n      第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。 同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111 \n      第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。 \n      第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。 \n      第三步重复上述两步， 各位相加 010^1010&#x3D;1000，进位值为100&#x3D;(010&amp;1010)&lt;&lt;1。 继续重复上述两步：1000^100 &#x3D; 1100，进位值为0，跳出循环，1100为最终结果。\n————————————————\n版权声明：本文为CSDN博主「夏至&amp;未至」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_35571554&#x2F;article&#x2F;details&#x2F;82780288\n*&#x2F;\npublic class Solution &#123;\n    public int Add(int num1,int num2) &#123;\n        while (num2!&#x3D;0) &#123;\n            int temp &#x3D; num1^num2;\n            num2 &#x3D; (num1&amp;num2)&lt;&lt;1;\n            num1 &#x3D; temp;\n        &#125;\n        return num1;\n    &#125;\n&#125;\n\n","slug":"Leetcode高频题总结","date":"2022-07-05T03:05:06.000Z","categories_index":"","tags_index":"算法与数据结构","author_index":"Aurora"},{"id":"6688690e355db1dd869bd788558b9211","title":"数据结构与算法学习","content":"由于之前并未完整成体系的学习算法，在力扣刷100道题后\n感觉到算法知识不成体系，决定看左程云的体系学习班学习算法\n学习路线\n搞定1,2,3差不多达到面试水平\n杂记子问题规模一样的递归可以用Master公式求时间复杂度\nT(N) &#x3D; a * T(N&#x2F;b) + O(N ^ d);\na:会有几次调用代码\nb:每次调用规模的大小\n\n如果 log（b , a) &lt; d 时间复杂度为： O(N^d)\n如果log (b , a) &gt; d 时间复杂度为 ： O(N^(log(b,a)))\n如果log（b , a）&#x3D;&#x3D; d 时间复杂度为：O(N^d * log(2,n)))注：log(b,a) 指以b为地a为指数\n\n基础的数据结构实现栈和队列用数组实现队列&#x2F;&#x2F; 给定一个长度被限制数组空间，如何实现队列？\npublic class RingArray&#123;\n    public static class MyQueue&#123;\n        private int[]arr;\n        private int pushi;\n        private int rolli;\n        private int size;\n        private final int limit;\n        \n        public MyQueue(int limit)&#123;\n            arr &#x3D; new int[limit];\n            pushi &#x3D; 0;\n            polli &#x3D; 0;\n            size &#x3D; 0;\n            this.limit &#x3D; limit;\n        &#125;\n        \n        public void push(int value)&#123;\n            if(size &#x3D;&#x3D; limit)&#123;\n                throw new RuntimeException(&quot;队列满了，不能再加了&quot;);\n            &#125;\n            size++;\n            arr[pushi] &#x3D; value;\n            pushi &#x3D; nextIndex(pushi);\n        &#125;\n        \n        public int pop()&#123;\n            if(size &#x3D;&#x3D; 0)&#123;\n                throw new RuntimeException(&quot;队列空了，不能再拿了&quot;);\n            &#125;\n            int ans &#x3D; arr[rolli];\n            rolli &#x3D; nextIndex(rolli);\n            return ans;\n        &#125;\n        \n        public boolean isEmpty()&#123;\n            return size &#x3D;&#x3D; 0;\n        &#125;\n        \n        private int nextIndex(int i)&#123;\n            return i &lt; limit - 1 ? i + 1: 0;\n        &#125;\n    &#125;\n&#125;\n\n数组实现一个特殊的栈，可实时返回栈中最小值&#x2F;&#x2F;在基本功能上，再实现返回栈中最小元素的功能，且pop、push、getMin操作的时间复杂度是O(1).\n\n&#x2F;&#x2F;思路：维护一个栈和一个最小值栈，最小栈中存此时栈中的最小值。\n\npublic class GetMinStack &#123;\n\n\tpublic static class MyStack &#123;\n\t\tprivate Stack&lt;Integer&gt; stackData;\n\t\tprivate Stack&lt;Integer&gt; stackMin;\n\n\t\tpublic MyStack2() &#123;\n\t\t\tthis.stackData &#x3D; new Stack&lt;Integer&gt;();\n\t\t\tthis.stackMin &#x3D; new Stack&lt;Integer&gt;();\n\t\t&#125;\n\n\t\tpublic void push(int newNum) &#123;\n\t\t\tif (this.stackMin.isEmpty()) &#123;\n\t\t\t\tthis.stackMin.push(newNum);\n\t\t\t&#125; else if (newNum &lt; this.getmin()) &#123;\n\t\t\t\tthis.stackMin.push(newNum);\n\t\t\t&#125; else &#123;\n\t\t\t\tint newMin &#x3D; this.stackMin.peek();\n\t\t\t\tthis.stackMin.push(newMin);\n\t\t\t&#125;\n\t\t\tthis.stackData.push(newNum);\n\t\t&#125;\n\n\t\tpublic int pop() &#123;\n\t\t\tif (this.stackData.isEmpty()) &#123;\n\t\t\t\tthrow new RuntimeException(&quot;Your stack is empty.&quot;);\n\t\t\t&#125;\n\t\t\tthis.stackMin.pop();\n\t\t\treturn this.stackData.pop();\n\t\t&#125;\n\n\t\tpublic int getmin() &#123;\n\t\t\tif (this.stackMin.isEmpty()) &#123;\n\t\t\t\tthrow new RuntimeException(&quot;Your stack is empty.&quot;);\n\t\t\t&#125;\n\t\t\treturn this.stackMin.peek();\n\t\t&#125;\n\t&#125;\n\n&#125;\n\n如何用栈实现队列&#x2F;&#x2F; 思路：一个push栈，一个pop栈，把push栈的元素放进pop栈再取出来\n&#x2F;&#x2F; 为保证顺序，1、pop栈不为空时,push栈不能往pop栈里倒元素。2、push栈倒元素需要一次性倒完\n\npublic class TwoStacksImplementQueue &#123;\n\n\tpublic static class TwoStacksQueue &#123;\n\t\tpublic Stack&lt;Integer&gt; stackPush;\n\t\tpublic Stack&lt;Integer&gt; stackPop;\n\n\t\tpublic TwoStacksQueue() &#123;\n\t\t\tstackPush &#x3D; new Stack&lt;Integer&gt;();\n\t\t\tstackPop &#x3D; new Stack&lt;Integer&gt;();\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; push栈向pop栈倒入数据\n\t\tprivate void pushToPop() &#123;\n\t\t\tif (stackPop.empty()) &#123;\n\t\t\t\twhile (!stackPush.empty()) &#123;\n\t\t\t\t\tstackPop.push(stackPush.pop());\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tpublic void add(int pushInt) &#123;\n\t\t\tstackPush.push(pushInt);\n\t\t\tpushToPop();\n\t\t&#125;\n\n\t\tpublic int poll() &#123;\n\t\t\tif (stackPop.empty() &amp;&amp; stackPush.empty()) &#123;\n\t\t\t\tthrow new RuntimeException(&quot;Queue is empty!&quot;);\n\t\t\t&#125;\n\t\t\tpushToPop();\n\t\t\treturn stackPop.pop();\n\t\t&#125;\n\n\t\tpublic int peek() &#123;\n\t\t\tif (stackPop.empty() &amp;&amp; stackPush.empty()) &#123;\n\t\t\t\tthrow new RuntimeException(&quot;Queue is empty!&quot;);\n\t\t\t&#125;\n\t\t\tpushToPop();\n\t\t\treturn stackPop.peek();\n\t\t&#125;\n\t&#125;\n&#125;\n\n如何用队列实现栈&#x2F;&#x2F;实现poll或peek功能是第一个队列中除最后一个元素依次取出加进另一个队列，剩下的那个就是所需要的元素\npublic class Code07_TwoQueueImplementStack &#123;\n\n\tpublic static class TwoQueueStack&lt;T&gt; &#123;\n\t\tpublic Queue&lt;T&gt; queue;\n\t\tpublic Queue&lt;T&gt; help;\n\n\t\tpublic TwoQueueStack() &#123;\n\t\t\tqueue &#x3D; new LinkedList&lt;&gt;();\n\t\t\thelp &#x3D; new LinkedList&lt;&gt;();\n\t\t&#125;\n\n\t\tpublic void push(T value) &#123;\n\t\t\tqueue.offer(value);\n\t\t&#125;\n\n\t\tpublic T poll() &#123;\n\t\t\twhile (queue.size() &gt; 1) &#123;\n\t\t\t\thelp.offer(queue.poll());\n\t\t\t&#125;\n\t\t\tT ans &#x3D; queue.poll();\n\t\t\tQueue&lt;T&gt; tmp &#x3D; queue;\n\t\t\tqueue &#x3D; help;\n\t\t\thelp &#x3D; tmp;\n\t\t\treturn ans;\n\t\t&#125;\n\n\t\tpublic T peek() &#123;\n\t\t\twhile (queue.size() &gt; 1) &#123;\n\t\t\t\thelp.offer(queue.poll());\n\t\t\t&#125;\n\t\t\tT ans &#x3D; queue.poll();\n\t\t\thelp.offer(ans);\n\t\t\tQueue&lt;T&gt; tmp &#x3D; queue;\n\t\t\tqueue &#x3D; help;\n\t\t\thelp &#x3D; tmp;\n\t\t\treturn ans;\n\t\t&#125;\n\n\t\tpublic boolean isEmpty() &#123;\n\t\t\treturn queue.isEmpty();\n\t\t&#125;\n\t&#125;\n&#125;\n\n堆public class Heap &#123;\n\n\tpublic static class MyMaxHeap &#123;\n\t\tprivate int[] heap;\n\t\tprivate final int limit;\n\t\tprivate int heapSize;\n\n\t\tpublic MyMaxHeap(int limit) &#123;\n\t\t\theap &#x3D; new int[limit];\n\t\t\tthis.limit &#x3D; limit;\n\t\t\theapSize &#x3D; 0;\n\t\t&#125;\n\n\t\tpublic boolean isEmpty() &#123;\n\t\t\treturn heapSize &#x3D;&#x3D; 0;\n\t\t&#125;\n\n\t\tpublic boolean isFull() &#123;\n\t\t\treturn heapSize &#x3D;&#x3D; limit;\n\t\t&#125;\n\n\t\tpublic void push(int value) &#123;\n\t\t\tif (heapSize &#x3D;&#x3D; limit) &#123;\n\t\t\t\tthrow new RuntimeException(&quot;heap is full&quot;);\n\t\t\t&#125;\n\t\t\theap[heapSize] &#x3D; value;\n\t\t\t&#x2F;&#x2F; value heapSize\n\t\t\theapInsert(heap, heapSize++);\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; 返回最大值，并且在大根堆中，把最大值删掉\n\t\t&#x2F;&#x2F; 剩下的数，依然保持大根堆组织\n\t\tpublic int pop() &#123;\n\t\t\tint ans &#x3D; heap[0];\n\t\t\tswap(heap, 0, --heapSize);\n\t\t\theapify(heap, 0, heapSize);\n\t\t\treturn ans;\n\t\t&#125;\n\n\t\tprivate void heapInsert(int[] arr, int index) &#123;\n\t\t\t&#x2F;&#x2F; [index] [index-1]&#x2F;2\n\t\t\t&#x2F;&#x2F; index &#x3D;&#x3D; 0\n\t\t\twhile (arr[index] &gt; arr[(index - 1) &#x2F; 2]) &#123;\n\t\t\t\tswap(arr, index, (index - 1) &#x2F; 2);\n\t\t\t\tindex &#x3D; (index - 1) &#x2F; 2;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tprivate void heapify(int[] arr, int index, int heapSize) &#123;\n\t\t\tint left &#x3D; index * 2 + 1;\n\t\t\twhile (left &lt; heapSize) &#123; &#x2F;&#x2F; 如果有左孩子，有没有右孩子，可能有可能没有！\n\t\t\t\t&#x2F;&#x2F; 把较大孩子的下标，给largest\n\t\t\t\tint largest &#x3D; left + 1 &lt; heapSize &amp;&amp; arr[left + 1] &gt; arr[left] ? left + 1 : left;\n\t\t\t\tlargest &#x3D; arr[largest] &gt; arr[index] ? largest : index;\n\t\t\t\tif (largest &#x3D;&#x3D; index) &#123;\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t\t\t&#x2F;&#x2F; index和较大孩子，要互换\n\t\t\t\tswap(arr, largest, index);\n\t\t\t\tindex &#x3D; largest;\n\t\t\t\tleft &#x3D; index * 2 + 1;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tprivate void swap(int[] arr, int i, int j) &#123;\n\t\t\tint tmp &#x3D; arr[i];\n\t\t\tarr[i] &#x3D; arr[j];\n\t\t\tarr[j] &#x3D; tmp;\n\t\t&#125;\n\n\t&#125;\n&#125;\n\n\n\n排序选择排序0~N-1上找到最小值与下标为0的值交换\n1~N-1上找到最小值与下标为1的值交换\n2~N-1上找到最小值与下标为2的值交换\n······\npublic static void selectionSort(int[] arr) &#123;\n\t\tif (arr &#x3D;&#x3D; null || arr.length &lt; 2) &#123;\n\t\t\treturn;\n\t\t&#125;\n\t\t&#x2F;&#x2F; 0 ~ N-1  找到最小值，在哪，放到0位置上\n\t\t&#x2F;&#x2F; 1 ~ n-1  找到最小值，在哪，放到1 位置上\n\t\t&#x2F;&#x2F; 2 ~ n-1  找到最小值，在哪，放到2 位置上\n\t\tfor (int i &#x3D; 0; i &lt; arr.length - 1; i++) &#123;\n\t\t\tint minIndex &#x3D; i;\n\t\t\tfor (int j &#x3D; i + 1; j &lt; arr.length; j++) &#123; &#x2F;&#x2F; i ~ N-1 上找最小值的下标 \n\t\t\t\tminIndex &#x3D; arr[j] &lt; arr[minIndex] ? j : minIndex;\n\t\t\t&#125;\n\t\t\tswap(arr, i, minIndex);\n\t\t&#125;\n\t&#125;\n\n\tpublic static void swap(int[] arr, int i, int j) &#123;\n\t\tint tmp &#x3D; arr[i];\n\t\tarr[i] &#x3D; arr[j];\n\t\tarr[j] &#x3D; tmp;\n\t&#125;\n\n冒泡排序public static void bubbleSort(int[] arr) &#123;\n\t\tif (arr &#x3D;&#x3D; null || arr.length &lt; 2) &#123;\n\t\t\treturn;\n\t\t&#125;\n\t\t&#x2F;&#x2F; 0 ~ N-1\n\t\t&#x2F;&#x2F; 0 ~ N-2\n\t\t&#x2F;&#x2F; 0 ~ N-3\n\t\tfor (int e &#x3D; arr.length - 1; e &gt; 0; e--) &#123; &#x2F;&#x2F; 0 ~ e\n\t\t\tfor (int i &#x3D; 0; i &lt; e; i++) &#123;\n\t\t\t\tif (arr[i] &gt; arr[i + 1]) &#123;\n\t\t\t\t\tswap(arr, i, i + 1);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F; 交换arr的i和j位置上的值，i和j是一个位置的话，会出错\n\tpublic static void swap(int[] arr, int i, int j) &#123;\n\t\tarr[i] &#x3D; arr[i] ^ arr[j];\n\t\tarr[j] &#x3D; arr[i] ^ arr[j];\n\t\tarr[i] &#x3D; arr[i] ^ arr[j];\n\t&#125;\n\n\n\n\n插入排序public static void insertionSort(int[] arr) &#123;\n\t\tif (arr &#x3D;&#x3D; null || arr.length &lt; 2) &#123;\n\t\t\treturn;\n\t\t&#125;\n\t\t&#x2F;&#x2F; 不只1个数\n\t\tfor (int i &#x3D; 1; i &lt; arr.length; i++) &#123; &#x2F;&#x2F; 0 ~ i 做到有序\n\t\t\tfor (int j &#x3D; i - 1; j &gt;&#x3D; 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) &#123;\n\t\t\t\tswap(arr, j, j + 1);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F; i和j是一个位置的话，会出错\n\tpublic static void swap(int[] arr, int i, int j) &#123;\n\t\tarr[i] &#x3D; arr[i] ^ arr[j];\n\t\tarr[j] &#x3D; arr[i] ^ arr[j];\n\t\tarr[i] &#x3D; arr[i] ^ arr[j];\n\t&#125;\n\n归并排序&#x2F;&#x2F; 递归方法实现\n\tpublic static void mergeSort1(int[] arr) &#123;\n\t\tif (arr &#x3D;&#x3D; null || arr.length &lt; 2) &#123;\n\t\t\treturn;\n\t\t&#125;\n\t\tprocess(arr, 0, arr.length - 1);\n\t&#125;\n\n\t&#x2F;&#x2F; 请把arr[L..R]排有序\n\t&#x2F;&#x2F; l...r N\n\t&#x2F;&#x2F; T(N) &#x3D; 2 * T(N &#x2F; 2) + O(N)\n\t&#x2F;&#x2F; O(N * logN)\n\tpublic static void process(int[] arr, int L, int R) &#123;\n\t\tif (L &#x3D;&#x3D; R) &#123; &#x2F;&#x2F; base case\n\t\t\treturn;\n\t\t&#125;\n\t\tint mid &#x3D; L + ((R - L) &gt;&gt; 1);\n\t\tprocess(arr, L, mid);\n\t\tprocess(arr, mid + 1, R);\n\t\tmerge(arr, L, mid, R);\n\t&#125;\n\n\tpublic static void merge(int[] arr, int L, int M, int R) &#123;\n\t\tint[] help &#x3D; new int[R - L + 1];\n\t\tint i &#x3D; 0;\n\t\tint p1 &#x3D; L;\n\t\tint p2 &#x3D; M + 1;\n\t\twhile (p1 &lt;&#x3D; M &amp;&amp; p2 &lt;&#x3D; R) &#123;\n\t\t\thelp[i++] &#x3D; arr[p1] &lt;&#x3D; arr[p2] ? arr[p1++] : arr[p2++];\n\t\t&#125;\n\t\t&#x2F;&#x2F; 要么p1越界了，要么p2越界了\n\t\twhile (p1 &lt;&#x3D; M) &#123;\n\t\t\thelp[i++] &#x3D; arr[p1++];\n\t\t&#125;\n\t\twhile (p2 &lt;&#x3D; R) &#123;\n\t\t\thelp[i++] &#x3D; arr[p2++];\n\t\t&#125;\n\t\tfor (i &#x3D; 0; i &lt; help.length; i++) &#123;\n\t\t\tarr[L + i] &#x3D; help[i];\n\t\t&#125;\n\t&#125;\n\n变形1：给定一个数组，求出每个元素左边比他小的元素之和，再求每个元素左边比他小的元素之和的累加和，要求小于O（N^2）\npublic static int smallSum(int[] arr) &#123;\n\t\tif (arr &#x3D;&#x3D; null || arr.length &lt; 2) &#123;\n\t\t\treturn 0;\n\t\t&#125;\n\t\treturn process(arr, 0, arr.length - 1);\n\t&#125;\n\n\t&#x2F;&#x2F; arr[L..R]既要排好序，也要求小和返回\n\t&#x2F;&#x2F; 所有merge时，产生的小和，累加\n\t&#x2F;&#x2F; 左 排序   merge\n\t&#x2F;&#x2F; 右 排序  merge\n\t&#x2F;&#x2F; merge\n\tpublic static int process(int[] arr, int l, int r) &#123;\n\t\tif (l &#x3D;&#x3D; r) &#123;\n\t\t\treturn 0;\n\t\t&#125;\n\t\t&#x2F;&#x2F; l &lt; r\n\t\tint mid &#x3D; l + ((r - l) &gt;&gt; 1);\n\t\treturn \n\t\t\t\tprocess(arr, l, mid) \n\t\t\t\t+ \n\t\t\t\tprocess(arr, mid + 1, r) \n\t\t\t\t+ \n\t\t\t\tmerge(arr, l, mid, r);\n\t&#125;\n\n\tpublic static int merge(int[] arr, int L, int m, int r) &#123;\n\t\tint[] help &#x3D; new int[r - L + 1];\n\t\tint i &#x3D; 0;\n\t\tint p1 &#x3D; L;\n\t\tint p2 &#x3D; m + 1;\n\t\tint res &#x3D; 0;\n\t\twhile (p1 &lt;&#x3D; m &amp;&amp; p2 &lt;&#x3D; r) &#123;\n\t\t\tres +&#x3D; arr[p1] &lt; arr[p2] ? (r - p2 + 1) * arr[p1] : 0;&#x2F;&#x2F;就多了这一行代码\n\t\t\thelp[i++] &#x3D; arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];\n\t\t&#125;\n\t\twhile (p1 &lt;&#x3D; m) &#123;\n\t\t\thelp[i++] &#x3D; arr[p1++];\n\t\t&#125;\n\t\twhile (p2 &lt;&#x3D; r) &#123;\n\t\t\thelp[i++] &#x3D; arr[p2++];\n\t\t&#125;\n\t\tfor (i &#x3D; 0; i &lt; help.length; i++) &#123;\n\t\t\tarr[L + i] &#x3D; help[i];\n\t\t&#125;\n\t\treturn res;\n\t&#125;\n\n变形2：求逆序对的数量\n给定一个序列有n个数，求n个数中逆序对的个数，逆序对的定义：i &lt; j &amp;&amp; a[i] &gt; a[j]。\nint merge_sort(int a[], int l ,int r)&#123;\n    &#x2F;&#x2F;序列只有一个数\n    if (l &#x3D;&#x3D; r) return 0;\n    &#x2F;&#x2F;递归左边和右边\n    int mid &#x3D; l + r &gt;&gt; 1;\n    int res &#x3D; merge_sort(a, l , mid) + merge_sort(a, mid + 1, r);\n    &#x2F;&#x2F;归并的过程\n    int i &#x3D; l , j &#x3D; mid + 1, k &#x3D; 0;\n    while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r)&#123;\n        if (a[i] &lt;&#x3D; a[j]) t[k++] &#x3D; a[i++];\n        else&#123;\n            t[k++] &#x3D; a[j++];\n            res +&#x3D; mid - i + 1;\n        &#125;\n    &#125;\n    while (i &lt;&#x3D; mid) t[k++] &#x3D; a[i++];\n    while (j &lt;&#x3D; r) t[k++] &#x3D; a[j++];\n    \n    &#x2F;&#x2F;还原数组\n    for (int i &#x3D; 0 , j &#x3D; l ; j &lt;&#x3D; r ; i ++ , j ++) a[j] &#x3D; t[i];\n    \n    return res;\n&#125;\n\n\n变形3：翻转对\nclass Solution &#123;\n   public static int reversePairs(int[] nums) &#123;\n\t\tif (nums &#x3D;&#x3D; null || nums.length &lt; 2) &#123;\n\t\t\treturn 0;\n\t\t&#125;\n\t\treturn process(nums, 0, nums.length - 1);\n\t&#125;\n\n\tpublic static int process(int[] nums, int l, int r) &#123;\n\t\tif (l &#x3D;&#x3D; r) &#123;\n\t\t\treturn 0;\n\t\t&#125;\n\t\t&#x2F;&#x2F; l &lt; r\n\t\tint mid &#x3D; l + ((r - l) &gt;&gt; 1);\n\t\treturn process(nums, l, mid) + process(nums, mid + 1, r) + merge(nums, l, mid, r);\n\t&#125;\n\n\tpublic static int merge(int[] nums, int L, int m, int r) &#123;\n\t\t&#x2F;&#x2F; [L....M] [M+1....R]\n\t\tint ans &#x3D; 0;\n\t\tint windowR &#x3D; m + 1;\n\t\tfor (int i &#x3D; L; i &lt;&#x3D; m; i++) &#123;\n\t\t\twhile (windowR &lt;&#x3D; r &amp;&amp; (long) nums[i] &gt; (long) nums[windowR] * 2) &#123;\n\t\t\t\twindowR++;\n\t\t\t&#125;\n\t\t\tans +&#x3D; windowR - m - 1;\n\t\t&#125;\n\t\tint[] help &#x3D; new int[r - L + 1];\n\t\tint i &#x3D; 0;\n\t\tint p1 &#x3D; L;\n\t\tint p2 &#x3D; m + 1;\n\t\twhile (p1 &lt;&#x3D; m &amp;&amp; p2 &lt;&#x3D; r) &#123;\n\t\t\thelp[i++] &#x3D; nums[p1] &lt;&#x3D; nums[p2] ? nums[p1++] : nums[p2++];\n\t\t&#125;\n\t\twhile (p1 &lt;&#x3D; m) &#123;\n\t\t\thelp[i++] &#x3D; nums[p1++];\n\t\t&#125;\n\t\twhile (p2 &lt;&#x3D; r) &#123;\n\t\t\thelp[i++] &#x3D; nums[p2++];\n\t\t&#125;\n\t\tfor (i &#x3D; 0; i &lt; help.length; i++) &#123;\n\t\t\tnums[L + i] &#x3D; help[i];\n\t\t&#125;\n\t\treturn ans;\n\t&#125;\n&#125;\n\n堆排序public class HeapSort&#123;\n    public static void heapSort(int[] arr) &#123;\n\t\tif (arr &#x3D;&#x3D; null || arr.length &lt; 2) &#123;\n\t\t\treturn;\n\t\t&#125;\n\t\tfor (int i &#x3D; 0; i &lt; arr.length; i++) &#123; &#x2F;&#x2F; O(N)\n\t\t\theapInsert(arr, i); &#x2F;&#x2F; O(logN)\n\t\t&#125;\n\t\t&#x2F;&#x2F; O(N)\n&#x2F;&#x2F;\t\tfor (int i &#x3D; arr.length - 1; i &gt;&#x3D; 0; i--) &#123;\n&#x2F;&#x2F;\t\t\theapify(arr, i, arr.length);\n&#x2F;&#x2F;\t\t&#125;\n\t\tint heapSize &#x3D; arr.length;\n\t\tswap(arr, 0, --heapSize);\n\t\twhile (heapSize &gt; 0) &#123; &#x2F;&#x2F; O(N) \n\t\t\theapify(arr, 0, heapSize); &#x2F;&#x2F; O(logN)\n\t\t\tswap(arr, 0, --heapSize); &#x2F;&#x2F; O(1)\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F; arr[index]刚来的数，往上\n\tpublic static void heapInsert(int[] arr, int index) &#123;\n\t\twhile (arr[index] &gt; arr[(index - 1) &#x2F; 2]) &#123;\n\t\t\tswap(arr, index, (index - 1) &#x2F; 2);\n\t\t\tindex &#x3D; (index - 1) &#x2F; 2;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F; arr[index]位置的数，能否往下移动\n\tpublic static void heapify(int[] arr, int index, int heapSize) &#123;\n\t\tint left &#x3D; index * 2 + 1; &#x2F;&#x2F; 左孩子的下标\n\t\twhile (left &lt; heapSize) &#123; &#x2F;&#x2F; 下方还有孩子的时候\n\t\t\t&#x2F;&#x2F; 两个孩子中，谁的值大，把下标给largest\n\t\t\tint largest &#x3D; left + 1 &lt; heapSize &amp;&amp; arr[left + 1] &gt; arr[left] ? left + 1 : left;\n\t\t\t&#x2F;&#x2F; 父和较大的孩子之间，谁的值大，把下标给largest\n\t\t\tlargest &#x3D; arr[largest] &gt; arr[index] ? largest : index;\n\t\t\tif (largest &#x3D;&#x3D; index) &#123;\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t\tswap(arr, largest, index);\n\t\t\tindex &#x3D; largest;\n\t\t\tleft &#x3D; index * 2 + 1;\n\t\t&#125;\n\t&#125;\n\n\tpublic static void swap(int[] arr, int i, int j) &#123;\n\t\tint tmp &#x3D; arr[i];\n\t\tarr[i] &#x3D; arr[j];\n\t\tarr[j] &#x3D; tmp;\n\t&#125;\n&#125;\n\n\n\n位运算int a &#x3D; 7;\nint b &#x3D; -a &#x3D; (~a) + 1 &#x3D; -7;\n\n&#x2F;&#x2F; arr中，只有一种数，出现奇数次\npublic static void printOddTimesNum1(int[] arr) &#123;\n\tint eor &#x3D; 0;\n\tfor (int i &#x3D; 0; i &lt; arr.length; i++) &#123;\n\t\teor ^&#x3D; arr[i];\n\t&#125;\n\tSystem.out.println(eor);\n&#125;\n\n&#x2F;&#x2F; arr中，有两种数，出现奇数次\npublic static void printOddTimesNum2(int[] arr) &#123;\n\tint eor &#x3D; 0;\n\tfor (int i &#x3D; 0; i &lt; arr.length; i++) &#123;\n\t\teor ^&#x3D; arr[i];\n\t&#125;\n\t&#x2F;&#x2F; a 和 b是两种数\n\t&#x2F;&#x2F; eor !&#x3D; 0\n\t&#x2F;&#x2F; eor最右侧的1，提取出来\n\t&#x2F;&#x2F; eor :     00110010110111000\n\t&#x2F;&#x2F; rightOne :00000000000001000\n\tint rightOne &#x3D; eor &amp; (-eor); &#x2F;&#x2F; 提取出最右的1\n\t\n\t\n\tint onlyOne &#x3D; 0; &#x2F;&#x2F; eor&#39;\n\tfor (int i &#x3D; 0 ; i &lt; arr.length;i++) &#123;\n\t\t&#x2F;&#x2F;  arr[1] &#x3D;  111100011110000\n\t\t&#x2F;&#x2F; rightOne&#x3D;  000000000010000\n\t\tif ((arr[i] &amp; rightOne) !&#x3D; 0) &#123;\n\t\t\tonlyOne ^&#x3D; arr[i];\n\t\t&#125;\n\t&#125;\n\tSystem.out.println(onlyOne + &quot; &quot; + (eor ^ onlyOne));\n&#125;\n   &#x2F;&#x2F; 输入一定能够保证，数组中所有的数都出现了M次，只有一种数出现了K次\n   &#x2F;&#x2F; 1 &lt;&#x3D; K &lt; M\n   &#x2F;&#x2F; 返回这种数\n   public static int km(int[] arr, int k, int m) &#123;\n       int[] help &#x3D; new int[32];\n       for (int num : arr) &#123;\n           for (int i &#x3D; 0; i &lt; 32; i++) &#123;\n               help[i] +&#x3D; (num &gt;&gt; i) &amp; 1;\n           &#125;\n       &#125;\n       int ans &#x3D; 0;\n       for (int i &#x3D; 0; i &lt; 32; i++) &#123;\n           help[i] %&#x3D; m;\n           if (help[i] !&#x3D; 0) &#123;\n               ans |&#x3D; 1 &lt;&lt; i;\n           &#125;\n       &#125;\n       return ans;\n   &#125;\n\n\n\n\n\n","slug":"数据结构与算法学习","date":"2022-07-02T01:51:23.000Z","categories_index":"","tags_index":"算法与数据结构","author_index":"Aurora"},{"id":"d75b47533ffd84933c1aac3f8bde1caa","title":"前端三件套","content":"HTMLHTML：超文本标记语言超文本：超越了文本的的限制，比普通文本更强大，除了文字信息，还可以定义图片，音频，视频等内容。标记语言：由标签构成的语言\nHTML运行在浏览器上，HTML标签由浏览器来解析\nHTML标签都是预定义好的。例如：使用&lt;img&gt;展示图片\n\nW3C标准：网页主要由三部分组成\n结构：HTML\n表现：CSS\n行为：JavaScript\n\n\n\nHTML结构：\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;&lt;&#x2F;title&gt;\n    &lt;&#x2F;head&gt;\n    &lt;body&gt;\n        \n    &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\n\n\n\n\n \nCSS导入方式：\n1、使用“”引入css样式；\n2、在style标签里写css样式；\n3、在元素标签里使用style属性写css样式。\n具体使用查W3cschool\njs导入方式：\n1、直接引入\n&lt;script&gt;alert(&quot;这是js的内部引入&quot;);&lt;&#x2F;script&gt;\n2、\n定义外部js文件\n&lt;script type&#x3D;”text&#x2F;javascript” src&#x3D;”demo.js”&gt;\n基本语法结尾 ; 可有可无\n使用window.alert()写入警告框\n使用document.write()写入html输出\n使用console.log()写入浏览器控制台\n用var声明变量\nvar test &#x3D; 20;\ntest &#x3D; &quot;张三&quot;\n\nJavascript是一门弱类型语言，变量可以存放不同类型的值\n变量名命名规则：\n\n组成字符可以是任何字母，数组，下划线(_)或美元符号($)\n数字不能开头\n建议使用驼峰命名\n\nECMAScript6新增了let关键字来定义变量，它的用法类似于var，但是所声明的变量，只在let关键字所在的代码块内有效，且不允许重复声明\nECMAScript6新增了const关键字，用来声明一个只读的常量。一旦声明，常量的值就不能改变了\n\n运算符 &#x3D;&#x3D;  和  &#x3D;&#x3D;&#x3D; \nvar age1 &#x3D; 20;\nvar age2 &#x3D; &quot;20&quot;;\nalert(age1 &#x3D;&#x3D; age2) &#x2F;&#x2F;会返回true\nalert(age1 &#x3D;&#x3D;&#x3D; age2) &#x2F;&#x2F;会返回false\n&#x2F;*\n\t&#x3D;&#x3D; ：1.判断类型是否一样，如果不一样，先转换成一样\n    \t2.再判断是否相等\n\t&#x3D;&#x3D;&#x3D;：1.判断类型是否一样，如果不一样，直接返回false\n\t\t2.再判断是否相等\n*&#x2F;\n\n\n\n\n\n类型转换：其他类型转为number：\n\nstring: 按照字符串的字面值，转为数字.如果字面值不是数字，则转为NaN。一般使用parseInt\nboolean: true 转为1，false转为0\n\n其他类型转为boolean：\n\nnumber:0和NaN转为false，其他的数字转为true \nstring:空字符串转为false，其他的字符串转为true \nnull:false \nundefined:false\n\n\n\n对象Array\nString\n自定义对象\nBOMBOM：Browser Object Model 浏览器对象模型。也就是 JavaScript 将浏览器的各个组成部分封装为对象。\n我们要操作浏览器的各个组成部分就可以通过操作 BOM 中的对象来实现。比如：我现在想将浏览器地址栏的地址改为 https://www.itheima.com 就可以通过使用 BOM 中定义的 Location 对象的 href 属性，代码： location.href = &quot;https://itheima.com&quot;; \n BOM 中包含了如下对象：\n\nWindow：浏览器窗口对象\nNavigator：浏览器对象\nScreen：屏幕对象\nHistory：历史记录对象\nLocation：地址栏对象\n\n下图是 BOM 中的各个对象和浏览器的各个组成部分的对应关系\n\nwindow对象\nhistory对象\nloaction对象\nDOMDOM：Document Object Model 文档对象模型。也就是 JavaScript 将 HTML 文档的各个组成部分封装为对象。\nDOM 其实我们并不陌生，之前在学习 XML 就接触过，只不过 XML 文档中的标签需要我们写代码解析，而 HTML 文档是浏览器解析。封装的对象分为\n\nDocument：整个文档对象\nElement：元素对象\nAttribute：属性对象\nText：文本对象\nComment：注释对象\n\n如下图，左边是 HTML 文档内容，右边是 DOM 树\n\n作用：\nJavaScript 通过 DOM， 就能够对 HTML进行操作了\n\n改变 HTML 元素的内容\n改变 HTML 元素的样式（CSS）\n对 HTML DOM 事件作出反应\n添加和删除 HTML 元素\n\nDOM相关概念：\nDOM 是 W3C（万维网联盟）定义了访问 HTML 和 XML 文档的标准。该标准被分为 3 个不同的部分：\n\n核心 DOM：针对任何结构化文档的标准模型。 XML 和 HTML 通用的标准\n\nDocument：整个文档对象\n\nElement：元素对象\n\nAttribute：属性对象\n\nText：文本对象\n\nComment：注释对象\n\n\n\nXML DOM： 针对 XML 文档的标准模型\n\nHTML DOM： 针对 HTML 文档的标准模型\n该标准是在核心 DOM 基础上，对 HTML 中的每个标签都封装成了不同的对象\n\n例如：&lt;img&gt; 标签在浏览器加载到内存中时会被封装成 Image 对象，同时该对象也是 Element 对象。\n例如：&lt;input type=&#39;button&#39;&gt; 标签在浏览器加载到内存中时会被封装成 Button 对象，同时该对象也是 Element 对象。\n\n\n\n获取Element对象HTML 中的 Element 对象可以通过 Document 对象获取，而 Document 对象是通过 window 对象获取。\nDocument 对象中提供了以下获取 Element 元素对象的函数\n\ngetElementById()：根据id属性值获取，返回单个Element对象\ngetElementsByTagName()：根据标签名称获取，返回Element对象数组\ngetElementsByName()：根据name属性值获取，返回Element对象数组\ngetElementsByClassName()：根据class属性值获取，返回Element对象数组\n\n事件监听\n事件：HTML事件是发生在HTML元素身上的“事情”。比如：\n\n按钮被点击\n鼠标移动到元素之上\n按下键盘按键\n\n\n事件监听：Javascript可以在事件被侦测到时执行代码\n\n\n事件绑定方式一：通过 HTML标签中的事件属性进行绑定\nonclick 是 单击事件 的事件属性\n&lt;input type&#x3D;&quot;button&quot; onclick&#x3D;&#39;on()’&gt;\nfunction on()&#123;\n\talert(&quot;我被点了&quot;);\n&#125;\n\n方式二：通过 DOM 元素属性绑定\n&lt;input type&#x3D;&quot;button&quot; id&#x3D;&quot;btn&quot;&gt;\ndocument.getElementById(&quot;btn&quot;).onclick &#x3D; function ()&#123;\n    alert(&quot;我被点了&quot;);\n&#125;\n\n为保证单一职责，建议使用方式二\n常见事件\n正则表达式正则对象有两种创建方式：\n\n直接量方式：注意不要加引号\nvar reg &#x3D; &#x2F;正则表达式&#x2F;;\n\n创建 RegExp 对象\nvar reg &#x3D; new RegExp(&quot;正则表达式&quot;);\n\ntest(str) ：判断指定字符串是否符合规则，返回 true或 false\n从上面创建正则对象的格式中可以看出不管哪种方式都需要正则表达式，那么什么是正则表达式呢？\n正则表达式定义了字符串组成的规则。也就是判断指定的字符串是否符合指定的规则，如果符合返回true，如果不符合返回false。\n正则表达式是和语言无关的。很多语言都支持正则表达式，Java语言也支持，只不过正则表达式在不同的语言中的使用方式不同，js 中需要使用正则对象来使用正则表达式。\n正则表达式常用的规则如下：\n\n^：表示开始\n\n$：表示结束\n\n[ ]：代表某个范围内的单个字符，比如： [0-9] 单个数字字符\n\n.：代表任意单个字符，除了换行和行结束符\n\n\\w：代表单词字符：字母、数字、下划线()，相当于 [A-Za-z0-9]\n\n\\d：代表数字字符： 相当于 [0-9]\n\n\n量词：\n\n+：至少一个\n\n*：零个或多个\n\n？：零个或一个\n\n{x}：x个\n\n{m,}：至少m个\n\n{m,n}：至少m个，最多n个\n\n\n","slug":"前端三件套基础入门","date":"2022-06-30T02:44:09.000Z","categories_index":"","tags_index":"前端","author_index":"Aurora"},{"id":"54e1d69dbe01003cc0c2e45b21bc6b3e","title":"Mybatis","content":"入门_MyBatis中文网(Mybatis.pdf)什么是Mybatis？\nMybatis是一款优秀的持久层框架，用于简化JDBC开发\n官网：https://mybatis.org/mybatis-3/zh/index.html\n\n持久层：\n\n负责将数据保存到数据库的那一层代码\n\nJavaEE三层架构：表现层，业务层，持久层\n\n\n框架：\n\n框架就是一个半成品软件，是一套可重用的、通用的、软件基础代码模型\n\n在框架的基础之上构建软件编写更加高效、规范、通用、可扩展\n\n\n\n快速入门\nJDBC写的是硬编码，后期维护很麻烦，无论是增删改查语句的修改，或者是用户名密码的改变，\nMyBatis虽然麻烦，不过很多步骤只做一次，后期维护非常的方便\n解决SQL映射文件的警告提示产生原因：IDEA和数据库没有建立连接，不识别表信息\n解决方法：在IDEA中配置MySQL数据库连接\n\n\nMapper代理开发\n目的\n1.解决原生方式中的硬编码\n2.简化后期执行SQL\n\n步骤\n1.定义与SQL映射文件同名的Mapper接口，并且将Mapper接口和SQL映射文件放置在同一目录下\n2.设置SQL映射文件的namespace属性为Mapper接口全限定名\n3.在Mapper接口中定义方法，方法名就是SQL映射文件中sql语句的id，并保持参数类型和返回值类型一致\n4.编码\n\n通过SqlSession的getMapper方法获取Mapper接口的代理对象\n调用对应方法完成sql的执行\n\n\n细节\n如果Mapper接口名称和SQL映射文件名称相同，并在同一目录下，则可以使用包扫描的方式简化SQL映射文件的加载\n&lt;mappers&gt;\n&lt;!--        加载sql映射文件--&gt;\n&lt;!--        &lt;mapper resource&#x3D;&quot;UserMapper.xml&quot;&#x2F;&gt;--&gt;\n&lt;!--        Mapper代理方式--&gt;\n        &lt;package name&#x3D;&quot;com.itheima.mapper&quot;&#x2F;&gt;\n    &lt;&#x2F;mappers&gt;\n\nMybatis核心配置文件详解\n注解完成增删改查\n注解即在接口方法上直接写SQL语句，不用在xml文件中再配置\n配置文件完成增删改查起别名\n定义&lt;sql&gt;片段\n定义&lt;resultMap&gt;片段\n注意事项\n参数占位符\n\n​      #{}: 执行SQL时，会将#{}占位符替换为?，将来自动设置参数值\n​      ${}: 拼SQL。会存在SQL注入问题\n​      使用时机：\n​      参数传递，都是用#{}\n​      如果要对表名，列名进行动态设置，只能使用${}进行sql拼接\n2.parameterType\n​\t\t用于设置参数类型，该参数可以省略\n3.SQL语句中特殊字符处理\n​\t转义字符\n&lt;![CDATA[内容]]&gt;\n动态SQLif标签：用于判断参数是否有值，使用test属性进行条件判断\n\n存在的问题：第一个条件不需要逻辑运算符\n\n解决方案：\n\n使用恒等式让所有条件格式都一样\n&lt;select id&#x3D;&quot;selectByCondition&quot; resultMap&#x3D;&quot;brandResultMap&quot;&gt;\n        select *\n        from tb_brand\nwhere 1 &#x3D; 1\n        &lt;if test&#x3D;&quot;status !&#x3D; null&quot;&gt;and status &#x3D; #&#123;status&#125;&lt;&#x2F;if&gt;\n        &lt;if test&#x3D;&quot;companyName !&#x3D; null and companyName !&#x3D; &#39;&#39;&quot;&gt;and company_name like #&#123;companyName&lt;&#x2F;if&gt;\n        &lt;if test&#x3D;&quot;brandName !&#x3D; null and brandName !&#x3D; &#39;&#39;&quot;&gt;and brand_name like #&#123;brandName&#125;&lt;&#x2F;if&gt;\n\n    &lt;&#x2F;select&gt;\n\n\n\n&lt;where&gt;标签替换where关键字\n&lt;select id&#x3D;&quot;selectByCondition&quot; resultMap&#x3D;&quot;brandResultMap&quot;&gt;\n        select *\n        from tb_brand\n&lt;where&gt;\n        &lt;if test&#x3D;&quot;status !&#x3D; null&quot;&gt; status &#x3D; #&#123;status&#125;&lt;&#x2F;if&gt;\n        &lt;if test&#x3D;&quot;companyName !&#x3D; null and companyName !&#x3D; &#39;&#39;&quot;&gt;and company_name like #&#123;companyName&lt;&#x2F;if&gt;\n        &lt;if test&#x3D;&quot;brandName !&#x3D; null and brandName !&#x3D; &#39;&#39;&quot;&gt;and brand_name like #&#123;brandName&#125;&lt;&#x2F;if&gt;&lt;&#x2F;where&gt;\n\n    &lt;&#x2F;select&gt;\n\n\n\n\n事务提交自动提交\nSqlSession sqlSession &#x3D; sqlSessionFactory.openSession(true);\n\n手动提交\nSqlSession sqlSession &#x3D; sqlSessionFactory.openSession();\n或\nSqlSession sqlSession &#x3D; sqlSessionFactory.openSession(false);\n\n事务后写sqlSession.commit();\n\n\n\n返回添加数据的主键\n&lt;insert useGeneratedKeys &#x3D; &quot;true&quot; keyProperty &#x3D; &quot;id&quot;&gt; \n\n\n\n\n\n上图（批量删除） 如果接口方法未加param注解，collection属性的值应该为array\n参数传递  \n参数封装\n\nMyBatis 参数封装：\n   单个参数：\n      1. POJO类型：直接使用，属性名 和 参数占位符名称 一致\n      2. Map集合：直接使用，键名 和 参数占位符名称 一致\n      3. Collection：封装为Map集合，可以使用@Param注解，替换Map集合中默认的arg键名\n          map.put(&quot;arg0&quot;,collection集合);\n          map.put(&quot;collection&quot;,collection集合);\n      4. List：封装为Map集合，可以使用@Param注解，替换Map集合中默认的arg键名\n          map.put(&quot;arg0&quot;,list集合);\n          map.put(&quot;collection&quot;,list集合);\n          map.put(&quot;list&quot;,list集合);\n      5. Array：封装为Map集合，可以使用@Param注解，替换Map集合中默认的arg键名\n          map.put(&quot;arg0&quot;,数组);\n          map.put(&quot;array&quot;,数组);\n      6. 其他类型：直接使用\n   多个参数：封装为Map集合,可以使用@Param注解，替换Map集合中默认的arg键名\n      map.put(&quot;arg0&quot;,参数值1)\n      map.put(&quot;param1&quot;,参数值1)\n      map.put(&quot;param2&quot;,参数值2)\n      map.put(&quot;agr1&quot;,参数值2)\n      ---------------@Param(&quot;username&quot;)\n      map.put(&quot;username&quot;,参数值1)\n      map.put(&quot;param1&quot;,参数值1)\n      map.put(&quot;param2&quot;,参数值2)\n      map.put(&quot;agr1&quot;,参数值2)\n\n \n\n\n","slug":"Mybatis","date":"2022-06-07T08:06:27.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"6f4f974e39a23a6637b9ccfa82544a76","title":"Maven","content":"\nMaven是专门用于管理和构建java项目的工具\n\nMaven的功能\n\n1、提供了一套标准化的项目结构\n\n2、提供了一套标准化的构建流程（编译，测试，打包，发布……）\n\n3、提供了一套依赖管理机制\n\n模型\n\n常见命令\ncompile 编译\nclean 清理\ntest 测试\npackage 打包\ninstall 安装\n\nIDEA配置Maven\nMaven坐标详解\n什么是坐标：\n\nMaven中的坐标是资源的唯一标识\n\n使用坐标来定义项目或引入项目中需要的依赖\n\n\n\nMaven坐标的主要组成\n\ngroupld：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima）\nartifactld：定义当前Maven项目名称（通常是模块名称）\nversion：定义当前项目版本号\n\n\n\n\nIDEA创建Maven项目\n依赖管理使用坐标导入jar包1.在pom.xml中编写&lt;dependencies&gt;标签\n2.在&lt;dependencies&gt;标签中 使用&lt;dependency&gt;引入坐标\n3.定义坐标的groupid，artifactld，version\n4.点击刷新按钮，使坐标生效(建议配置自动生效，无需刷新)\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;\n      &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;\n      &lt;version&gt;4.11&lt;&#x2F;version&gt;\n      &lt;scope&gt;test&lt;&#x2F;scope&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;\n      &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;\n      &lt;version&gt;5.1.48&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n  &lt;&#x2F;dependencies&gt;\n\n\n依赖范围 \n","slug":"Maven","date":"2022-05-18T08:50:49.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"f83fade08690f69bc32eef72fe024ed9","title":"JDBC总结","content":"JDBC快速入门\t(JDBC.pdf)1、编写代码步骤1、创建工程,导入驱动jar包\n jar包\n2、注册驱动Class.forName(&quot;com.mysql.jdbc.Driver&quot;);\n\n3、获取连接Connection conn &#x3D; DriverMannager.getConnection(url,username,password);\n\n4、定义SQL语句String sql &#x3D; &quot;&quot;;\n\n5、获取执行SQL的对象Statement stmt &#x3D; conn.createStatement();\n\n6、执行SQL语句stmt.executeUpdate(sql);  \n&#x2F;&#x2F;此方法会执行sql语句并返回受影响的行数。可以用\nint count &#x3D; stmt.executeUpdate(sql)接受返回值;\n\n7、处理返回结果8、释放资源stmt.close();\nconn.cloes();\n\n例\nAPI详解1、DriverManager1、注册驱动*** MYSQL 5之后的驱动包，可以省略注册驱动的步骤***\n\n这个方法可以完成驱动的注册，但是实际开发中一般不会使用这个方法完成驱动的注册\n原因：\n如果需要注册驱动，就会使用，DriverManager.registerDriver(new Driver()); ,但是查看源代码发现，在代码中一段静态代码块，静态代码块已经调用了注册驱动的方法。\n\n如果再手动调用该方法注册驱动，就会导致驱动被注册两次。实际开发中一般户次爱用;\nClass.forName(&quot;com.mysql.jdbc.Driver&quot;);\n\n2、获得与数据库的连接\n这个方法就是用来获得与数据库连接的方法，这个方法中的三个参数为 与数据库连接的路径(url)，与数据库连接的用户名(user)，与数据库连接的密码(password)。\n主要是url的写法：\njdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;db1\n\njdbc:mysql:&#x2F;&#x2F;ip地址:端口号&#x2F;数据库名称?参数键值对1&amp;参数键值对2...\n\nlocalhost           :连接的MySQL数据库服务器的主机ip地址。（连接是本机就可以写成localhost），如果连接不是本机的，就需要写上连接主机的IP地址。\nurl如果连接的是本机的路径，可以简化为如下格式：\njdbc:mysql:&#x2F;&#x2F;&#x2F;db1\n配置useSSL &#x3D; false 参数，禁用安全连接方式，解决警告提示\n2、Connection1、获取执行SQL对象普通执行SQL对象\nStatement createStatement();\n\n 预编译SQL的执行SQL对象；防止SQL注入\nPreparedStatement prepareStatement(sql);\n\n执行存储过程的对象\nCallableStatement prepareCall(sql)\n\n2、事务管理MYSQL事务管理开启事务：  begin;&#x2F;start transaction;\n提交事务：  commit;\n回滚事务：  rollback;\n\nMYSQL默认自动提交事务\n\nJDBC事务管理Connection接口中定义了3个对应的方法\n开启事务：setAutoCommit(bollean autoCommit): true为自动提交事务；false为手动提交事务，即为开启事务\n提交事务：commit()\n回滚事务：rollback()\n\n例：\npackage com.itheima.jdbc;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n&#x2F;**\n * JDBC API 详解：Connection\n *&#x2F;\npublic class JDBCDemo3_Connection &#123;\n\n    public static void main(String[] args) throws Exception &#123;\n        &#x2F;&#x2F;1. 注册驱动\n        &#x2F;&#x2F;Class.forName(&quot;com.mysql.jdbc.Driver&quot;);\n        &#x2F;&#x2F;2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写\n        String url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;db1?useSSL&#x3D;false&quot;;\n        String username &#x3D; &quot;root&quot;;\n        String password &#x3D; &quot;1234&quot;;\n        Connection conn &#x3D; DriverManager.getConnection(url, username, password);\n        &#x2F;&#x2F;3. 定义sql\n        String sql1 &#x3D; &quot;update account set money &#x3D; 3000 where id &#x3D; 1&quot;;\n        String sql2 &#x3D; &quot;update account set money &#x3D; 3000 where id &#x3D; 2&quot;;\n        &#x2F;&#x2F;4. 获取执行sql的对象 Statement\n        Statement stmt &#x3D; conn.createStatement();\n\n        try &#123;\n            &#x2F;&#x2F; 开启事务\n            conn.setAutoCommit(false);\n            &#x2F;&#x2F;5. 执行sql\n            int count1 &#x3D; stmt.executeUpdate(sql1);&#x2F;&#x2F;受影响的行数\n            &#x2F;&#x2F;6. 处理结果\n            System.out.println(count1);\n            int i &#x3D; 3&#x2F;0;\n            &#x2F;&#x2F;5. 执行sql\n            int count2 &#x3D; stmt.executeUpdate(sql2);&#x2F;&#x2F;受影响的行数\n            &#x2F;&#x2F;6. 处理结果\n            System.out.println(count2);\n\n            &#x2F;&#x2F; 提交事务\n            conn.commit();\n        &#125; catch (Exception throwables) &#123;\n            &#x2F;&#x2F; 回滚事务\n            conn.rollback();\n            throwables.printStackTrace();\n        &#125;\n\n\n\n        &#x2F;&#x2F;7. 释放资源\n        stmt.close();\n        conn.close();\n    &#125;\n&#125;\n\n3、Statement1、执行SQL语句int executeUpdate(sql):执行DML、DDL语句\n返回值（1）DML语句影响的行数（2）DDL语句执行后，执行成功也可能返回0\n\nResultSet executeQuery(sql):执行DQL语句\n返回值：Result结果集对象\n\n4、ResultSet封装了DQL查询语句的结果ResultSet stmt.executeQuery(sql); 执行DQL语句，返回ResultSet对象\n\n获取查询结果boolean next(): (1)将光标从当前位置向前移动一行 (2)判断当前行是否为有效行\n返回值 true：有效行，当前行有数据   false：无效行，当前行没有数据\n\nxxx getXxx(参数):获取数据\nxxx：数据类型，如 ： int getInt(参数) String getString(参数)\n参数：int： 列的编号，从1开始\n\t string：列的名称\n\n使用步骤1、游标向下移动一行，并判断该行是否有数据：next()\n2 、获取数据：getXxx(参数)\n&#x2F;&#x2F;循环判断游标是否是最后一行末尾\nwhile(rs.next())\n&#123;\n\t&#x2F;&#x2F;获取数据\n\trs.getXxx(参数);\n&#125;\n\n5、PreparedStatement作用：预编译SQL语句并执行，防止SQL注入问题如：用户名随便写，密码写成’ or ‘ 1 ‘ &#x3D; ‘1\n用法：1、获取PreparedStatement对象&#x2F;&#x2F;SQL语句中的参数值，使用？占位符替代\nString sql &#x3D; &quot;select * from user where username &#x3D; ? and password &#x3D; ？&quot;;\n&#x2F;&#x2F;通过Connection对象获取，并传入对应的SQL语句\nPreparedStatement pstmt &#x3D; conn.prepareStatement(sql);\n\n2、设置参数值PreparedStatement对象:setXxx(参数1,参数2):给？赋值\nXxx:数据类型，如setInt(参数1,参数2)\n参数：\n参数1：？的位置编号，从1开始\n参数2：？的值\n\n3、执行SQLexecuteUpdate();&#x2F;executeQuery(); :不需要再传递sql\n\n\n\n例public class JDBCDemo7_PreparedStatement &#123;\n\n    @Test\n    public void testPreparedStatement() throws  Exception &#123;\n       &#x2F;&#x2F;2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写\n       String url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;db1?useSSL&#x3D;false&quot;;\n       String username &#x3D; &quot;root&quot;;\n       String password &#x3D; &quot;1234&quot;;\n       Connection conn &#x3D; DriverManager.getConnection(url, username, password);\n\n       &#x2F;&#x2F; 接收用户输入 用户名和密码\n        String name &#x3D; &quot;zhangsan&quot;;\n        String pwd &#x3D; &quot;&#39; or &#39;1&#39; &#x3D; &#39;1&quot;;\n\n        &#x2F;&#x2F; 定义sql\n        String sql &#x3D; &quot;select * from tb_user where username &#x3D; ? and password &#x3D; ?&quot;;\n\n        &#x2F;&#x2F; 获取pstmt对象\n        PreparedStatement pstmt &#x3D; conn.prepareStatement(sql);\n\n        &#x2F;&#x2F; 设置？的值\n        pstmt.setString(1,name);\n        pstmt.setString(2,pwd);\n\n        &#x2F;&#x2F; 执行sql\n        ResultSet rs &#x3D; pstmt.executeQuery();\n\n        &#x2F;&#x2F; 判断登录是否成功\n        if(rs.next())&#123;\n            System.out.println(&quot;登录成功~&quot;);\n        &#125;else&#123;\n            System.out.println(&quot;登录失败~&quot;);\n        &#125;\n\n        &#x2F;&#x2F;7. 释放资源\n        rs.close();\n        pstmt.close();\n        conn.close();\n    &#125;\n\n好处：1、预编译SQL，性能更高\n2、防止SQL注入，将敏感字符进行转义\nPreparedStatement预编译功能开启：useServerPrepStmts&#x3D;true\n（参数键值对）应加在URL最后\n配置MySQL执行日志（重启mysql服务后生效）\nlog-output&#x3D;FILE\ngeneral-log&#x3D;1\ngeneral_log_file&#x3D;&quot;D:\\mysql.log&quot;\nslow-query-log&#x3D;1\nslow_query_log_file&#x3D;&quot;D:\\mysql_slow.log&quot;\nlong_query_time&#x3D;2\n\n原理：1、在获取PreparedStatement对象时，将sql语句发送给mysql服务器进行检查，编译（这些步骤很耗时）\n2、执行时就不用再进行这些步骤了，速度更快\n3、如果sql模板一样，则只需要进行一次检查编译\n\n数据库连接池简介\n数据库连接池是个容器，负责分配，，管理数据库连接\n\n它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个\n\n释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏\n\n好处：\n\n资源重用\n\n提升系统响应速度\n\n避免数据库连接遗漏\n\n\n\n\n数据库连接池实现标准接口\n官方（SUN）提供的数据库连接池标准接口，由第三方组织实现此接口。\n功能：获取连接\n\nConnection getConnection()\n\n常见的数据库连接池：\nDBCP\nC3P0\nDruid\n\nDruid（德鲁伊）\nDruid连接池是阿里巴巴开源的数据库连接池项目\n功能强大，性能优秀，是Java语言最好的数据库连接池之一\n\n","slug":"JDBC总结","date":"2022-05-07T02:47:07.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"758e18fa21f3b95498a42a108b10694c","title":"SQL总结","content":"SQL通用语法1.SQL语句可以单行或多行书写，以分号结尾。\n2.MYSQL数据库的SQL语句不区分大小写，关键字建议适用大写。\n3.注释\n （1） 单行注释：– 注释内容（两个横杠一个空格+注释内容） 或 #注释内容（MYSQL特有)\n（2） 多行注释： &#x2F;* 注释 *&#x2F;\n对 MYSQL 的 windows命令1、启动mysql服务net start mysql 启动 mysql 服务\nnet stop mysql 关闭 mysql 服务\n\n2、进入mysql，输入密码：mysql -hlocalhost -uroot -proot 进入mysql数据库，其中-h表示服务器名，localhost表示本地；\n-u为数据库用户名，root是mysql默认用户名；-p为密码，如果设置了密码，可直接在-p后直接输入。\n\nmysql -u root -p;\n\n对数据库的操作1、查看所有数据库mysql&gt; show databases;\n\n2、创建数据库mysql&gt; create database; 数据库名称\n如果数据库已经存在，则会报错\n可使用\nmysql&gt; create database if not exists; 数据库名称\n\n3、删除数据库drop database 数据库名称;\ndrop database if exists 数据库名称;\n\n4、使用数据库使用数据库 use 数据库名称;\n\n5、查看当前使用的数据库select database();\n\n对表的操作· 创建（create）\n·查询（retrieve）\n·修改（update）\n·删除（delete）\n1、创建（create）创建表create table 表名(\n\t\t字段名1 数据类型1,\n\t\t字段名2 数据类型2,\n\t\t...\n\t\t字段名n 数据类型n\n);\n\n最后一行末尾不能加逗号\n2、查询（retrieve）查询当前数据库下所有表名称show tables;\n\n查询表结构desc 表名称;\n\n3、修改（update）修改表名alter table 表名 rename to 新的表名;\n\n添加一列alter table 表名 add 列名 数据类型;\n\n修改数据类型alter table 表名 modify 列名 新数据类型;\n\n修改列名和数据类型alter table 表名 change 列名 新列名 新数据类型;\n\n删除列alter table 表名 drop 列名;\n\n\n\n4、删除（delete）删除表drop table 表名;\ndrop table if exists 表名;\n\n对数据的操作添加数据1、给指定列添加数据insert into 表名(列名1,列名2，...)values(值1,值2,...); \n\n2、给全部列添加数据insert into 表名 values(值1,值2,...);\n\n3、批量添加数据insert into 表名(列名1,列名2,...) values(值1,值2,...),(值1,值2,...),(值1,值2,...)...;\n\ninsert into 表名 values(值1,值2,...),(值1,值2,...),(值1,值2,...)...;\n\n修改数据1、修改表数据update 表名 set 列名1&#x3D;值1,列名2&#x3D;值2,...[where 条件];\n\n修改语句如果不加条件，则所有数据都将被修改!\n删除数据1、删除数据delete from 表名 [where 条件];\n\n删除语句如果不加条件，则所有数据都将被删除\n查询数据select\n\t字段列表\nfrom\n\t表名列表\nwhere\n\t条件列表\ngroup by\n\t分组字段\nhaving\n\t分组后条件\norder by\n\t排序字段\nlimit\n\t分页限定\n\n\n\n\n\n\n\n\n约束 \n外键约束\n数据库设计\n\n\n多表查询内连接隐式内连接\nselect 字段列表 from 表1,表2... where 条件;\n\n显式内连接\nselect 字段列表 from 表1 [inner] join 表2 on 条件；\n\n内连接相当于查询A B 交集数据\n外连接左外连接\nselect 字段列表 from 表1 left [outer] join 表2 on 条件；\n右外连接\nselect 字段列表 from 表1 right [outer] join 表2 on 条件；\n\n左外连接 ：相当于查询A表所有数据和交集部分数据\n右外连接 ：相当于查询B表所有数据和交集部分数据\n子查询子查询根据查询结果不同，作用不同;1、单行单列:作为条件值，使用&#x3D;,!&#x3D;,&gt;,&lt;等进行条件判断\nselect 字段列表 from 表 where 字段名 &#x3D; (子查询)；\n\n2、多行单列:作为条件值，使用in等关键字进行条件判断\nselect 字段列表 from 表 where 字段名 in (子查询)；\n\n 3、多行duolie:作为虚拟表\nselect 字段列表 from (子查询) where 条件；\n\n事物1、开启事务start transaction; 或者 begin;\n\n2、提交事务commit;\n\n3、回滚事务rollback;\n\n4、事务的特性\n5.事务提交mysql事务默认自动提交\n-- 查看事物的默认提交方式\nselect @@autocommit;\n-- 1 自动提交 0 手动提交\n-- 修改事务提交方式\nset @@autocommit &#x3D; 0;\n","slug":"SQL总结","date":"2022-04-30T08:59:10.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"a64b935a3dc12ce8d8b93a103ca9afe0","title":"java核心技术卷总结","content":"1.&amp;&amp;和|| 运算符是按照“短路”方式来求值的：如果第一个操作数已经能够确定表达式的值，第二个操作数就不必计算了。2.位移运算符的右操作数要完成模32的运算（除非左操作数是long类型，在这种情况下需要对右操作数模64）。例如，1&lt;&lt;35的值等同于1&lt;&lt;3或8。3.同一个级别的运算符按照从左到右的次序进行计算（但右结合运算符除外）&amp;&amp; 优先级大于 | | 。4.String类的substring方法可以从一个较大的字符串提取出一个子串。例如：    String greeting &#x3D; “Hello”;            String a &#x3D; greeting.substring(0,3);    打印 a 会输出    Hel。    即输出[a,b)。5.检测字符串是否相等string a &#x3D; “ok”;string b &#x3D; “ok”;a.equals(b)；“ok”.equals(“ok”);“ok”.equals(“b”);想要检测两个字符串是否相等，而不区分大小写，可用equalsIgnoreCase方法。“Hello”. equalsIgnoreCase(“hello”);6.一定不要使用&#x3D;&#x3D;来检测两个字符串是否相等!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! &#x3D;&#x3D;只能够确定两个字符串是否存放在同一位置上。当然，如果存放在同一位置上，它们必然相等。但是，完全有可能将内容相同的多个字符串副本放置在不同位置上。如果虚拟机始终将相同的字符串共享，就可以使用&#x3D;&#x3D;运算符检测是否相等。但实际上只有字符串字面量是共享的，而+或substring等操作得到的字符串并不共享。因此，千万不要视同&#x3D;&#x3D;运算符测试字符串的相等性！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！7.检查一个字符串既不是null也不是空串 if(str!&#x3D;null &amp;&amp; str.length()!&#x3D;0)。\n","slug":"java核心技术卷总结","date":"2022-04-25T11:48:12.000Z","categories_index":"","tags_index":"","author_index":"Aurora"}]