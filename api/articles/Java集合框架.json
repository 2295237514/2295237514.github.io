{"title":"Java集合框架","uid":"de47803b5d69541ea546c3889eeeba14","slug":"Java集合框架","date":"2022-11-20T08:41:47.000Z","updated":"2023-02-13T14:54:57.010Z","comments":true,"path":"api/articles/Java集合框架.json","keywords":null,"cover":[],"content":"<h1 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>HashMap基于哈希表的Map接口实现，是以key-value存储形式存在，即主要用来存放键值对。HashMap的实现不是同步的，这意味着他不是线程安全的，它的key、value都可以为null，此外，HashMap中的映射不是有序的。</p>\n<ol>\n<li><p>JDK 1.8之前是由数组+链表组成的。数组是HashMap的主体，链表则是主要为了解决哈希冲突**(两个对象调用的hashCode方法计算的哈希码值一致导致计算的数组索引值相同)**而存在的(‘拉链法解决hash冲突’)</p>\n</li>\n<li><p>JDK1.8 以后，<strong>当链表长度大于阈值（或者红黑树的边界值，默认为 8）并且当前数组的长度大于64时，此时此索引位置上的所有数据改为使用红黑树存储。</strong></p>\n</li>\n</ol>\n<p>补充：将链表转换成红黑树前会判断，即使阈值大于8，但是数组长度小于64，此时并不会将链表变为红黑树。而是选择进行数组扩容。</p>\n<p>这样做的目的是因为数组比较小，尽量避开红黑树结构，这种情况下变为红黑树结构，反而会降低效率，因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡 。同时数组长度小于64时，搜索时间相对要快些。所以综上所述为了提高性能和减少搜索时间，底层在阈值大于8并且数组长度大于64时，链表才转换为红黑树。具体可以参考 <code>treeifyBin</code>方法。</p>\n<p>当然虽然增了红黑树作为底层数据结构，结构变得复杂了，但是阈值大于8并且数组长度大于64时，链表转换为红黑树时，效率也变的更高效。</p>\n<h2 id=\"特点：\"><a href=\"#特点：\" class=\"headerlink\" title=\"特点：\"></a>特点：</h2><p>1.存取无序的</p>\n<p>2.键和值位置都可以是null，但是键位置只能是一个null</p>\n<p>3.键位置是唯一的，底层的数据结构控制键的</p>\n<p>4.jdk1.8前数据结构是：链表 + 数组  jdk1.8之后是 ： 链表 + 数组  + 红黑树</p>\n<p>5.阈值(边界值) &gt; 8 并且数组长度大于64，才将链表转换为红黑树，变为红黑树的目的是为了高效的查询。</p>\n<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20230213224322.png\"></p>\n<p>说明：</p>\n<p>1.面试题：HashMap中hash函数是怎么实现的？还有哪些hash函数的实现方式？</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">对于key的hashCode做hash操作，无符号右移16位然后做异或运算。\n还有平方取中法，伪随机数法和取余数法。这三种效率都比较低。而无符号右移16位异或运算效率是最高的。至于底层是如何计算的我们下面看源码时给大家讲解。</code></pre>\n\n<p>2.面试题：当两个对象的hashCode相等时会怎么样？</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">会产生哈希碰撞，若key值内容相同则替换旧的value.不然连接到链表后面，链表长度超过阈值8就转换为红黑树存储。</code></pre>\n\n<p>3.面试题：何时发生哈希碰撞和什么是哈希碰撞,如何解决哈希碰撞？</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">只要两个元素的key计算的哈希码值相同就会发生哈希碰撞。jdk8前使用链表解决哈希碰撞。jdk8之后使用链表+红黑树解决哈希碰撞。</code></pre>\n\n<p>4.面试题：如果两个键的hashcode相同，如何存储键值对？</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">hashcode相同，通过equals比较内容是否相同。\n相同：则新的value覆盖之前的value\n不相同：则将新的键值对添加到哈希表中</code></pre>\n\n<p>5.在不断的添加数据的过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。</p>\n<p>6.通过上述描述，当位于一个链表中的元素较多，即hash值相等但是内容不相等的元素较多时，通过key值依次查找的效率较低。而<strong>JDK1.8</strong>中，哈希表存储采用数组+链表+红黑树实现，当链表长度(阀值)超过 8 时且当前数组的长度 &gt; 64时，将链表转换为红黑树，这样大大减少了查找时间。jdk8在哈希表中引入红黑树的原因只是为了查找效率更高。</p>\n<p>简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的。如下图所示。</p>\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20230213224456.png\"></p>\n<p> <strong>但是这样的话问题来了，传统hashMap的缺点，1.8为什么引入红黑树？这样结构的话不是更麻烦了吗，为何阈值大于8换成红黑树？</strong></p>\n<p> JDK 1.8 以前 HashMap 的实现是 数组+链表，即使哈希函数取得再好，也很难达到元素百分百均匀分布。当 HashMap 中有大量的元素都存放到同一个桶中时，这个桶下有一条长长的链表，这个时候 HashMap 就相当于一个单链表，假如单链表有 n 个元素，遍历的时间复杂度就是 O(n)，完全失去了它的优势。针对这种情况，JDK 1.8 中引入了 红黑树（查找时间复杂度为 O(logn)）来优化这个问题。 当链表长度很小的时候，即使遍历，速度也非常快，但是当链表长度不断变长，肯定会对查询性能有一定的影响，所以才需要转成树。</p>\n<p>至于为什么阈值是8，我想，去源码中找寻答案应该是最可靠的途径。 下面我们在分析源码的时候会介绍。</p>\n<p><strong>jdk8存储过程:</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20230213224716.png\"></p>\n<h2 id=\"继承关系\"><a href=\"#继承关系\" class=\"headerlink\" title=\"继承关系\"></a>继承关系</h2><p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20230213224914.png\"></p>\n<p>说明：</p>\n<ul>\n<li>Cloneable 空接口，表示可以克隆。 创建并返回HashMap对象的一个副本。</li>\n<li>Serializable 序列化接口。属于标记性接口。HashMap对象可以被序列化和反序列化。 </li>\n<li>AbstractMap 父类提供了Map实现接口。以最大限度地减少实现此接口所需的工作。</li>\n</ul>\n<p>补充：通过上述继承关系我们发现一个很奇怪的现象， 就是HashMap已经继承了AbstractMap而AbstractMap类实现了Map接口，那为什么HashMap还要在实现Map接口呢？同样在ArrayList中LinkedList中都是这种结构。 </p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">据 java 集合框架的创始人Josh Bloch描述，这样的写法是一个失误。在java集合框架中，类似这样的写法很多，最开始写java集合框架的时候，他认为这样写，在某些地方可能是有价值的，直到他意识到错了。显然的，JDK的维护者，后来不认为这个小小的失误值得去修改，所以就这样存在下来了。</code></pre>\n\n<h2 id=\"成员\"><a href=\"#成员\" class=\"headerlink\" title=\"成员\"></a>成员</h2><h3 id=\"成员变量\"><a href=\"#成员变量\" class=\"headerlink\" title=\"成员变量\"></a>成员变量</h3><p>1.序列化版本号</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private static final long serialVersionUID &#x3D; 362498820763181265L;</code></pre>\n\n<p>2.集合的初始化容量( <strong>必须是二的n次幂</strong> )</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;默认的初始容量是16 -- 1&lt;&lt;4相当于1*2的4次方---1*16\nstatic final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4;   </code></pre>\n\n<p>问题： <strong>为什么必须是2的n次幂？如果输入值不是2的幂比如10会怎么样？</strong> </p>\n<p>HashMap构造方法还可以指定集合的初始化容量大小：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">HashMap(int initialCapacity) 构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap。</code></pre>\n\n<p> 根据上述讲解我们已经知道，当向HashMap中添加一个元素的时候，需要根据key的hash值，去确定其在数组中的具体位置。 HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现就在把数据存到哪个链表中的算法。</p>\n<p>这个算法实际就是取模，hash%length，计算机中直接求余效率不如位移运算(这点上述已经讲解)。所以源码中做了优化,使用 hash&amp;(length-1)，而实际上hash%length等于hash&amp;(length-1)的前提是length是2的n次幂。</p>\n<p>为什么这样能均匀分布减少碰撞呢？2的n次方实际就是1后面n个0，2的n次方-1  实际就是n个1；</p>\n<p>小结：</p>\n<p>​\t1.由上面可以看出，当我们根据key的hash确定其在数组的位置时，如果n为2的幂次方，可以保证数据的均匀插入，如果n不是2的幂次方，可能数组的一些位置永远不会插入数据，浪费数组的空间，加大hash冲突。</p>\n<p>​    2.另一方面，一般我们可能会想通过 % 求余来确定位置，这样也可以，只不过性能不如 &amp; 运算。而且当n是2的幂次方时：hash &amp; (length - 1) &#x3D;&#x3D; hash % length</p>\n<p>​\t3.因此，HashMap 容量为2次幂的原因，就是为了数据的的均匀分布，减少hash冲突，毕竟hash冲突越大，代表数组中一个链的长度越大，这样的话会降低hashmap的性能</p>\n<p>​\t<strong>4.如果创建HashMap对象时，输入的数组长度是10，不是2的幂，HashMap通过一通位移运算和或运算得到的肯定是2的幂次数，并且是离那个数最近的数字。</strong></p>\n<h1 id=\"集合概述\"><a href=\"#集合概述\" class=\"headerlink\" title=\"集合概述\"></a>集合概述</h1><ul>\n<li><strong>概念</strong>：对象的容器，定义了对多个对象进项操作的的常用方法。可实现数组的功能。</li>\n<li><strong>和数组的区别</strong>：</li>\n</ul>\n<ol>\n<li>数组长度固定，集合长度不固定。</li>\n<li>数组可以存储基本类型和引用类型，集合只能存储引用类型。</li>\n</ol>\n<ul>\n<li><strong>位置</strong>： java.util.*;</li>\n</ul>\n<h2 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a>Collection</h2><p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20221120165256.png\"></p>\n<h3 id=\"Collection父接口\"><a href=\"#Collection父接口\" class=\"headerlink\" title=\"Collection父接口\"></a>Collection父接口</h3><ul>\n<li><p>特点：代表一组任意类型的对象，无序，无下标，不能重复。</p>\n</li>\n<li><p>方法：</p>\n<ul>\n<li><code>boolean add(Object obj) //添加一个对象。</code></li>\n<li><code>boolean addAll(Collection c) //讲一个集合中的所有对象添加到此集合中。</code></li>\n<li><code>void clear() //清空此集合中的所有对象。</code></li>\n<li><code>boolean contains(Object o) //检查此集合中是否包含o对象。</code></li>\n<li><code>boolean equals(Object o) //比较此集合是否与指定对象相等。</code></li>\n<li><code>boolean isEmpty() //判断此集合是否为空。</code></li>\n<li><code>boolean remove(Object o) //在此集合中移除o对象。</code></li>\n<li><code>int size() //返回此集合中的元素个数。</code></li>\n<li><code>Object[] toArray() //姜此集合转换成数组。</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Collection子接口\"><a href=\"#Collection子接口\" class=\"headerlink\" title=\"Collection子接口\"></a>Collection子接口</h3>","feature":true,"text":"HashMap简介HashMap基于哈希表的Map接口实现，是以key-value存储形式存在，即主要用来存放键值对。HashMap的实现不是同步的，这意味着他不是线程安全的，它的key、value都可以为null，此外，HashMap中的映射不是有序的。 JDK 1.8之前是由...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#HashMap\"><span class=\"toc-text\">HashMap</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">简介</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%89%B9%E7%82%B9%EF%BC%9A\"><span class=\"toc-text\">特点：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">数据结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">继承关系</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%88%90%E5%91%98\"><span class=\"toc-text\">成员</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">成员变量</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">集合概述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Collection\"><span class=\"toc-text\">Collection</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Collection%E7%88%B6%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">Collection父接口</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Collection%E5%AD%90%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">Collection子接口</span></a></li></ol></li></ol></li></ol>","author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Redis入门","uid":"9d6afd20d8190b4b550aed150e5e2779","slug":"Redis入门","date":"2023-01-09T02:59:24.000Z","updated":"2023-01-10T05:31:27.002Z","comments":true,"path":"api/articles/Redis入门.json","keywords":null,"cover":[],"text":"NOSQL优点1.解决CPU及内存压力 2.解决IO压力 概述NoSQL(NoSQL &#x3D; Not Only SQL )，意即“不仅仅是SQL”，泛指非关系型的数据库。 NoSQL 不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[],"tags":[],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"面试精选问题","uid":"81ee9368cecd59974c7ff981e1f45f53","slug":"面试精选问题","date":"2022-09-26T08:13:25.000Z","updated":"2022-12-20T01:54:28.227Z","comments":true,"path":"api/articles/面试精选问题.json","keywords":null,"cover":"https://pixabay.com/zh/photos/dog-pet-american-eskimo-palmerian-7651002/","text":"JAVA1.一道关于Integer的面试题1，来，先来一道考题，你看做对了吗？ Integer i1 &#x3D; new Integer(66); Integer i2 &#x3D; new Integer(66); System.out.println(i1 &#x3D;&#...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[],"tags":[],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}