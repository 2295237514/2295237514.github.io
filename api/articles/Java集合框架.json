{"title":"Java集合框架","uid":"de47803b5d69541ea546c3889eeeba14","slug":"Java集合框架","date":"2022-11-20T08:41:47.000Z","updated":"2023-02-18T08:42:01.482Z","comments":true,"path":"api/articles/Java集合框架.json","keywords":null,"cover":[],"content":"<h1 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h1><h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>1：put方法：put(key，value)，我们经常用存储一些常用的数据，比如flag、百分比之类的，我们就可以返回map结构，如果key相同则值会覆盖，允许key和value为null。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">2：get方法：get(key)，主要用来取map中存储的数据，我们根据其key值，可以取到对应的value值，没有该key对应的值则返回null。\n\n3：remove方法：remove(key)，主要用来删除map中对应的key及其value值。\n\n4：clear方法，用法：clear()，会清空map中的数据。\n\n5：containsKey(key)，判断map集合中是否包含某个key。\n\n6：containsValue(value)，判断map集合中是否包含某个value。\n\n7：entrySet()：hashmap.entrySet().iterator()，entrySet()的效率比keySet()要高。key和value存储在entry对象里面，遍历的时候，拿到entry对象就可以取到value了。\n\n8：keySet()：hashmap.keySet().iterator()，keySet是把key放到一个set集合中，通过迭代器遍历，再用hashmap.get(key)来取到value的值。</code></pre>\n<p>9：Map.getOrDefault(key，默认值)；</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">map.put(curr.val, map.getOrDefault(curr.val, 0) + 1);\n&#x2F;&#x2F;Map中会存储一一对应的key和value。\n&#x2F;&#x2F;如果 在Map中存在key，则返回key所对应的的value。\n&#x2F;&#x2F;如果 在Map中不存在key，则返回默认值。</code></pre>\n\n\n\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>HashMap基于哈希表的Map接口实现，是以key-value存储形式存在，即主要用来存放键值对。HashMap的实现不是同步的，这意味着他不是线程安全的，它的key、value都可以为null，此外，HashMap中的映射不是有序的。</p>\n<ol>\n<li><p>JDK 1.8之前是由数组+链表组成的。数组是HashMap的主体，链表则是主要为了解决哈希冲突**(两个对象调用的hashCode方法计算的哈希码值一致导致计算的数组索引值相同)**而存在的(‘拉链法解决hash冲突’)</p>\n</li>\n<li><p>JDK1.8 以后，<strong>当链表长度大于阈值（或者红黑树的边界值，默认为 8）并且当前数组的长度大于64时，此时此索引位置上的所有数据改为使用红黑树存储。</strong></p>\n</li>\n</ol>\n<p>补充：将链表转换成红黑树前会判断，即使阈值大于8，但是数组长度小于64，此时并不会将链表变为红黑树。而是选择进行数组扩容。</p>\n<p>这样做的目的是因为数组比较小，尽量避开红黑树结构，这种情况下变为红黑树结构，反而会降低效率，因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡 。同时数组长度小于64时，搜索时间相对要快些。所以综上所述为了提高性能和减少搜索时间，底层在阈值大于8并且数组长度大于64时，链表才转换为红黑树。具体可以参考 <code>treeifyBin</code>方法。</p>\n<p>当然虽然增了红黑树作为底层数据结构，结构变得复杂了，但是阈值大于8并且数组长度大于64时，链表转换为红黑树时，效率也变的更高效。</p>\n<h2 id=\"特点：\"><a href=\"#特点：\" class=\"headerlink\" title=\"特点：\"></a>特点：</h2><p>1.存取无序的</p>\n<p>2.键和值位置都可以是null，但是键位置只能是一个null</p>\n<p>3.键位置是唯一的，底层的数据结构控制键的</p>\n<p>4.jdk1.8前数据结构是：链表 + 数组  jdk1.8之后是 ： 链表 + 数组  + 红黑树</p>\n<p>5.阈值(边界值) &gt; 8 并且数组长度大于64，才将链表转换为红黑树，变为红黑树的目的是为了高效的查询。</p>\n<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20230213224322.png\"></p>\n<p>说明：</p>\n<p>1.面试题：HashMap中hash函数是怎么实现的？还有哪些hash函数的实现方式？</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">对于key的hashCode做hash操作，无符号右移16位然后做异或运算。\n还有平方取中法，伪随机数法和取余数法。这三种效率都比较低。而无符号右移16位异或运算效率是最高的。至于底层是如何计算的我们下面看源码时给大家讲解。</code></pre>\n\n<p>2.面试题：当两个对象的hashCode相等时会怎么样？</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">会产生哈希碰撞，若key值内容相同则替换旧的value.不然连接到链表后面，链表长度超过阈值8就转换为红黑树存储。</code></pre>\n\n<p>3.面试题：何时发生哈希碰撞和什么是哈希碰撞,如何解决哈希碰撞？</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">只要两个元素的key计算的哈希码值相同就会发生哈希碰撞。jdk8前使用链表解决哈希碰撞。jdk8之后使用链表+红黑树解决哈希碰撞。</code></pre>\n\n<p>4.面试题：如果两个键的hashcode相同，如何存储键值对？</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">hashcode相同，通过equals比较内容是否相同。\n相同：则新的value覆盖之前的value\n不相同：则将新的键值对添加到哈希表中</code></pre>\n\n<p>5.在不断的添加数据的过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。</p>\n<p>6.通过上述描述，当位于一个链表中的元素较多，即hash值相等但是内容不相等的元素较多时，通过key值依次查找的效率较低。而<strong>JDK1.8</strong>中，哈希表存储采用数组+链表+红黑树实现，当链表长度(阀值)超过 8 时且当前数组的长度 &gt; 64时，将链表转换为红黑树，这样大大减少了查找时间。jdk8在哈希表中引入红黑树的原因只是为了查找效率更高。</p>\n<p>简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的。如下图所示。</p>\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20230213224456.png\"></p>\n<p> <strong>但是这样的话问题来了，传统hashMap的缺点，1.8为什么引入红黑树？这样结构的话不是更麻烦了吗，为何阈值大于8换成红黑树？</strong></p>\n<p> JDK 1.8 以前 HashMap 的实现是 数组+链表，即使哈希函数取得再好，也很难达到元素百分百均匀分布。当 HashMap 中有大量的元素都存放到同一个桶中时，这个桶下有一条长长的链表，这个时候 HashMap 就相当于一个单链表，假如单链表有 n 个元素，遍历的时间复杂度就是 O(n)，完全失去了它的优势。针对这种情况，JDK 1.8 中引入了 红黑树（查找时间复杂度为 O(logn)）来优化这个问题。 当链表长度很小的时候，即使遍历，速度也非常快，但是当链表长度不断变长，肯定会对查询性能有一定的影响，所以才需要转成树。</p>\n<p>至于为什么阈值是8，我想，去源码中找寻答案应该是最可靠的途径。 下面我们在分析源码的时候会介绍。</p>\n<p><strong>jdk8存储过程:</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20230213224716.png\"></p>\n<h2 id=\"继承关系\"><a href=\"#继承关系\" class=\"headerlink\" title=\"继承关系\"></a>继承关系</h2><p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20230213224914.png\"></p>\n<p>说明：</p>\n<ul>\n<li>Cloneable 空接口，表示可以克隆。 创建并返回HashMap对象的一个副本。</li>\n<li>Serializable 序列化接口。属于标记性接口。HashMap对象可以被序列化和反序列化。 </li>\n<li>AbstractMap 父类提供了Map实现接口。以最大限度地减少实现此接口所需的工作。</li>\n</ul>\n<p>补充：通过上述继承关系我们发现一个很奇怪的现象， 就是HashMap已经继承了AbstractMap而AbstractMap类实现了Map接口，那为什么HashMap还要在实现Map接口呢？同样在ArrayList中LinkedList中都是这种结构。 </p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">据 java 集合框架的创始人Josh Bloch描述，这样的写法是一个失误。在java集合框架中，类似这样的写法很多，最开始写java集合框架的时候，他认为这样写，在某些地方可能是有价值的，直到他意识到错了。显然的，JDK的维护者，后来不认为这个小小的失误值得去修改，所以就这样存在下来了。</code></pre>\n\n<h2 id=\"成员\"><a href=\"#成员\" class=\"headerlink\" title=\"成员\"></a>成员</h2><h3 id=\"成员变量\"><a href=\"#成员变量\" class=\"headerlink\" title=\"成员变量\"></a>成员变量</h3><p>1.序列化版本号</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private static final long serialVersionUID &#x3D; 362498820763181265L;</code></pre>\n\n<p>2.集合的初始化容量( <strong>必须是二的n次幂</strong> )</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;默认的初始容量是16 -- 1&lt;&lt;4相当于1*2的4次方---1*16\nstatic final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4;   </code></pre>\n\n<p>问题： <strong>为什么必须是2的n次幂？如果输入值不是2的幂比如10会怎么样？</strong> </p>\n<p>HashMap构造方法还可以指定集合的初始化容量大小：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">HashMap(int initialCapacity) 构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap。</code></pre>\n\n<p> 根据上述讲解我们已经知道，当向HashMap中添加一个元素的时候，需要根据key的hash值，去确定其在数组中的具体位置。 HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现就在把数据存到哪个链表中的算法。</p>\n<p>这个算法实际就是取模，hash%length，计算机中直接求余效率不如位移运算(这点上述已经讲解)。所以源码中做了优化,使用 hash&amp;(length-1)，而实际上hash%length等于hash&amp;(length-1)的前提是length是2的n次幂。</p>\n<p>为什么这样能均匀分布减少碰撞呢？2的n次方实际就是1后面n个0，2的n次方-1  实际就是n个1；</p>\n<p>小结：</p>\n<p>​\t1.由上面可以看出，当我们根据key的hash确定其在数组的位置时，如果n为2的幂次方，可以保证数据的均匀插入，如果n不是2的幂次方，可能数组的一些位置永远不会插入数据，浪费数组的空间，加大hash冲突。</p>\n<p>​    2.另一方面，一般我们可能会想通过 % 求余来确定位置，这样也可以，只不过性能不如 &amp; 运算。而且当n是2的幂次方时：hash &amp; (length - 1) &#x3D;&#x3D; hash % length</p>\n<p>​\t3.因此，HashMap 容量为2次幂的原因，就是为了数据的的均匀分布，减少hash冲突，毕竟hash冲突越大，代表数组中一个链的长度越大，这样的话会降低hashmap的性能</p>\n<p>​\t<strong>4.如果创建HashMap对象时，输入的数组长度是10，不是2的幂，HashMap通过一通位移运算和或运算得到的肯定是2的幂次数，并且是离那个数最近的数字。</strong></p>\n<p>源代码如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;创建HashMap集合的对象，指定数组长度是10，不是2的幂\nHashMap hashMap &#x3D; new HashMap(10);\npublic HashMap(int initialCapacity) &#123;&#x2F;&#x2F;initialCapacity&#x3D;10\n   this(initialCapacity, DEFAULT_LOAD_FACTOR);\n &#125;\npublic HashMap(int initialCapacity, float loadFactor) &#123;&#x2F;&#x2F;initialCapacity&#x3D;10\n     if (initialCapacity &lt; 0)\n            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +\n                                               initialCapacity);\n        if (initialCapacity &gt; MAXIMUM_CAPACITY)\n            initialCapacity &#x3D; MAXIMUM_CAPACITY;\n        if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))\n            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +\n                                               loadFactor);\n    this.loadFactor &#x3D; loadFactor;\n    this.threshold &#x3D; tableSizeFor(initialCapacity);&#x2F;&#x2F;initialCapacity&#x3D;10\n&#125;\n  &#x2F;**\n   * Returns a power of two size for the given target capacity.\n  *&#x2F;\n    static final int tableSizeFor(int cap) &#123;&#x2F;&#x2F;int cap &#x3D; 10\n        int n &#x3D; cap - 1;\n        n |&#x3D; n &gt;&gt;&gt; 1;\n        n |&#x3D; n &gt;&gt;&gt; 2;\n        n |&#x3D; n &gt;&gt;&gt; 4;\n        n |&#x3D; n &gt;&gt;&gt; 8;\n        n |&#x3D; n &gt;&gt;&gt; 16;\n        return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    &#125;</code></pre>\n\n\n\n<ol>\n<li>默认的负载因子，默认值是0.75</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</code></pre>\n\n<ol start=\"2\">\n<li>当链表的值超过8则会转红黑树(<strong>1.8新增</strong>)</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;当桶(bucket)上的结点数大于这个值时会转成红黑树\nstatic final int TREEIFY_THRESHOLD &#x3D; 8;</code></pre>\n\n<p>因为树节点的大小大约是普通节点的两倍，所以我们只在箱子包含足够的节点时才使用树节点(参见TREEIFY_THRESHOLD)。当它们变得太小(由于删除或调整大小)时，就会被转换回普通的桶。在使用分布良好的用户hashcode时，很少使用树箱。理想情况下，在随机哈希码下，箱子中节点的频率服从<strong>泊松分布</strong></p>\n<p>因为树节点的大小大约是普通节点的两倍，所以我们只在箱子包含足够的节点时才使用树节点(参见TREEIFY_THRESHOLD)。当它们变得太小(由于删除或调整大小)时，就会被转换回普通的桶。在使用分布良好的用户hashcode时，很少使用树箱。理想情况下，在随机哈希码下，箱子中节点的频率服从泊松分布</p>\n<p><strong>红黑树的平均查找长度是log(n)，如果长度为8，平均查找长度为log(8)&#x3D;3，链表的平均查找长度为n&#x2F;2，当长度为8时，平均查找长度为8&#x2F;2&#x3D;4，这才有转换成树的必要；链表长度如果是小于等于6，6&#x2F;2&#x3D;3，而log(6)&#x3D;2.6，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。</strong></p>\n<ol start=\"3\">\n<li>集合最大容量</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;集合最大容量的上限是：2的30次幂\nstatic final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;</code></pre>\n\n<p>原因：</p>\n<p>1 int类型是32位整型，占4个字节。</p>\n<p>2 Java的原始类型里没有无符号类型。 –&gt; 所以首位是符号位 正数为0，负数为1</p>\n<p>3 java中存放的是补码，1左移31位的为 16进制的0x80000000代表的是-2147483648–&gt;所以最大只能是30</p>\n<p><strong>1 &lt;&lt; 30 &#x3D; 1073741824</strong><br><strong>1 &lt;&lt; 31 &#x3D; -2147483648</strong><br>1 &lt;&lt; 32 &#x3D; 1<br>1 &lt;&lt; 33 &#x3D; 2<br>1 &lt;&lt; -1 &#x3D; -2147483648</p>\n<hr>\n<ol start=\"4\">\n<li><strong>当链表的值小于6则会从红黑树转回链表</strong></li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;当桶(bucket)上的结点数小于这个值时树转链表\nstatic final int UNTREEIFY_THRESHOLD &#x3D; 6;</code></pre>\n\n<ol start=\"5\">\n<li><strong>当Map里面的数量超过这个值时，表中的桶才能进行树形化 ，否则桶内元素太多时会扩容，而不是树形化 为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD (8)</strong></li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;桶中结构转化为红黑树对应的数组长度最小的值 \nstatic final int MIN_TREEIFY_CAPACITY &#x3D; 64;</code></pre>\n\n<ol start=\"6\">\n<li><strong>table用来初始化(必须是二的n次幂)(重点)</strong></li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;存储元素的数组 \ntransient Node&lt;K,V&gt;[] table;</code></pre>\n\n<p><strong>table</strong>在JDK1.8中我们了解到HashMap是由数组加链表加红黑树来组成的结构其中table就是HashMap中的数组，jdk8之前数组类型是Entry&lt;K,V&gt;类型。从jdk1.8之后是Node&lt;K,V&gt;类型。只是换了个名字，都实现了一样的接口：Map.Entry&lt;K,V&gt;。负责存储键值对数据的。</p>\n<ol start=\"7\">\n<li>用来存放缓存</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;存放具体元素的集合\ntransient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</code></pre>\n\n<ol start=\"8\">\n<li><strong>HashMap中存放元素的个数(重点)</strong></li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;存放元素的个数，注意这个不等于数组的长度。\n transient int size;</code></pre>\n\n<p><strong>size</strong>为HashMap中K-V的实时数量，不是数组table的长度。</p>\n<ol start=\"9\">\n<li>用来记录HashMap的修改次数</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 每次扩容和更改map结构的计数器\n transient int modCount;  </code></pre>\n\n<ol start=\"10\">\n<li>用来调整大小下一个容量的值计算方式为(容量*负载因子)</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 临界值 当实际大小(容量*负载因子)超过临界值时，会进行扩容\nint threshold;</code></pre>\n\n<ol start=\"11\">\n<li><strong>哈希表的加载因子(重点)</strong></li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 加载因子\nfinal float loadFactor;</code></pre>\n\n<p><strong>说明：</strong></p>\n<p>1.<strong>loadFactor</strong>加载因子，是用来衡量 HashMap 满的程度，<strong>表示HashMap的疏密程度，影响hash操作到同一个数组位置的概率</strong>，计算HashMap的实时加载因子的方法为：size&#x2F;capacity，而不是占用桶的数量去除以capacity。capacity 是桶的数量，也就是 table 的长度length。</p>\n<p><strong>loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值</strong>。</p>\n<p><strong>当HashMap里面容纳的元素已经达到HashMap数组长度的75%时，表示HashMap太挤了，需要扩容，而扩容这个过程涉及到 rehash、复制数据等操作，非常消耗性能。，所以开发中尽量减少扩容的次数，可以通过创建HashMap集合对象时指定初始容量来尽量避免。</strong></p>\n<p><strong>同时在HashMap的构造器中可以定制loadFactor。</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">构造方法：\nHashMap(int initialCapacity, float loadFactor) 构造一个带指定初始容量和加载因子的空 HashMap。</code></pre>\n\n\n\n<p>2.为什么加载因子设置为0.75,初始化临界值是12？</p>\n<p>loadFactor越趋近于1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。</p>\n<hr>\n<ul>\n<li><strong>threshold</strong>计算公式：capacity(数组长度默认16) * loadFactor(负载因子默认0.75)。这个值是当前已占用数组长度的最大值。<strong>当Size&gt;&#x3D;threshold</strong>的时候，那么就要考虑对数组的resize(扩容)，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。 扩容后的 HashMap 容量是之前容量的两倍.</li>\n</ul>\n<h2 id=\"遍历方式\"><a href=\"#遍历方式\" class=\"headerlink\" title=\"遍历方式\"></a>遍历方式</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class HashMapStudy &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;一般来说,最好初始化一下, 小于12的就不要初始化了\n        &#x2F;&#x2F; 默认的就是16,因为加载因子是0.75,也就是到16*0.75&#x3D;12的时候会扩容\n        Map&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;(3);\n\n        map.put(&quot;welcome&quot;,&quot;to&quot;);\n        map.put(&quot;java&quot;,&quot;study&quot;);\n        map.put(&quot;wechat&quot;,&quot;best396975802&quot;);\n\n        &#x2F;&#x2F;遍历方法1: 先遍历key , 再取出value\n        System.out.println(&quot;遍历方法1: 先遍历key , 再取出value&quot;);\n        for (String key : map.keySet()) &#123;\n            System.out.println(&quot;key is &quot;+key);\n            System.out.println(&quot;value is &quot;+ map.get(key));\n        &#125;\n        &#x2F;&#x2F;遍历方法2: 直接遍历value\n        System.out.println(&quot;遍历方法2: 直接遍历value&quot;);\n        for (String value : map.values()) &#123;\n            System.out.println(&quot;value is &quot;+value);\n        &#125;\n\n        &#x2F;&#x2F;遍历方法3: 通过遍历entry来取Key和value,推荐的方法!!!\n        System.out.println(&quot;遍历方法3: 通过遍历entry来取Key和value,推荐的方法!!!&quot;);\n        for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;\n            System.out.println(&quot;key is &quot;+entry.getKey());\n            System.out.println(&quot;value is &quot;+ entry.getValue());\n        &#125;\n\n        &#x2F;&#x2F;遍历方法4: 通过forEach方法直接遍历key和value\n        System.out.println(&quot;遍历方法4: 通过forEach方法直接遍历&quot;);\n        map.forEach((key,value)-&gt;&#123;\n            System.out.println(&quot;key is &quot;+ key);\n            System.out.println(&quot;value is &quot;+ value);\n        &#125;);\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"容量的初始化\"><a href=\"#容量的初始化\" class=\"headerlink\" title=\"容量的初始化\"></a>容量的初始化</h2><p>把默认容量的数字设置成  initialCapacity&#x2F; 0.75F + 1.0F</p>\n<h1 id=\"集合概述\"><a href=\"#集合概述\" class=\"headerlink\" title=\"集合概述\"></a>集合概述</h1><ul>\n<li><strong>概念</strong>：对象的容器，定义了对多个对象进项操作的的常用方法。可实现数组的功能。</li>\n<li><strong>和数组的区别</strong>：</li>\n</ul>\n<ol>\n<li>数组长度固定，集合长度不固定。</li>\n<li>数组可以存储基本类型和引用类型，集合只能存储引用类型。</li>\n</ol>\n<ul>\n<li><strong>位置</strong>： java.util.*;</li>\n</ul>\n<h2 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a>Collection</h2><p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20221120165256.png\"></p>\n<h3 id=\"Collection父接口\"><a href=\"#Collection父接口\" class=\"headerlink\" title=\"Collection父接口\"></a>Collection父接口</h3><ul>\n<li><p>特点：代表一组任意类型的对象，无序，无下标，不能重复。</p>\n</li>\n<li><p>方法：</p>\n<ul>\n<li><code>boolean add(Object obj) //添加一个对象。</code></li>\n<li><code>boolean addAll(Collection c) //讲一个集合中的所有对象添加到此集合中。</code></li>\n<li><code>void clear() //清空此集合中的所有对象。</code></li>\n<li><code>boolean contains(Object o) //检查此集合中是否包含o对象。</code></li>\n<li><code>boolean equals(Object o) //比较此集合是否与指定对象相等。</code></li>\n<li><code>boolean isEmpty() //判断此集合是否为空。</code></li>\n<li><code>boolean remove(Object o) //在此集合中移除o对象。</code></li>\n<li><code>int size() //返回此集合中的元素个数。</code></li>\n<li><code>Object[] toArray() //姜此集合转换成数组。</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Collection子接口\"><a href=\"#Collection子接口\" class=\"headerlink\" title=\"Collection子接口\"></a>Collection子接口</h3><h1 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h1><p><strong>增加：</strong><br>add(E e)：在链表后添加一个元素；   通用方法<br>addFirst(E e)：在链表头部插入一个元素；  特有方法<br>addLast(E e)：在链表尾部添加一个元素；  特有方法<br>push(E e)：与addFirst方法一致<br>offer(E e)：在链表尾部插入一个元素<br>add(int index, E element)：在指定位置插入一个元素。<br>offerFirst(E e)：JDK1.6版本之后，在头部添加； 特有方法<br>offerLast(E e)：JDK1.6版本之后，在尾部添加； 特有方法</p>\n<p><strong>删除：</strong><br>remove() ：移除链表中第一个元素;    通用方法<br>remove(E e)：移除指定元素；   通用方法<br>removeFirst(E e)：删除头，获取元素并删除；  特有方法<br>removeLast(E e)：删除尾；  特有方法<br>pollFirst()：删除头；  特有方法<br>pollLast()：删除尾；  特有方法<br>pop()：和removeFirst方法一致，删除头。<br>poll()：查询并移除第一个元素     特有方法    </p>\n<p><strong>查：</strong><br>get(int index)：按照下标获取元素；  通用方法<br>getFirst()：获取第一个元素；  特有方法<br>getLast()：获取最后一个元素； 特有方法<br>peek()：获取第一个元素，但是不移除；  特有方法<br>peekFirst()：获取第一个元素，但是不移除；<br>peekLast()：获取最后一个元素，但是不移除；<br>pollFirst()：查询并删除头；  特有方法<br>pollLast()：删除尾；  特有方法<br>poll()：查询并移除第一个元素     特有方法</p>\n<h1 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h1><p>1、add(Object element) 方法<br>2、size()  方法<br>3、get(int  index)   方法<br>4、add(int index, Object element)  方法<br>5、set(int i, Object element) 方法<br>6、clear() 方法<br>7、isEmpty() 方法<br>8、iterator()  方法<br>9、contains(Object o)  方法<br>10、remove(int  index)  方法<br>11、remove(Object o)  方法</p>\n<h1 id=\"Queue\"><a href=\"#Queue\" class=\"headerlink\" title=\"Queue\"></a>Queue</h1><p>add\t增加一个元索\t如果队列已满，则抛出一个IIIegaISlabEepeplian异常<br>remove\t移除并返回队列头部的元素\t如果队列为空，则抛出一个NoSuchElementException异常<br>element\t返回队列头部的元素\t如果队列为空，则抛出一个NoSuchElementException异常<br>offer\t添加一个元素并返回true\t如果队列已满，则返回false<br>poll\t移除并返问队列头部的元素\t如果队列为空，则返回null<br>peek\t返回队列头部的元素\t如果队列为空，则返回null<br>put\t添加一个元素\t如果队列满，则阻塞<br>take\t移除并返回队列头部的元素\t如果队列为空，则阻塞</p>\n","feature":true,"text":"HashMap方法1：put方法：put(key，value)，我们经常用存储一些常用的数据，比如flag、百分比之类的，我们就可以返回map结构，如果key相同则值会覆盖，允许key和value为null。 2：get方法：get(key)，主要用来取map中存储的数据，我们根...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#HashMap\"><span class=\"toc-text\">HashMap</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">简介</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%89%B9%E7%82%B9%EF%BC%9A\"><span class=\"toc-text\">特点：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">数据结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">继承关系</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%88%90%E5%91%98\"><span class=\"toc-text\">成员</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">成员变量</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">遍历方式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%B9%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">容量的初始化</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">集合概述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Collection\"><span class=\"toc-text\">Collection</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Collection%E7%88%B6%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">Collection父接口</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Collection%E5%AD%90%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">Collection子接口</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#LinkedList\"><span class=\"toc-text\">LinkedList</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ArrayList\"><span class=\"toc-text\">ArrayList</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Queue\"><span class=\"toc-text\">Queue</span></a></li></ol>","author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Redis入门","uid":"9d6afd20d8190b4b550aed150e5e2779","slug":"Redis入门","date":"2023-01-09T02:59:24.000Z","updated":"2023-01-10T05:31:27.002Z","comments":true,"path":"api/articles/Redis入门.json","keywords":null,"cover":[],"text":"NOSQL优点1.解决CPU及内存压力 2.解决IO压力 概述NoSQL(NoSQL &#x3D; Not Only SQL )，意即“不仅仅是SQL”，泛指非关系型的数据库。 NoSQL 不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[],"tags":[],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"面试精选问题","uid":"81ee9368cecd59974c7ff981e1f45f53","slug":"面试精选问题","date":"2022-09-26T08:13:25.000Z","updated":"2022-12-20T01:54:28.227Z","comments":true,"path":"api/articles/面试精选问题.json","keywords":null,"cover":"https://pixabay.com/zh/photos/dog-pet-american-eskimo-palmerian-7651002/","text":"JAVA1.一道关于Integer的面试题1，来，先来一道考题，你看做对了吗？ Integer i1 &#x3D; new Integer(66); Integer i2 &#x3D; new Integer(66); System.out.println(i1 &#x3D;&#...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[],"tags":[],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}