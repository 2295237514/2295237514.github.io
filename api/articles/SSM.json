{"title":"SSM","uid":"5bf9428aa95fdc2b26bf23a606aad789","slug":"SSM","date":"2022-07-26T08:33:15.000Z","updated":"2022-07-31T08:43:21.603Z","comments":true,"path":"api/articles/SSM.json","keywords":null,"cover":[],"content":"<p><a href=\"https://spring.io/\">spring官网</a></p>\n<h1 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h1><ul>\n<li>Spring Framework是Spring生态圈中最基础的项目，是其他项目的根基</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220726165418.png\"></p>\n<h2 id=\"学习路线\"><a href=\"#学习路线\" class=\"headerlink\" title=\"学习路线\"></a>学习路线</h2><p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220726165701.png\"></p>\n<h2 id=\"核心容器的核心概念\"><a href=\"#核心容器的核心概念\" class=\"headerlink\" title=\"核心容器的核心概念\"></a>核心容器的核心概念</h2><ul>\n<li><p>代码书写现状</p>\n<ul>\n<li>代码耦合度高</li>\n</ul>\n</li>\n<li><p>解决方案</p>\n<ul>\n<li>使用对象时，在程序中不要主动使用new产生对象，转换为由<em>外部</em>提供对象</li>\n</ul>\n</li>\n<li><p><strong>IoC(Inversion of Control) 控制反转</strong></p>\n<ul>\n<li>对象的创建控制权由程序转移到<em>外部</em>，这种思想称为控制反转</li>\n<li>目标：解耦</li>\n</ul>\n</li>\n<li><p>Spring技术对IoC思想进行了实现</p>\n<ul>\n<li>Spring提供了一个容器，称为IoC容器，用来充当IoC思想的<em>外部</em></li>\n<li>IoC容器负责对象的创建、初始化等一系列工作，被创建或被管理的对象在IoC容器中统称为Bean</li>\n</ul>\n</li>\n<li><p><strong>DI(Dependency Injection)依赖注入</strong></p>\n<ul>\n<li>在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><strong>本节总结：</strong></p>\n<ul>\n<li><strong>目标：充分解耦</strong><ul>\n<li><strong>在IoC容器中管理bran（IoC）</strong></li>\n<li><strong>在IoC容器内将有依赖关系的bean进行关系绑定（DI）</strong></li>\n</ul>\n</li>\n<li><strong>最终效果</strong><ul>\n<li><strong>使用对象时不仅可以直接从IoC容器中获取，并且获取的bean已经绑定了所有的依赖关系</strong></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"IoC入门案例思路分析\"><a href=\"#IoC入门案例思路分析\" class=\"headerlink\" title=\"IoC入门案例思路分析\"></a>IoC入门案例思路分析</h2><p> 1.管理什么？(Service与Dao)</p>\n<p>2.如何将被管理的对象告知IoC容器？(配置)</p>\n<p>3.被管理的对象叫啊给IoC容器，如何获取到IoC容器？(接口)</p>\n<p>4.IoC容器得到后，如何从容器中获取bean？(接口方法)</p>\n<p>5.使用Spring时怎么导入坐标(pom.xml)</p>\n<p>使用步骤：</p>\n<p>1.导jar包</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;5.2.10.RELEASE&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p>2.定义spring管理的类（接口）</p>\n<p>3.创建Spirng配置文件，配置对应类作为Spring管理的bean</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;\n\n    &lt;bean id&#x3D;&quot;bookDaoBean&quot; class&#x3D;&quot;com.itheima.dao.impl.BookDaoImpl&quot;&#x2F;&gt;\n    &lt;bean id&#x3D;&quot;bookServiceBean&quot; class&#x3D;&quot;com.itheima.service.impl.BookServiceImpl&quot;&#x2F;&gt;\n&lt;&#x2F;beans&gt;</code></pre>\n\n<p>注意事项：bean定义式id属性在同一个上下文中不能重复</p>\n<p>4.初始化IoC容器，通过容器获取bean</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);\n\n需要获取的对象的类型 bookDao &#x3D; (需要获取的对象类型)applicationContext.getBean(&quot;bookDaoBean&quot;);</code></pre>\n\n<p>applicationContext.getBean(“”)获取的是一个Object类型的对象，应对其进行强制类型转换</p>\n<h2 id=\"DI入门案例\"><a href=\"#DI入门案例\" class=\"headerlink\" title=\"DI入门案例\"></a>DI入门案例</h2><p>1.基于IoC管理bean</p>\n<p>2.Service中使用new形式创建的Dao对象是否保留？(否)</p>\n<p>3.Service中需要的Dao对象如何进入到Service中？(提供方法)</p>\n<p>4.Service与Dao间的关系如何描述？(配置)</p>\n<p>使用步骤：</p>\n<p>1.删除使用new的形式创建对象的代码</p>\n<p>private BookDao bookDao <del>&#x3D; new BookDaoImpl()</del>;</p>\n<p>public void save(){<br>    System.out.println(“book service 我他妈莱纳”);<br>    bookDao.save();<br>}</p>\n<p>2.提供依赖对象对应的setter方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class BookServiceImpl implements BookService &#123;\n\n    private BookDao bookDao;\n\n    public void save()&#123;\n        System.out.println(&quot;book service 。。。。。。&quot;);\n        bookDao.save();\n    &#125;\n\n    public void setBookDao(BookDao bookDao) &#123;\n        this.bookDao &#x3D; bookDao;\n    &#125;\n&#125;</code></pre>\n\n<p>3.配置service与dao之间的关系</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;bean id&#x3D;&quot;bookServiceBean&quot; class&#x3D;&quot;com.itheima.service.impl.BookServiceImpl&quot;&gt;\n        &lt;property name&#x3D;&quot;bookDao&quot; ref&#x3D;&quot;bookDaoBean&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n&#x2F;&#x2F; property 标签中 name是 id&#x3D;&quot;bookServiceBean&quot;对象里属性的名称   ref则是bean对象的名称</code></pre>\n\n<h2 id=\"bean基础配置\"><a href=\"#bean基础配置\" class=\"headerlink\" title=\"bean基础配置\"></a>bean基础配置</h2><h3 id=\"别名配置\"><a href=\"#别名配置\" class=\"headerlink\" title=\"别名配置\"></a>别名配置</h3><p>姓名：name</p>\n<p>类型：属性</p>\n<p>所属：bean标签</p>\n<p>范例</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;bean id&#x3D;&quot;bookServiceBean&quot; name&#x3D;&quot;FirstBean,SecondBean&quot; class&#x3D;&quot;com.itheima.service.impl.BookServiceImpl&quot;&gt;\n        &lt;property name&#x3D;&quot;bookDao&quot; ref&#x3D;&quot;bookDaoBean&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;</code></pre>\n\n<p><strong>注意事项</strong></p>\n<p>获取bean无论是通过id还是name获取，如果无法获取到，将抛出异常NoSuchBeanDefinitionException</p>\n<p>NoSuchBeanDefinitionException: No bean named ‘bookServiceImpl’ available</p>\n<h3 id=\"bean作用范围说明\"><a href=\"#bean作用范围说明\" class=\"headerlink\" title=\"bean作用范围说明\"></a>bean作用范围说明</h3><p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220730095635.png\"></p>\n<p>可见，Spring默认给我们创建的bean是一个单例模式，</p>\n<p>我们可以通过在 bean标签中设置属性 scope&#x3D;”prototype”来讲bean设置成非单例</p>\n<ul>\n<li>适合交给容器进行管理的bean<ul>\n<li>表现层对象</li>\n<li>业务层对象</li>\n<li>数据层对象</li>\n<li>工具对象</li>\n</ul>\n</li>\n<li>不适合交给容器进行管理的bean<ul>\n<li>封装实体的域对象</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"单例bean与原型bean的区别\"><a href=\"#单例bean与原型bean的区别\" class=\"headerlink\" title=\"单例bean与原型bean的区别\"></a>单例bean与原型bean的区别</h3><p><em>单例bean：如果一个bean被声明为单例的时候，在处理多次请求的时候在Spring容器里只实例化出一个bean，后续的请求都公用这个对象，这个对象会保存在一个map里面。<br>当有请求来的时候会先从缓存(map)里查看有没有，有的话直接使用这个对象，没有的话才实例化一个新的对象，所以这是个单例的。（ThreadLocal ）创建完后，后面都会复用这个bean</em></p>\n<p><em>原型(prototype)bean来说当每次请求来的时候直接实例化新的bean，没有缓存以及从缓存查的过程。</em></p>\n<p>结论：</p>\n<p><em>单例的bean只有第一次创建新的bean 后面都会复用该bean，所以不会频繁创建对象。</em></p>\n<p><em>原型的bean每次都会新创建</em></p>\n<p>单例bean的优势<br>由于不会每次都新创建新对象所以有一下几个性能上的优势：</p>\n<p><strong>1.减少了新生成实例的消耗</strong><br>新生成实例消耗包括两方面，第一，Spring会通过反射或者cglib来生成bean实例这都是耗性能的操作，其次给对象分配内存也会涉及复杂算法。</p>\n<p><strong>2.减少jvm垃圾回收</strong><br>由于不会给每个请求都新生成bean实例，所以自然回收的对象少了。</p>\n<p><strong>3.可以快速获取到bean</strong><br>因为单例的获取bean操作除了第一次生成之外其余的都是从缓存里获取的所以很快。</p>\n<p><em><strong>单例bean的劣势</strong></em><br>单例的bean一个很大的劣势就是他不能做到线程安全！！！尤其是高并发情况下。</p>\n<p>由于所有请求都共享一个bean实例，所以这个bean要是有状态的一个bean的话可能在并发场景下出现问题，而原型的bean则不会有这样问题（但也有例外，比如他被单例bean依赖），因为给每个请求都新创建实例。</p>\n<h2 id=\"bean实例化的三种方式\"><a href=\"#bean实例化的三种方式\" class=\"headerlink\" title=\"bean实例化的三种方式\"></a>bean实例化的三种方式</h2><h3 id=\"构造方法（常用）\"><a href=\"#构造方法（常用）\" class=\"headerlink\" title=\"构造方法（常用）\"></a>构造方法（常用）</h3><ul>\n<li>bean本质上就是对象，创建bean使用构造方法完成</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class BookDaoImpl implements BookDao &#123;\n\n&#x2F;&#x2F;    private BookDaoImpl()&#123;\n&#x2F;&#x2F;        System.out.println(&quot;book dao struct is running......&quot;);\n&#x2F;&#x2F;    &#125;\n    public void save() &#123;\n        System.out.println(&quot;BookDao 我他吗来啦&quot;);\n    &#125;\n&#125;</code></pre>\n\n\n\n<ul>\n<li>提供可访问的构造方法</li>\n</ul>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;bean id&#x3D;&quot;bookDaoBean&quot; class&#x3D;&quot;com.itheima.dao.impl.BookDaoImpl&quot;&#x2F;&gt;</code></pre>\n\n<h3 id=\"静态工厂（了解）\"><a href=\"#静态工厂（了解）\" class=\"headerlink\" title=\"静态工厂（了解）\"></a>静态工厂（了解）</h3><p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220730114100.png\"></p>\n<h3 id=\"实例工厂\"><a href=\"#实例工厂\" class=\"headerlink\" title=\"实例工厂\"></a>实例工厂</h3><p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220730114017.png\"></p>\n<h3 id=\"FactoryBean（实用）\"><a href=\"#FactoryBean（实用）\" class=\"headerlink\" title=\"FactoryBean（实用）\"></a>FactoryBean（实用）</h3><p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220730130510.png\"></p>\n<h2 id=\"bean生命周期\"><a href=\"#bean生命周期\" class=\"headerlink\" title=\"bean生命周期\"></a>bean生命周期</h2><ul>\n<li>生命周期：从创建到销毁的完整过程</li>\n<li>bean生命周期控制：在bean创建后到销毁前做一些事情</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220730133209.png\"></p>\n<p>接口控制（了解）</p>\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220730133605.png\"></p>\n<h3 id=\"bean生命周期-1\"><a href=\"#bean生命周期-1\" class=\"headerlink\" title=\"bean生命周期\"></a>bean生命周期</h3><ul>\n<li><p>初始化容器</p>\n<p>1.创建对象（内存分配）</p>\n<p>2.执行构造方法</p>\n<p>3.执行属性注入（set操作）</p>\n<p>4.执行bean初始化方法</p>\n</li>\n<li><p>使用bean</p>\n<p>1.执行业务操作</p>\n</li>\n<li><p>关闭&#x2F;销毁容器</p>\n<p>1.执行bean销毁方法</p>\n</li>\n</ul>\n<h3 id=\"bean销毁时机\"><a href=\"#bean销毁时机\" class=\"headerlink\" title=\"bean销毁时机\"></a>bean销毁时机</h3><ul>\n<li><p>容器关闭前触发bean的销毁</p>\n</li>\n<li><p>关闭容器方式：</p>\n<ul>\n<li><p>手工关闭容器</p>\n<p>ConfigurableApplicationContext接口close（）方法</p>\n</li>\n<li><p>注册关闭钩子，在虚拟机退出前先关闭容器再退出虚拟机</p>\n<p>ConfigurableApplicationContext接口registerShutdownHook（）操作</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"依赖注入方式\"><a href=\"#依赖注入方式\" class=\"headerlink\" title=\"依赖注入方式\"></a>依赖注入方式</h2><ul>\n<li><p>思考：向一个类中传递数据的方式有几种？</p>\n<ul>\n<li>普通方法（set方法）</li>\n<li>构造方法</li>\n</ul>\n</li>\n<li><p>思考：依赖注入描述了在容器中简历bean与bean之间依赖关系的过程，如果bean运行需要的是数据或字符串呢？</p>\n</li>\n<li><p>setter注入</p>\n<ul>\n<li><p>简单类型</p>\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220730140922.png\"></p>\n</li>\n<li><p>引用类型</p>\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220730140856.png\"></p>\n</li>\n</ul>\n</li>\n<li><p>构造器注入</p>\n<ul>\n<li><p>简单类型</p>\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220730163208.png\"></p>\n</li>\n<li><p>引用类型</p>\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220730163117.png\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"依赖注入方式选择\"><a href=\"#依赖注入方式选择\" class=\"headerlink\" title=\"依赖注入方式选择\"></a>依赖注入方式选择</h3><p>1.强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现</p>\n<p>2.可选依赖使用setter注入进行，灵活性强</p>\n<p>3.Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨</p>\n<p>4.如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入</p>\n<p>5.实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入</p>\n<p><strong>6.自己开发的模块推荐使用setter注入</strong></p>\n<h3 id=\"自动装配\"><a href=\"#自动装配\" class=\"headerlink\" title=\"自动装配\"></a>自动装配</h3><ul>\n<li><p>IoC容器根据bean所以来的资源在容器中自动查找并注入到bean中的过程称为自动装配</p>\n</li>\n<li><p>自动装配方式</p>\n<ul>\n<li>按类型（常用）</li>\n<li>按名称</li>\n<li>按构造方法</li>\n<li>不启用自动装配</li>\n</ul>\n</li>\n<li><p>配种中使用bean标签autowire</p>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220731085314.png\"></p>\n<ul>\n<li>自动装配用于引用类型依赖注入，不能对简单类型进行操作</li>\n<li>使用按类型装配时(byType)必须保障容器中想同类型的bean唯一，推荐使用</li>\n<li>使用按名称装配时(byName)必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用</li>\n<li>自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效</li>\n</ul>\n<h3 id=\"集合注入\"><a href=\"#集合注入\" class=\"headerlink\" title=\"集合注入\"></a>集合注入</h3><p><em>数组，List，Set，Map,Properties</em></p>\n<p><strong>bean所依赖的实现类</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class BookDaoImpl implements BookDao &#123;\n\n    private int[] array;\n\n    private List&lt;String&gt; list;\n\n    private Set&lt;String&gt; set;\n\n    private Map&lt;String,String&gt; map;\n\n    private Properties properties;\n\n\n\n\n    public void setArray(int[] array) &#123;\n        this.array &#x3D; array;\n    &#125;\n\n    public void setList(List&lt;String&gt; list) &#123;\n        this.list &#x3D; list;\n    &#125;\n\n    public void setSet(Set&lt;String&gt; set) &#123;\n        this.set &#x3D; set;\n    &#125;\n\n    public void setMap(Map&lt;String, String&gt; map) &#123;\n        this.map &#x3D; map;\n    &#125;\n\n    public void setProperties(Properties properties) &#123;\n        this.properties &#x3D; properties;\n    &#125;\n\n\n\n\n    public void save() &#123;\n        System.out.println(&quot;book dao save ...&quot;);\n\n        System.out.println(&quot;遍历数组:&quot; + Arrays.toString(array));\n\n        System.out.println(&quot;遍历List&quot; + list);\n\n        System.out.println(&quot;遍历Set&quot; + set);\n\n        System.out.println(&quot;遍历Map&quot; + map);\n\n        System.out.println(&quot;遍历Properties&quot; + properties);\n    &#125;\n&#125;</code></pre>\n\n<p>applicationContext.xml</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;\n    &lt;bean id&#x3D;&quot;bookDao&quot; class&#x3D;&quot;com.itheima.dao.impl.BookDaoImpl&quot;&gt;\n        &lt;!--数组注入--&gt;\n        &lt;property name&#x3D;&quot;array&quot;&gt;\n            &lt;array&gt;\n                &lt;value&gt;100&lt;&#x2F;value&gt;\n                &lt;value&gt;200&lt;&#x2F;value&gt;\n                &lt;value&gt;300&lt;&#x2F;value&gt;\n            &lt;&#x2F;array&gt;\n        &lt;&#x2F;property&gt;\n        &lt;!--list集合注入--&gt;\n        &lt;property name&#x3D;&quot;list&quot;&gt;\n            &lt;list&gt;\n                &lt;value&gt;itcast&lt;&#x2F;value&gt;\n                &lt;value&gt;itheima&lt;&#x2F;value&gt;\n                &lt;value&gt;boxuegu&lt;&#x2F;value&gt;\n                &lt;value&gt;chuanzhihui&lt;&#x2F;value&gt;\n            &lt;&#x2F;list&gt;\n        &lt;&#x2F;property&gt;\n        &lt;!--set集合注入--&gt;\n        &lt;property name&#x3D;&quot;set&quot;&gt;\n            &lt;set&gt;\n                &lt;value&gt;itcast&lt;&#x2F;value&gt;\n                &lt;value&gt;itheima&lt;&#x2F;value&gt;\n                &lt;value&gt;boxuegu&lt;&#x2F;value&gt;\n                &lt;value&gt;boxuegu&lt;&#x2F;value&gt;\n            &lt;&#x2F;set&gt;\n        &lt;&#x2F;property&gt;\n        &lt;!--map集合注入--&gt;\n        &lt;property name&#x3D;&quot;map&quot;&gt;\n            &lt;map&gt;\n                &lt;entry key&#x3D;&quot;country&quot; value&#x3D;&quot;china&quot;&#x2F;&gt;\n                &lt;entry key&#x3D;&quot;province&quot; value&#x3D;&quot;henan&quot;&#x2F;&gt;\n                &lt;entry key&#x3D;&quot;city&quot; value&#x3D;&quot;kaifeng&quot;&#x2F;&gt;\n            &lt;&#x2F;map&gt;\n        &lt;&#x2F;property&gt;\n        &lt;!--Properties注入--&gt;\n        &lt;property name&#x3D;&quot;properties&quot;&gt;\n            &lt;props&gt;\n                &lt;prop key&#x3D;&quot;country&quot;&gt;china&lt;&#x2F;prop&gt;\n                &lt;prop key&#x3D;&quot;province&quot;&gt;henan&lt;&#x2F;prop&gt;\n                &lt;prop key&#x3D;&quot;city&quot;&gt;kaifeng&lt;&#x2F;prop&gt;\n            &lt;&#x2F;props&gt;\n        &lt;&#x2F;property&gt;\n    &lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;\n</code></pre>\n\n<h2 id=\"第三方资源配置管理\"><a href=\"#第三方资源配置管理\" class=\"headerlink\" title=\"第三方资源配置管理\"></a>第三方资源配置管理</h2><ul>\n<li><p>导入druid坐标</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;1.1.16&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;</code></pre>\n</li>\n<li><p>配置数据源对象作为spring管理的bean</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;bean class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;\n        &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;spring_db&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;</code></pre></li>\n</ul>\n<h2 id=\"加载properties文件\"><a href=\"#加载properties文件\" class=\"headerlink\" title=\"加载properties文件\"></a>加载properties文件</h2><p>由于上次学习将数据库的用户名，密码，全配置在applicationContext.xml之中，非常的危险，故应该使用properties文件记录数据库信息</p>\n<p>1.开启context命名空间</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xsi:schemaLocation&#x3D;&quot;\n            http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n            http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n            http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context\n            http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd\n            &quot;&gt;\n    &lt;!--  将含有beans的代码复制一份并用context替换beans--&gt;</code></pre>\n\n\n\n<p>2.使用context空间加载properties文件</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;context:property-placeholder location&#x3D;&quot;classpath*:*.properties&quot; system-properties-mode&#x3D;&quot;NEVER&quot;&#x2F;&gt;</code></pre>\n\n\n\n<ol start=\"3\">\n<li>使用属性占位符${}读取properties文件中的属性</li>\n</ol>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;bean class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;\n        &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;$&#123;jdbc.Driver&#125;&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;</code></pre>\n\n<p>4.自己配置的 jdbc.properties文件内容</p>\n<pre class=\"line-numbers language-properties\" data-language=\"properties\"><code class=\"language-properties\">jdbc.driver&#x3D;com.mysql.jdbc.Driver\njdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;spring_db\njdbc.username&#x3D;root\njdbc.password&#x3D;root</code></pre>\n\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220731110143.png\"></p>\n<h2 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h2><h3 id=\"创建容器\"><a href=\"#创建容器\" class=\"headerlink\" title=\"创建容器\"></a>创建容器</h3><p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220731114926.png\"></p>\n<h3 id=\"获取bean\"><a href=\"#获取bean\" class=\"headerlink\" title=\"获取bean\"></a>获取bean</h3><p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220731115010.png\"></p>\n<h3 id=\"容器类结构层次\"><a href=\"#容器类结构层次\" class=\"headerlink\" title=\"容器类结构层次\"></a>容器类结构层次</h3><p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220731131448.png\"></p>\n<h3 id=\"BeanFactory\"><a href=\"#BeanFactory\" class=\"headerlink\" title=\"BeanFactory\"></a>BeanFactory</h3><ul>\n<li>类路径加载配置文件</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220731131508.png\"></p>\n<h2 id=\"核心容器总结\"><a href=\"#核心容器总结\" class=\"headerlink\" title=\"核心容器总结\"></a>核心容器总结</h2><ul>\n<li>BeanFactory是IoC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载</li>\n<li>ApplicationContext接口是Spring容器的核心接口，初始化时bean立即加载</li>\n<li>ApplicationContext接口提供基础的bean操作相关方法，通过其他接口扩展其功能</li>\n<li>ApplicationContext接口常用初始化类<ul>\n<li>ClassPathXmlApplicationContext</li>\n<li>FileSystemXmlApplicationContext</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"bean相关\"><a href=\"#bean相关\" class=\"headerlink\" title=\"bean相关\"></a>bean相关</h3><p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220731132707.png\"></p>\n<h3 id=\"依赖注入相关\"><a href=\"#依赖注入相关\" class=\"headerlink\" title=\"依赖注入相关\"></a>依赖注入相关</h3><p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220731132729.png\"></p>\n<h2 id=\"注解开发\"><a href=\"#注解开发\" class=\"headerlink\" title=\"注解开发\"></a>注解开发</h2><h3 id=\"注解开发定义bean\"><a href=\"#注解开发定义bean\" class=\"headerlink\" title=\"注解开发定义bean\"></a>注解开发定义bean</h3><p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220731140547.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220731140608.png\"></p>\n<p><strong>同时这几个注解后面也可以添加一些参数，比如比较常用的一个是注解的括号中加value属性，来表示这个组件在容器中的ID，如果不设置value值时，默认的ID是类名的全称（第一个字母小写）。</strong></p>\n<p><strong>在这里有一点需要注意：事实上Spring并没有能力识别一个组件到底是不是它所标记的类型，</strong>即使将@Respository注解用在一个表述层控制器组件上面也不会产生任何错误，所以@Respository、@Service、@Controller这几个注解仅仅是为了让开发人员自己明确当前的组件扮演的角色。方便将组件加入到容器中去。</p>\n<h3 id=\"纯注解开发\"><a href=\"#纯注解开发\" class=\"headerlink\" title=\"纯注解开发\"></a>纯注解开发</h3><ul>\n<li><p>Spring3.0升级了纯注解开发模式，使用java类替代配置文件，开启了Spring快速开发赛道</p>\n</li>\n<li><p>读取Spring核心配置文件初始化容器对象切换为读取Java配置类初始化容器对象</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;加载配置文件初始化容器\nApplicationContext ctx &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);\n&#x2F;&#x2F;加载配置类初始化容器    \nApplicationContext ctx &#x3D; new AnnotationConfigApplicationContext(SpringConfig.class);</code></pre>\n\n\n\n\n\n\n</li>\n<li><p>Java类替代Spring核心配置文件</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xsi:schemaLocation&#x3D;&quot;\n        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;\n\n    &lt;context:component-scan base-package&#x3D;&quot;com.itheima&quot;&#x2F;&gt;\n\n&lt;&#x2F;beans&gt;\n\n\n&#x2F;&#x2F;配置文件被替换为\n\n\n&#x2F;&#x2F;声明当前类为Spring配置类\n@Configuration\n&#x2F;&#x2F;设置bean扫描路径，多个路径书写为字符串数组格式\n@ComponentScan(&#123;&quot;com.itheima.service&quot;,&quot;com.itheima.dao&quot;&#125;)\npublic class SpringConfig &#123;\n&#125;\n</code></pre>\n\n<ul>\n<li><p>@Configuration注解用于设定当前类为配置类</p>\n</li>\n<li><p>@ComponentScan注解用于设定扫描路径，次注解只能添加一次，多个数据请用数组格式</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@ComponentScan(&#123;&quot;com.itheima.service&quot;,&quot;com.itheima.dao&quot;&#125;)</code></pre></li>\n</ul>\n<h3 id=\"注解开发小结\"><a href=\"#注解开发小结\" class=\"headerlink\" title=\"注解开发小结\"></a>注解开发小结</h3><p>1.定义bean</p>\n<ul>\n<li>@Component<ul>\n<li>@Controller</li>\n<li>@Service</li>\n<li>@Repository</li>\n</ul>\n</li>\n<li>&lt;context:component-scan&#x2F;&gt;</li>\n</ul>\n<p>2.纯注解开发</p>\n<ul>\n<li>@Configuration</li>\n<li>@ComponentScan</li>\n<li>AnnotationConfigApplicationContext</li>\n</ul>\n<h3 id=\"bean作用范围与生命周期管理\"><a href=\"#bean作用范围与生命周期管理\" class=\"headerlink\" title=\"bean作用范围与生命周期管理\"></a>bean作用范围与生命周期管理</h3><ul>\n<li>使用@Scope定义bean作用范围</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Repository\n@Scope(&quot;singleton&quot;)\npublic class BookDaoImpl implements BookDao&#123;\n&#125;</code></pre>\n\n<p>使用@PostConstruct、@PreDestroy定义bean生命周期</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Repository\n@Scope(&quot;singleton&quot;)\npublic class BookDaoImpl implements BookDao&#123;\n\tpublic BookDaoImpl()&#123;\n\t\tSystem.out.println(&quot;book dao constructor ...&quot;);\n\t&#125;\n    @PostConstruct\n    public void init()&#123;\n        System.out.println(&quot;book init ...&quot;);\n    &#125;\n    @PreDestroy\n    public void destroy()&#123;\n        System.out.println(&quot;book destroy ...&quot;)\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a>依赖注入</h3><ul>\n<li>使用@Autowired注解开发自动装配模式(按类型)</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Service\npublic class bookServiceImpl implements BookService&#123;\n\t@Autowired\n\tprivate BookDao bookDao;\n\t\n\tpublic void save()&#123;\n\t\tSystem.out.println(&quot;book service save ...&quot;);\n\t\tbookDao.save();\n\t&#125;\n&#125;</code></pre>\n\n<ul>\n<li>注意：自动装配基于反射设计创建对象并暴力反射对应属性为私有属性初始化数据，隐藏无需提供setter方法</li>\n<li>注意：自动装配建议使用无参构造方法创建对象(默认)，如果不提供对应构造对象，请提供唯一的构造方法</li>\n</ul>\n<hr>\n<ul>\n<li>使用@Qualifier注解开启指定名称装配bean</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Service\npublic class BookServiceImpl implements BookService &#123;\n    &#x2F;&#x2F;@Autowired：注入引用类型，自动装配模式，默认按类型装配\n    @Autowired\n    &#x2F;&#x2F;@Qualifier：自动装配bean时按bean名称装配\n    @Qualifier(&quot;bookDao&quot;)\n    private BookDao bookDao;\n\n    public void save() &#123;\n        System.out.println(&quot;book service save ...&quot;);\n        bookDao.save();\n    &#125;\n&#125;</code></pre>\n\n<ul>\n<li>注意：@Qualifier注解无法单独使用，必须配合@Autowired注解使用</li>\n</ul>\n<hr>\n<ul>\n<li>使用@Value实现简单类型注入</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Repository(&quot;bookDao&quot;)\npublic class BookDaoImpl implements BookDao &#123;\n    &#x2F;&#x2F;@Value：注入简单类型（无需提供set方法）\n    @Value(&quot;Hello World&quot;)\n    private String name;\n\n    public void save() &#123;\n        System.out.println(&quot;book dao save ...&quot; + name);\n    &#125;\n&#125;</code></pre>\n\n<hr>\n<h4 id=\"加载properties文件-1\"><a href=\"#加载properties文件-1\" class=\"headerlink\" title=\"加载properties文件\"></a>加载properties文件</h4><ul>\n<li>使用@PropertySource注解加载properties文件</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\n@ComponentScan(&quot;com.itheima&quot;)\n@PropertySource(&quot;classpath:jdbc.properties&quot;)\npublic class SpringConfig&#123;\n&#125;</code></pre>\n\n<ul>\n<li>注意：路径仅支持单一文件配置，多文件请使用数组格式配置，不允许使用通配符*</li>\n</ul>\n<h3 id=\"第三方bean\"><a href=\"#第三方bean\" class=\"headerlink\" title=\"第三方bean\"></a>第三方bean</h3><h4 id=\"第三方bean管理\"><a href=\"#第三方bean管理\" class=\"headerlink\" title=\"第三方bean管理\"></a>第三方bean管理</h4><ul>\n<li>使用@bean配置第三方bean</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\npublic class SpringConfig &#123;\n\n    @Bean\n    public DataSource dataSource()&#123;\n        DruidDataSource ds &#x3D; new DruidDataSource();\n        ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);\n      \tds.setUrl(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;spring_db&quot;);\n        ds.setUsername(&quot;root&quot;);\n        ds.setPassword(&quot;1234&quot;);\n        return ds;\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220731161957.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220731162026.png\"></p>\n<p><strong>建议使用方式一，因为方式二看不出你用过哪些配置类</strong></p>\n<h4 id=\"第三方bean依赖注入\"><a href=\"#第三方bean依赖注入\" class=\"headerlink\" title=\"第三方bean依赖注入\"></a>第三方bean依赖注入</h4><ul>\n<li>简单类型依赖注入</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class JdbcConfig &#123;\n    &#x2F;&#x2F;1.定义一个方法获得要管理的对象\n    @Value(&quot;com.mysql.jdbc.Driver&quot;)\n    private String driver;\n    @Value(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;spring_db&quot;)\n    private String url;\n    @Value(&quot;root&quot;)\n    private String userName;\n    @Value(&quot;root&quot;)\n    private String password;\n    &#x2F;&#x2F;2.添加@Bean，表示当前方法的返回值是一个bean\n    &#x2F;&#x2F;@Bean修饰的方法，形参根据类型自动装配\n    @Bean\n    public DataSource dataSource(BookDao bookDao)&#123;\n        System.out.println(bookDao);\n        DruidDataSource ds &#x3D; new DruidDataSource();\n        ds.setDriverClassName(driver);\n        ds.setUrl(url);\n        ds.setUsername(userName);\n        ds.setPassword(password);\n        return ds;\n    &#125;\n&#125;</code></pre>\n\n<ul>\n<li>引用类型依赖注入</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Bean\n   public DataSource dataSource(BookDao bookDao)&#123;\n       System.out.println(bookDao);\n       DruidDataSource ds &#x3D; new DruidDataSource();\n       ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);\n       ds.setUrl(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;spring_db&quot;);\n       ds.setUsername(&quot;root&quot;);\n       ds.setPassword(&quot;1234&quot;);\n       return ds;\n   &#125;</code></pre>\n\n<p><strong>引用类型注入只需要为bean定义方法设置形参即可，容器会根据类型自动装配对象</strong></p>\n<h2 id=\"注解开发总结\"><a href=\"#注解开发总结\" class=\"headerlink\" title=\"注解开发总结\"></a>注解开发总结</h2><h3 id=\"XML配置对比注解配置\"><a href=\"#XML配置对比注解配置\" class=\"headerlink\" title=\"XML配置对比注解配置\"></a>XML配置对比注解配置</h3><p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220731163956.png\"></p>\n","feature":true,"text":"spring官网 Spring Spring Framework是Spring生态圈中最基础的项目，是其他项目的根基 学习路线 核心容器的核心概念 代码书写现状 代码耦合度高 解决方案 使用对象时，在程序中不要主动使用new产生对象，转换为由外部提供对象 IoC(Inversio...","link":"","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"17 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Spring\"><span class=\"toc-text\">Spring</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF\"><span class=\"toc-text\">学习路线</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%B8%E5%BF%83%E5%AE%B9%E5%99%A8%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">核心容器的核心概念</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#IoC%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90\"><span class=\"toc-text\">IoC入门案例思路分析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#DI%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B\"><span class=\"toc-text\">DI入门案例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#bean%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">bean基础配置</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%AB%E5%90%8D%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">别名配置</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#bean%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">bean作用范围说明</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E4%BE%8Bbean%E4%B8%8E%E5%8E%9F%E5%9E%8Bbean%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">单例bean与原型bean的区别</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#bean%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">bean实例化的三种方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%88%E5%B8%B8%E7%94%A8%EF%BC%89\"><span class=\"toc-text\">构造方法（常用）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89\"><span class=\"toc-text\">静态工厂（了解）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E4%BE%8B%E5%B7%A5%E5%8E%82\"><span class=\"toc-text\">实例工厂</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#FactoryBean%EF%BC%88%E5%AE%9E%E7%94%A8%EF%BC%89\"><span class=\"toc-text\">FactoryBean（实用）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">bean生命周期</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-1\"><span class=\"toc-text\">bean生命周期</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#bean%E9%94%80%E6%AF%81%E6%97%B6%E6%9C%BA\"><span class=\"toc-text\">bean销毁时机</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">依赖注入方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F%E9%80%89%E6%8B%A9\"><span class=\"toc-text\">依赖注入方式选择</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D\"><span class=\"toc-text\">自动装配</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9B%86%E5%90%88%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">集合注入</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%89%E6%96%B9%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">第三方资源配置管理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8A%A0%E8%BD%BDproperties%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">加载properties文件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">创建容器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%8E%B7%E5%8F%96bean\"><span class=\"toc-text\">获取bean</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%BB%93%E6%9E%84%E5%B1%82%E6%AC%A1\"><span class=\"toc-text\">容器类结构层次</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#BeanFactory\"><span class=\"toc-text\">BeanFactory</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%B8%E5%BF%83%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">核心容器总结</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#bean%E7%9B%B8%E5%85%B3\"><span class=\"toc-text\">bean相关</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3\"><span class=\"toc-text\">依赖注入相关</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91\"><span class=\"toc-text\">注解开发</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%E5%AE%9A%E4%B9%89bean\"><span class=\"toc-text\">注解开发定义bean</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%AF%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91\"><span class=\"toc-text\">纯注解开发</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">注解开发小结</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#bean%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">bean作用范围与生命周期管理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">依赖注入</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8A%A0%E8%BD%BDproperties%E6%96%87%E4%BB%B6-1\"><span class=\"toc-text\">加载properties文件</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%89%E6%96%B9bean\"><span class=\"toc-text\">第三方bean</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%89%E6%96%B9bean%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">第三方bean管理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%89%E6%96%B9bean%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">第三方bean依赖注入</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">注解开发总结</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#XML%E9%85%8D%E7%BD%AE%E5%AF%B9%E6%AF%94%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">XML配置对比注解配置</span></a></li></ol></li></ol></li></ol>","author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"JVM","uid":"0b1381c4a63c09e41167c5168339035a","slug":"JVM","date":"2022-07-28T00:37:05.000Z","updated":"2022-07-28T06:11:20.945Z","comments":true,"path":"api/articles/JVM.json","keywords":null,"cover":[],"text":"定义： Java Virtual Machine - java程序的运行环境 (java二进制字节码的运行环境) 好处： 一次编写，到处运行 自动内存管理，垃圾回收功能 数据下标越界检查 多态 比较： ​ JRE: Java Runtime Enviroment（） 常见的JVM...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[],"tags":[],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"计算机组成原理","uid":"56c491e94a7396878a3a1e31f971413b","slug":"计算机组成原理","date":"2022-07-13T13:29:14.000Z","updated":"2022-07-13T13:50:13.422Z","comments":true,"path":"api/articles/计算机组成原理.json","keywords":null,"cover":null,"text":"第一章1.21.2.1 冯诺依曼计算机的特点： 计算机有哦运算器，存储器，控制器，输入设备和输出设备五大部件组成 指令和数据以同等地位存放于存储器中，并可按地址寻访 指令和数据均用二进制数表示 指令由操作码和地址码组成，操作码用来表示操作的性质，地址码用来表示操作数在存储器中的位...","link":"","photos":[],"count_time":{"symbolsCount":690,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}