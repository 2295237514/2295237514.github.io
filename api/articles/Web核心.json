{"title":"Web核心","uid":"2d34257e8e68ae00ecf08b330efedcd5","slug":"Web核心","date":"2022-07-06T06:27:05.000Z","updated":"2022-07-24T03:58:46.321Z","comments":true,"path":"api/articles/Web核心.json","keywords":null,"cover":[],"content":"<h1 id=\"Web概述\"><a href=\"#Web概述\" class=\"headerlink\" title=\"Web概述\"></a>Web概述</h1><h2 id=\"JavaWeb技术栈\"><a href=\"#JavaWeb技术栈\" class=\"headerlink\" title=\"JavaWeb技术栈\"></a>JavaWeb技术栈</h2><ul>\n<li><p>B&#x2F;S架构：Browser&#x2F;Server，浏览器&#x2F;服务器 架构模式，它的特点是，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web资源，服务器把Web资源发送给浏览器即可</p>\n<ul>\n<li>好处：易于维护升级：服务器升级苟，客户端无需任何不输就可以使用到新的版本</li>\n</ul>\n</li>\n<li><p>静态资源：HTML  CSS  JavaScript  图片等。 负责页面展现</p>\n</li>\n<li><p>动态资源：Servlet  Jsp等。 负责逻辑处理</p>\n</li>\n<li><p>数据库：负责存储数据</p>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220706143521.png\"></p>\n<h1 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h1><ul>\n<li><p>概念：HyperText  Transfer  Protocol， 超文本传输协议，规定了浏览器和服务器之间数据传输的规则</p>\n</li>\n<li><p>HTTP协议特点：</p>\n<p>1.基于TCP协议：面向连接，安全</p>\n<p>2.基于请求-响应模型：一次请求对应一次响应</p>\n<p>3.HTTP协议是无状态的协议：对于事务处理没有记忆能力。每次请求-响应都是独立的</p>\n<ul>\n<li>缺点：多次请求间不能共享数据       <em>Java中使用会话技术（Cookie、Session）来解决</em></li>\n<li>有点：速度快</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"请求数据格式\"><a href=\"#请求数据格式\" class=\"headerlink\" title=\"请求数据格式\"></a>请求数据格式</h2><ul>\n<li>请求数据分为三部分：</li>\n</ul>\n<p>1.请求行：请求数据的第一行。其中GET表示请求方式，&#x2F;表示请求资源路径，HTTP&#x2F;1.1表示协议版本</p>\n<p>2.请求头：第二行开始，格式为key：value形式，常见的HTTP请求头有:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Host: 表示请求的主机名\nUser-Agent: 浏览器版本,例如Chrome浏览器的标识类似Mozilla&#x2F;5.0 ...Chrome&#x2F;79，IE浏览器的标识类似Mozilla&#x2F;5.0 (Windows NT ...)like Gecko；\nAccept：表示浏览器能接收的资源类型，如text&#x2F;*，image&#x2F;*或者*&#x2F;*表示所有；\nAccept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页；\nAccept-Encoding：表示浏览器可以支持的压缩类型，例如gzip, deflate等。</code></pre>\n\n<p>3.请求体：POST请求的最后一部分，存放请求参数</p>\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220706151130.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220706151439.png\"></p>\n<h2 id=\"响应数据格式\"><a href=\"#响应数据格式\" class=\"headerlink\" title=\"响应数据格式\"></a>响应数据格式</h2><ul>\n<li><p>1.响应行：响应数据的第一行。其中HTTP&#x2F;1.1表示协议版本，200表示响应状态码，OK表示状态码描述</p>\n</li>\n<li><p>2.响应头：第二行开始，格式为key：value形式，常见的HTTP响应头有:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Content-Type：表示该响应内容的类型，例如text&#x2F;html，image&#x2F;jpeg；\nContent-Length：表示该响应内容的长度（字节数）；\nContent-Encoding：表示该响应压缩算法，例如gzip；\nCache-Control：指示客户端应如何缓存，例如max-age&#x3D;300表示可以最多缓存300秒</code></pre>\n</li>\n<li><p>3.响应体：最后一部分。存放相应数据</p>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220706152548.png\"></p>\n<h3 id=\"一、状态码大类\"><a href=\"#一、状态码大类\" class=\"headerlink\" title=\"一、状态码大类\"></a>一、状态码大类</h3><table>\n<thead>\n<tr>\n<th>状态码分类</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1xx</td>\n<td><strong>响应中</strong>——临时状态码，表示请求已经接受，告诉客户端应该继续请求或者如果它已经完成则忽略它</td>\n</tr>\n<tr>\n<td>2xx</td>\n<td><strong>成功</strong>——表示请求已经被成功接收，处理已完成</td>\n</tr>\n<tr>\n<td>3xx</td>\n<td><strong>重定向</strong>——重定向到其它地方：它让客户端再发起一个请求以完成整个处理。</td>\n</tr>\n<tr>\n<td>4xx</td>\n<td><strong>客户端错误</strong>——处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等</td>\n</tr>\n<tr>\n<td>5xx</td>\n<td><strong>服务器端错误</strong>——处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等</td>\n</tr>\n</tbody></table>\n<p>状态码大全：<a href=\"https://cloud.tencent.com/developer/chapter/13553\">https://cloud.tencent.com/developer/chapter/13553</a> </p>\n<h3 id=\"二、常见的响应状态码\"><a href=\"#二、常见的响应状态码\" class=\"headerlink\" title=\"二、常见的响应状态码\"></a>二、常见的响应状态码</h3><table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>英文描述</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>200</td>\n<td><strong><code>OK</code></strong></td>\n<td>客户端请求成功，即<strong>处理成功</strong>，这是我们最想看到的状态码</td>\n</tr>\n<tr>\n<td>302</td>\n<td><strong><code>Found</code></strong></td>\n<td>指示所请求的资源已移动到由<code>Location</code>响应头给定的 URL，浏览器会自动重新访问到这个页面</td>\n</tr>\n<tr>\n<td>304</td>\n<td><strong><code>Not Modified</code></strong></td>\n<td>告诉客户端，你请求的资源至上次取得后，服务端并未更改，你直接用你本地缓存吧。隐式重定向</td>\n</tr>\n<tr>\n<td>400</td>\n<td><strong><code>Bad Request</code></strong></td>\n<td>客户端请求有<strong>语法错误</strong>，不能被服务器所理解</td>\n</tr>\n<tr>\n<td>403</td>\n<td><strong><code>Forbidden</code></strong></td>\n<td>服务器收到请求，但是<strong>拒绝提供服务</strong>，比如：没有权限访问相关资源</td>\n</tr>\n<tr>\n<td>404</td>\n<td><strong><code>Not Found</code></strong></td>\n<td><strong>请求资源不存在</strong>，一般是URL输入有误，或者网站资源被删除了</td>\n</tr>\n<tr>\n<td>428</td>\n<td><strong><code>Precondition Required</code></strong></td>\n<td><strong>服务器要求有条件的请求</strong>，告诉客户端要想访问该资源，必须携带特定的请求头</td>\n</tr>\n<tr>\n<td>429</td>\n<td><strong><code>Too Many Requests</code></strong></td>\n<td><strong>太多请求</strong>，可以限制客户端请求某个资源的数量，配合 Retry-After(多长时间后可以请求)响应头一起使用</td>\n</tr>\n<tr>\n<td>431</td>\n<td><strong><code> Request Header Fields Too Large</code></strong></td>\n<td><strong>请求头太大</strong>，服务器不愿意处理请求，因为它的头部字段太大。请求可以在减少请求头域的大小后重新提交。</td>\n</tr>\n<tr>\n<td>405</td>\n<td><strong><code>Method Not Allowed</code></strong></td>\n<td>请求方式有误，比如应该用GET请求方式的资源，用了POST</td>\n</tr>\n<tr>\n<td>500</td>\n<td><strong><code>Internal Server Error</code></strong></td>\n<td><strong>服务器发生不可预期的错误</strong>。服务器出异常了，赶紧看日志去吧</td>\n</tr>\n<tr>\n<td>503</td>\n<td><strong><code>Service Unavailable</code></strong></td>\n<td><strong>服务器尚未准备好处理请求</strong>，服务器刚刚启动，还未初始化好</td>\n</tr>\n<tr>\n<td>511</td>\n<td><strong><code>Network Authentication Required</code></strong></td>\n<td><strong>客户端需要进行身份验证才能获得网络访问权限</strong></td>\n</tr>\n</tbody></table>\n<h1 id=\"Tomcat\"><a href=\"#Tomcat\" class=\"headerlink\" title=\"Tomcat\"></a>Tomcat</h1><p>Web服务器是一个应用程序（软件），对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作，让开发更加便捷，主要功能是提供网上信息浏览服务 </p>\n<p>作用：</p>\n<ul>\n<li>封装HTTP协议操作，简化开发</li>\n<li>可以将web项目部署到服务器中，对外提供网上浏览服务</li>\n</ul>\n<p>Tomcat是一个轻量级的Web服务器，支持Servlet&#x2F;JSP少量JavaEE规范，也称为Web服务器，Servlet容器</p>\n<h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220707170900.png\"></p>\n<h2 id=\"部署项目\"><a href=\"#部署项目\" class=\"headerlink\" title=\"部署项目\"></a>部署项目</h2><p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220707171555.png\"></p>\n<h2 id=\"IDEA中创建Maven-Web项目\"><a href=\"#IDEA中创建Maven-Web项目\" class=\"headerlink\" title=\"IDEA中创建Maven Web项目\"></a>IDEA中创建Maven Web项目</h2><h3 id=\"项目结构：\"><a href=\"#项目结构：\" class=\"headerlink\" title=\"项目结构：\"></a>项目结构：</h3><p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220707172439.png\"></p>\n<h3 id=\"创建方法\"><a href=\"#创建方法\" class=\"headerlink\" title=\"创建方法\"></a>创建方法</h3><h4 id=\"1、\"><a href=\"#1、\" class=\"headerlink\" title=\"1、\"></a>1、</h4><p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220707172656.png\"></p>\n<h4 id=\"2、\"><a href=\"#2、\" class=\"headerlink\" title=\"2、\"></a>2、</h4><p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220707172714.png\"></p>\n<h3 id=\"IDEA集成本地Tomcat\"><a href=\"#IDEA集成本地Tomcat\" class=\"headerlink\" title=\"IDEA集成本地Tomcat\"></a>IDEA集成本地Tomcat</h3><p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220711125029.png\"></p>\n<h3 id=\"IDEA中使用Tomcat-Tomcat-Maven插件\"><a href=\"#IDEA中使用Tomcat-Tomcat-Maven插件\" class=\"headerlink\" title=\"IDEA中使用Tomcat - Tomcat Maven插件\"></a>IDEA中使用Tomcat - Tomcat Maven插件</h3><p>1.pom.xml添加Tomcat插件</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;build&gt;\n    &lt;plugins&gt;\n    \t&lt;!--Tomcat插件 --&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.apache.tomcat.maven&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;tomcat7-maven-plugin&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;2.2&lt;&#x2F;version&gt;\n        &lt;&#x2F;plugin&gt;\n    &lt;&#x2F;plugins&gt;\n&lt;&#x2F;build&gt;</code></pre>\n\n<p>2.使用Maven Helper 插件快速启动项目，选中项目，右键 Run Maven –&gt; tomcat7:run</p>\n<h1 id=\"Servlet\"><a href=\"#Servlet\" class=\"headerlink\" title=\"Servlet\"></a>Servlet</h1><ul>\n<li>Servlet是java提供的一门动态Web资源开发技术</li>\n<li>Servlet是javaEE规范之一，其实就是一个接口，将来我们要定义Servlet类来访问Servlet接口，并由web服务器运行Servlet</li>\n</ul>\n<h2 id=\"Servlet快速入门\"><a href=\"#Servlet快速入门\" class=\"headerlink\" title=\"Servlet快速入门\"></a>Servlet快速入门</h2><p>1.创建一个项目，导入Servlet依赖坐标</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;javax.servlet-api&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;3.1.0&lt;&#x2F;version&gt;\n    &lt;!--\n      此处为什么需要添加该标签?\n      provided指的是在编译和测试过程中有效,最后生成的war包时不会加入\n       因为Tomcat的lib目录中已经有servlet-api这个jar包，如果在生成war包的时候生效就会和Tomcat中的jar包冲突，导致报错\n    --&gt;\n    &lt;scope&gt;provided&lt;&#x2F;scope&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n\n\n<p>2.创建：定义一个类，实现Servlet接口，并重写接口中的所有方法，并在service方法中输入一句话</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.itheima.web;\n\nimport javax.servlet.*;\nimport java.io.IOException;\n\npublic class ServletDemo1 implements Servlet &#123;\n\n    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;\n        System.out.println(&quot;servlet hello world~&quot;);\n    &#125;\n    public void init(ServletConfig servletConfig) throws ServletException &#123;\n\n    &#125;\n\n    public ServletConfig getServletConfig() &#123;\n        return null;\n    &#125;\n\n    public String getServletInfo() &#123;\n        return null;\n    &#125;\n\n    public void destroy() &#123;\n\n    &#125;\n&#125;</code></pre>\n\n\n\n<p>3.配置: 在类上使用@WebServlet注解，配置该Servlet的访问路径</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@WebServlet(&quot;&#x2F;demo1&quot;)</code></pre>\n\n\n\n<p>4.访问:启动Tomcat，浏览器输入URL访问该Servlet</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">http:&#x2F;&#x2F;localhost:8080&#x2F;web-demo&#x2F;demo1</code></pre>\n\n<h2 id=\"Servlet执行流程\"><a href=\"#Servlet执行流程\" class=\"headerlink\" title=\"Servlet执行流程\"></a>Servlet执行流程<img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220711141836.png\"></h2><h2 id=\"Servlet生命周期\"><a href=\"#Servlet生命周期\" class=\"headerlink\" title=\"Servlet生命周期\"></a>Servlet生命周期</h2><ul>\n<li><p>对象的生命周期指一个对象从被创建到被销毁的整个过程</p>\n</li>\n<li><p>Servlet运行在Servlet容器（Web服务器）中，其生命周期由容器来管理，分为4个阶段</p>\n<p>1.加载和实例化：默认情况下，当Servlet第一次被访问时，其容器创建Servlet对象</p>\n</li>\n</ul>\n<p>\t</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">默认情况，Servlet会在第一次访问被容器创建，但是如果创建Servlet比较耗时的话，\n那么第一个访问的人等待的时间就比较长，用户的体验就比较差，\n那么我们能不能把Servlet的创建放到服务器启动的时候来创建，具体如何来配置?\n\n@WebServlet(urlPatterns &#x3D; &quot;&#x2F;demo1&quot;,loadOnStartup &#x3D; 1)\nloadOnstartup的取值有两类情况\n（1）负整数:第一次访问时创建Servlet对象\n（2）0或正整数:服务器启动时创建Servlet对象，数字越小优先级越高</code></pre>\n\n<p>2.初始化：在Servlet实例化之后，容器将调用Servlet的init()方法来初始化这个对象，完成一些如加载配置文件、创建连接等初始化的工作。该方法只调用一次</p>\n<p>3.请求处理：每次请求Servlet时，Servlet容器都会调用Servlet的service()方法对请求进行处理</p>\n<p>4.服务终止：当需要释放内存或容器关闭时，容器就会调用Servlet实例的destory()方法完成资源的释放。在destory()方法调用之后，容器会释放这个Servlet实例，该实例随后会被java的垃圾收集器所回收</p>\n<h2 id=\"Servlet方法介绍\"><a href=\"#Servlet方法介绍\" class=\"headerlink\" title=\"Servlet方法介绍\"></a>Servlet方法介绍</h2><ul>\n<li>初始化方法，在Servlet被创建时执行，只执行一次</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">void init(ServletConfig config) </code></pre>\n\n<ul>\n<li>提供服务方法， 每次Servlet被访问，都会调用该方法</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">void service(ServletRequest req, ServletResponse res)</code></pre>\n\n<ul>\n<li>销毁方法，当Servlet被销毁时，调用该方法。在内存释放或服务器关闭时销毁Servlet</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">void destroy() </code></pre>\n\n<p>剩下的两个方法是:</p>\n<ul>\n<li>获取Servlet信息</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String getServletInfo() \n&#x2F;&#x2F;该方法用来返回Servlet的相关信息，没有什么太大的用处，一般我们返回一个空字符串即可\npublic String getServletInfo() &#123;\n    return &quot;&quot;;\n&#125;</code></pre>\n\n<ul>\n<li>获取ServletConfig对象</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ServletConfig getServletConfig()</code></pre>\n\n<h2 id=\"Servlet体系结构\"><a href=\"#Servlet体系结构\" class=\"headerlink\" title=\"Servlet体系结构\"></a>Servlet体系结构</h2><p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220711164606.png\"></p>\n<p>我们将来开发B&#x2F;S架构的web项目，都是针对HTTP协议，所以我们自定义Servlet，会继承HttpServlet</p>\n<ol>\n<li><p>HttpServlet使用步骤</p>\n<ol>\n<li>继承HttpServlet</li>\n<li>重写doGet和doPost方法</li>\n</ol>\n</li>\n<li><p>HttpServlet原理</p>\n<p>获取请求方式，并根据不同的请求方式，调用不同的doXxx方法。</p>\n</li>\n</ol>\n<h2 id=\"Servlet-urlPattern配置\"><a href=\"#Servlet-urlPattern配置\" class=\"headerlink\" title=\"Servlet urlPattern配置\"></a>Servlet urlPattern配置</h2><p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220711175218.png\"></p>\n<p>优先级：1&gt;2&gt;3&gt;&#x2F;*&gt;&#x2F;</p>\n<h2 id=\"XML配置Servlet\"><a href=\"#XML配置Servlet\" class=\"headerlink\" title=\"XML配置Servlet\"></a>XML配置Servlet</h2><p>前面对应Servlet的配置，我们都使用的是@WebServlet,这个是Servlet从3.0版本后开始支持注解配置，3.0版本前只支持XML配置文件的配置方法。</p>\n<p>对于XML的配置步骤有两步:</p>\n<ul>\n<li><p>编写Servlet类</p>\n</li>\n<li><p>在web.xml中配置该Servlet 代码如下：</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;servlet&gt;\n       &lt;!-- servlet的名称，名字任意--&gt;\n       &lt;servlet-name&gt;demo13&lt;&#x2F;servlet-name&gt;\n       &lt;!--servlet的类全名--&gt;\n       &lt;servlet-class&gt;com.itheima.web.ServletDemo13&lt;&#x2F;servlet-class&gt;\n   &lt;&#x2F;servlet&gt;\n  \n   &lt;!-- \n       Servlet 访问路径\n   --&gt;\n   &lt;servlet-mapping&gt;\n       &lt;!-- servlet的名称，要和上面的名称一致--&gt;\n       &lt;servlet-name&gt;demo13&lt;&#x2F;servlet-name&gt;\n       &lt;!-- servlet的访问路径--&gt;\n       &lt;url-pattern&gt;&#x2F;demo13&lt;&#x2F;url-pattern&gt;\n   &lt;&#x2F;servlet-mapping&gt;</code></pre></li>\n</ul>\n<h1 id=\"Request\"><a href=\"#Request\" class=\"headerlink\" title=\"Request\"></a>Request</h1><h2 id=\"Request继承体系\"><a href=\"#Request继承体系\" class=\"headerlink\" title=\"Request继承体系\"></a>Request继承体系</h2><p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220712103848.png\"></p>\n<h2 id=\"Request获取数据请求参数\"><a href=\"#Request获取数据请求参数\" class=\"headerlink\" title=\"Request获取数据请求参数\"></a>Request获取数据请求参数</h2><p>HTTP请求数据总共分为三部分内容，分别是  请求行、请求头、请求体</p>\n<h3 id=\"Request获取请求行数据\"><a href=\"#Request获取请求行数据\" class=\"headerlink\" title=\"Request获取请求行数据\"></a>Request获取请求行数据</h3><p>请求行包含三块内容，分别是<code>请求方式</code>、<code>请求资源路径</code>、<code>HTTP协议及版本</code></p>\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220712122125.png\"></p>\n<p>对于这三部分内容，request对象都提供了对应的API方法来获取，具体如下:</p>\n<ul>\n<li>获取请求方式<code>GET</code></li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">String getMethod()</code></pre>\n\n<ul>\n<li>获取虚拟目录（项目访问路径）<code>/request-demo</code></li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Sting getContextPath()</code></pre>\n\n<ul>\n<li>获取URL（统一资源定位符）<code>https://localhost:8080/request-demo/req1</code></li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">StringBuffer getRequestURL()</code></pre>\n\n<ul>\n<li>获取URI(统一资源标识符)<code>request-demo/req1</code></li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">String getRequestURI()</code></pre>\n\n<ul>\n<li>获取请求参数(GET方式)<code>username=zhangsan&amp;password=123</code></li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Sting getQueryString()</code></pre>\n\n<p>例：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * request 获取请求数据\n *&#x2F;\n@WebServlet(&quot;&#x2F;req1&quot;)\npublic class RequestDemo1 extends HttpServlet &#123;\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        &#x2F;&#x2F; String getMethod()：获取请求方式： GET\n        String method &#x3D; req.getMethod();\n        System.out.println(method);&#x2F;&#x2F;GET\n        &#x2F;&#x2F; String getContextPath()：获取虚拟目录(项目访问路径)：&#x2F;request-demo\n        String contextPath &#x3D; req.getContextPath();\n        System.out.println(contextPath);\n        &#x2F;&#x2F; StringBuffer getRequestURL(): 获取URL(统一资源定位符)：http:&#x2F;&#x2F;localhost:8080&#x2F;request-demo&#x2F;req1\n        StringBuffer url &#x3D; req.getRequestURL();\n        System.out.println(url.toString());\n        &#x2F;&#x2F; String getRequestURI()：获取URI(统一资源标识符)： &#x2F;request-demo&#x2F;req1\n        String uri &#x3D; req.getRequestURI();\n        System.out.println(uri);\n        &#x2F;&#x2F; String getQueryString()：获取请求参数（GET方式）： username&#x3D;zhangsan\n        String queryString &#x3D; req.getQueryString();\n        System.out.println(queryString);\n    &#125;\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"获取请求头数据\"><a href=\"#获取请求头数据\" class=\"headerlink\" title=\"获取请求头数据\"></a>获取请求头数据</h3><p>对于请求头的数据，格式为<code>key: value</code>如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220712123628.png\"></p>\n<p>所以根据请求头名称获取对应值的方法为:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">String getHeader(String name)</code></pre>\n\n<h3 id=\"获取请求体数据\"><a href=\"#获取请求体数据\" class=\"headerlink\" title=\"获取请求体数据\"></a>获取请求体数据</h3><p>浏览器在发送GET请求的时候是没有请求体的，所以需要把请求方式变更为POST，请求体中的数据格式如下:</p>\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220712125253.png\"></p>\n<ul>\n<li>获取字节输入流，如果前端发送的是字节数据，比如传递的是文件数据，则使用该方法</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">ServletInputStream getInputStream()\n该方法可以获取字节</code></pre>\n\n<ul>\n<li>获取字符输入流，如果前端发送的是纯文本数据，则使用该方法</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">BufferedReader getReader()</code></pre>\n\n\n\n<p>具体实现的步骤如下:</p>\n<p>1.准备一个页面，在页面中添加form表单,用来发送post请求</p>\n<p>2.在Servlet的doPost方法中获取请求体数据</p>\n<p>3.在doPost方法中使用request的getReader()或者getInputStream()来获取</p>\n<p>4.访问测试</p>\n<h3 id=\"获取请求参数的通用方式\"><a href=\"#获取请求参数的通用方式\" class=\"headerlink\" title=\"获取请求参数的通用方式\"></a>获取请求参数的通用方式</h3><p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220712135714.png\"></p>\n<ul>\n<li>获取所有参数Map集合</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Map&lt;String,String[]&gt; getParameterMap()</code></pre>\n\n<ul>\n<li>根据名称获取参数值（数组）</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">String[] getParameterValues(String name)</code></pre>\n\n<ul>\n<li>根据名称获取参数值(单个值)</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">String getParameter(String name)</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class RequestDemo1 extends HttpServlet &#123;\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n       &#x2F;&#x2F;采用request提供的获取请求参数的通用方式来获取请求参数\n       &#x2F;&#x2F;编写其他的业务代码...\n    &#125;\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        this.doGet(req,resp);\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"请求参数中文乱码处理\"><a href=\"#请求参数中文乱码处理\" class=\"headerlink\" title=\"请求参数中文乱码处理\"></a>请求参数中文乱码处理</h3><ul>\n<li><p>请求参数如果存在中文数据，则会乱码</p>\n</li>\n<li><p>解决方案：</p>\n<ul>\n<li><p>POST:设置输入流的编码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">req.setCharacterEncoding(&quot;UTF-8&quot;);</code></pre>\n</li>\n<li><p>通用方式（GET&#x2F;POST）：先编码，再解码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">new String(username.getBytes(&quot;ISO-8859-\t1&quot;),&quot;UTF-8&quot;);</code></pre></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Request请求转发\"><a href=\"#Request请求转发\" class=\"headerlink\" title=\"Request请求转发\"></a>Request请求转发</h2><ul>\n<li>请求转发：一种在服务器的内部资源跳转方式</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220712152115.png\"></p>\n<ul>\n<li><p>实现方式：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">req.getRequestDispatcher(&quot;资源B路径&quot;).forward(req,resp);</code></pre>\n</li>\n<li><p>请求转发资源间共享数据:使用Request对象</p>\n<ul>\n<li>void setAttribute(String name, Object o)：存储数据到request域中</li>\n<li>Object getAttribute(String name)：根据key，获取值</li>\n<li>void removAttribute(String name)：根据key，删除该键值对</li>\n</ul>\n</li>\n<li><p>请求转发特点：</p>\n<ul>\n<li>浏览器地址栏领不发生变化</li>\n<li>只能转发到当前服务器的内部资源</li>\n<li>一次请求，可以在转发的资源间使用requset共享数据</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Response\"><a href=\"#Response\" class=\"headerlink\" title=\"Response\"></a>Response</h1><h2 id=\"Response设置响应数据功能介绍\"><a href=\"#Response设置响应数据功能介绍\" class=\"headerlink\" title=\"Response设置响应数据功能介绍\"></a>Response设置响应数据功能介绍</h2><ul>\n<li><p>响应数据分为3部分：</p>\n<ul>\n<li><p>响应行：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">HTTP&#x2F;1.1 200 OK</code></pre>\n\n<p>void setStatus(int sc): 设置响应状态码</p>\n</li>\n<li><p>响应头：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Content-Type:text&#x2F;html</code></pre>\n\n<p>void setHeader(String name, String value):设置响应头键值对</p>\n</li>\n<li><p>响应体：</p>\n<pre class=\"line-numbers language-html\" data-language=\"html\"><code class=\"language-html\">&lt;html&gt;\n\t&lt;head&gt;\n\t\n\t&lt;head&gt;\n\t\n\t&lt;body&gt;\n\t\n\t&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;</code></pre>\n\n<p>printWriter getWriter(): 获取字符输出流</p>\n<p>ServletOutputStream getOutputStream():获取字节输出流</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Response完成重定向\"><a href=\"#Response完成重定向\" class=\"headerlink\" title=\"Response完成重定向\"></a>Response完成重定向</h2><ul>\n<li>重定向：一种资源跳转方式</li>\n</ul>\n<p>​\t<img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220712172339.png\"></p>\n<h2 id=\"资源路径问题\"><a href=\"#资源路径问题\" class=\"headerlink\" title=\"资源路径问题\"></a>资源路径问题</h2><p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220712173717.png\"></p>\n<p><em>建议动态获取虚拟目录：String contextPath &#x3D; request.getContextPath();</em></p>\n<p><em>重定向：response.sendRedirect(contextPath + “&#x2F;resp2”);</em></p>\n<h2 id=\"Response响应字符数据\"><a href=\"#Response响应字符数据\" class=\"headerlink\" title=\"Response响应字符数据\"></a>Response响应字符数据</h2><ul>\n<li><p>使用：</p>\n<p>1.通过Response对象获取字符输入流</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">PrintWriter writer &#x3D; response.getWriter();</code></pre>\n\n<p>2.写数据</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">writer.write(&quot;aaa&quot;);</code></pre>\n</li>\n<li><p>注意：</p>\n<ul>\n<li><p>该流不需要关闭，随着响应结束，Response对象销毁，由服务器关闭</p>\n</li>\n<li><p>中文数据乱码：原因通过获取的字符输出流默认编码：ISO-8859-1</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">resp.setContentType(&quot;text&#x2F;html;charset&#x3D;utf-8&quot;);</code></pre></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Response响应字节数据\"><a href=\"#Response响应字节数据\" class=\"headerlink\" title=\"Response响应字节数据\"></a>Response响应字节数据</h2><ul>\n<li><p>使用：</p>\n<p>1.通过Response对象获取字符输入流</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">ServletOutputStream outputStream &#x3D; resp.getOutputStream();</code></pre>\n\n<p>2.写数据</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">outputStream.write(字节数据);</code></pre>\n</li>\n<li><p>IOUtils工具类使用</p>\n<p>1.导入坐标</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;dependency&gt;\n\t&lt;groupid&gt;commons-io&lt;&#x2F;groupid&gt;\n    &lt;artifactld&gt;commons-io&lt;&#x2F;artifactld&gt;\n    &lt;version&gt;2.6&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p>2.使用</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">IOUtils.copy(输入流，输出流);</code></pre></li>\n</ul>\n<h2 id=\"SqlSessionFactory代码优化\"><a href=\"#SqlSessionFactory代码优化\" class=\"headerlink\" title=\"SqlSessionFactory代码优化\"></a>SqlSessionFactory代码优化</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">String resource &#x3D; &quot;org&#x2F;mybatis&#x2F;example&#x2F;mybatis-config.xml&quot;;\nInputStream inputStream &#x3D; Resources.getResourceAsStream(resource);\nSqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);</code></pre>\n\n<p>问题： </p>\n<p>​\t1.代码重复：       解决<em>（工具类)</em></p>\n<p>​\t2.SqlSessionFactory工厂只创建一次，不要重复创建：  解决<em>（静态代码块）</em></p>\n<p>我创建的工具类：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.itheima.util;\n\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\npublic class SqlSessionFactoryUtils &#123;\n    private static  SqlSessionFactory sqlSessionFactory;\n\n    static &#123;\n        &#x2F;&#x2F;静态代码块会随着类的加载自动执行，且只执行一次\n        try &#123;\n            String resource &#x3D; &quot;mybatis-config.xml&quot;;\n            InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);\n            SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);\n        &#125; catch (IOException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n    public static SqlSessionFactory getSqlSessionFactory()&#123;\n        return sqlSessionFactory;\n    &#125;\n&#125;</code></pre>\n\n<h1 id=\"JSP\"><a href=\"#JSP\" class=\"headerlink\" title=\"JSP\"></a>JSP</h1><ul>\n<li>Java Server Pages ，Java服务端页面</li>\n<li>一种动态的网页技术，其中既可以定义HTML,JS,CSS等静态内容，还可以定义Java代码的动态内容</li>\n<li>JSP &#x3D; HTML + Java</li>\n<li>作用：简化开发，避免了在Servlet中直接输出HTML标签</li>\n</ul>\n<h2 id=\"快速入门\"><a href=\"#快速入门\" class=\"headerlink\" title=\"快速入门\"></a>快速入门</h2><p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220713154017.png\"></p>\n<h2 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h2><p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220713162526.png\"></p>\n<h2 id=\"EL表达式\"><a href=\"#EL表达式\" class=\"headerlink\" title=\"EL表达式\"></a>EL表达式</h2><ul>\n<li><p>用于简化JSP页面内的Java代码</p>\n</li>\n<li><p>主要功能：获取数据</p>\n</li>\n<li><p>语法：${expression}</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$&#123;brands&#125;</code></pre>\n\n<p>获取域中存储key为brands的数据</p>\n</li>\n<li><p>JavaWeb中的四大域对象：</p>\n<ul>\n<li>page:当前页面有效</li>\n<li>request:当前请求有效</li>\n<li>session:当前会话有效</li>\n<li>application:当前应用有效</li>\n</ul>\n</li>\n</ul>\n<p>*el表达式获取数据，会依次从这4个域中寻找，直到找到为止</p>\n<h2 id=\"JSTL标签\"><a href=\"#JSTL标签\" class=\"headerlink\" title=\"JSTL标签\"></a>JSTL标签</h2><ul>\n<li>JSP标签库（Jsp Standarded Tag Library），使用标签取代JSP页面上的Java代码</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220714094650.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220714095238.png\"></p>\n<h2 id=\"MVC模式和三层架构\"><a href=\"#MVC模式和三层架构\" class=\"headerlink\" title=\"MVC模式和三层架构\"></a>MVC模式和三层架构</h2><h3 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h3><ul>\n<li><p>MVC是一种分层开发模式，其中：</p>\n<ul>\n<li>M:Model，业务模型，处理业务</li>\n<li>V:View，视图，页面展示</li>\n<li>C：Controller，控制器，处理请求，调用模型和视图</li>\n</ul>\n</li>\n<li><p>MVC好处</p>\n<ul>\n<li>职责单一，互不影响</li>\n<li>有利于分工协作</li>\n<li>有利于组件重用</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"三层架构\"><a href=\"#三层架构\" class=\"headerlink\" title=\"三层架构\"></a>三层架构</h3><p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220714100144.png\"></p>\n<h2 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h2><p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220714101417.png\"></p>\n<h1 id=\"会话跟踪技术\"><a href=\"#会话跟踪技术\" class=\"headerlink\" title=\"会话跟踪技术\"></a>会话跟踪技术</h1><ul>\n<li>会话：用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应</li>\n<li>会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自同一浏览器，以便在同义词绘画的多次请求间共享数据</li>\n<li>HTTP协议是无状态的，每次浏览器向服务器请求时，服务器都会将该请求视为新的请求，因此我们需要会话跟踪技术来实现会话内数据共享</li>\n<li>实现方式：<ul>\n<li>客户端会话跟踪技术：Cookie</li>\n<li>服务端会话跟踪技术：Session</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h2><p><em>Cookie:客户端会话技术，将数据保存到客户端，以后每次请求都携带Cookie数据进行访问</em></p>\n<h3 id=\"Cookie基本使用\"><a href=\"#Cookie基本使用\" class=\"headerlink\" title=\"Cookie基本使用\"></a>Cookie基本使用</h3><h4 id=\"发送Cookie\"><a href=\"#发送Cookie\" class=\"headerlink\" title=\"发送Cookie\"></a>发送Cookie</h4><p>1.创建Cookie对象，设置数据</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Cookie cookie &#x3D; new Cookie(&quot;key&quot;,&quot;value&quot;);</code></pre>\n\n<p>2.发送Cookie到客户端：使用response对象</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">response.addCookie(cookie);</code></pre>\n\n<h4 id=\"获取Cookie\"><a href=\"#获取Cookie\" class=\"headerlink\" title=\"获取Cookie\"></a>获取Cookie</h4><p>3.获取客户端携带的所有Cookie，使用request对象</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Cookie[] cookies &#x3D; request.getCookies();</code></pre>\n\n<p>4.遍历数组，获取每一个Cookie对象：for</p>\n<p>5.使用Cookie对象方法获取数据</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">cookie.getName();</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">cookie.getValue();</code></pre>\n\n<h3 id=\"Cookie原理\"><a href=\"#Cookie原理\" class=\"headerlink\" title=\"Cookie原理\"></a>Cookie原理</h3><p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220714132848.png\"></p>\n<h3 id=\"Cookie使用细节\"><a href=\"#Cookie使用细节\" class=\"headerlink\" title=\"Cookie使用细节\"></a>Cookie使用细节</h3><ul>\n<li>Cookie存活时间：</li>\n</ul>\n<p>​\t-默认情况下，Cookie存储爱浏览器内存中，当浏览器关闭，内存释放，则Cookie被销毁</p>\n<p>​\tsetMaxAge（int seconds）：设置Cookie存活时间</p>\n<p>​\t\t1.正数：将Cookie写入浏览器所爱电脑的硬盘，持久化存储，到时见自动删除</p>\n<p>​\t\t2.负数：默认值，Cookie在当前浏览器内存中，当浏览器关闭，则Cookie被销毁</p>\n<p>​\t\t2.零：删除对应Cookie</p>\n<ul>\n<li><p>Cookie存储中文</p>\n<p>Cookie不能直接存储中文</p>\n<p>如需要存储，则需要进行转码：URL编码，使用时再解码</p>\n</li>\n</ul>\n<h2 id=\"Session\"><a href=\"#Session\" class=\"headerlink\" title=\"Session\"></a>Session</h2><p><em>Session：服务端会话跟踪技术，将数据保存到服务端</em></p>\n<p><em>JavaEE提供HttpSession接口，来实现一次会话的多次请求间数据共享功能</em></p>\n<h3 id=\"Session基本使用\"><a href=\"#Session基本使用\" class=\"headerlink\" title=\"Session基本使用\"></a>Session基本使用</h3><p>1.获取Session对象：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">HttpSession session &#x3D; request.getSession();</code></pre>\n\n<p>2.Session对象功能：</p>\n<p>(1) void setAttribute(String name, Object o): 存储数据到session域中</p>\n<p>(2)Object getAttribute(String name):根据key，获取值</p>\n<p>(3)void removeAttribute(String name):根据key，删除该键值对</p>\n<h3 id=\"Session原理\"><a href=\"#Session原理\" class=\"headerlink\" title=\"Session原理\"></a>Session原理</h3><ul>\n<li><p>Session是基于Cookie实现的</p>\n</li>\n<li><p>在一次会话的多次请求之间获取的session对象是同一个</p>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220714151529.png\"></p>\n<h3 id=\"Session使用细节\"><a href=\"#Session使用细节\" class=\"headerlink\" title=\"Session使用细节\"></a>Session使用细节</h3><ul>\n<li><p>Session钝化，活化：</p>\n<ul>\n<li>钝化：在服务器正常关闭后，Tomcat会自动将Session数据写入硬盘的文件</li>\n<li>活化：再次启动服务器后，从文件中加载到Session中</li>\n</ul>\n</li>\n<li><p>Session销毁： </p>\n<ul>\n<li><p>默认情况下，无操作，30分钟自动销毁</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;session-config&gt;\n\t&lt;session-timeout&gt;30&lt;&#x2F;session-timeout&gt;\n&lt;session-config&gt;\t</code></pre>\n</li>\n<li><p>调用Session对象的invalidate()方法</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><ul>\n<li>Cookie和Session都是来完成一次会话内多次请求建数据共享的</li>\n<li>区别：<ul>\n<li>存储位置：Cookie是将数据存储在客户端，Session将数据存储在服务端</li>\n<li>安全性：Cookie不安全，Session安全</li>\n<li>数据大小：Cookie最大3KB，Session无大小限制</li>\n<li>存储时间：Cookie可以长期存储，Session默认30分钟</li>\n<li>服务器性能：Cookie不占服务器资源，Session占用服务器资源</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Filter\"><a href=\"#Filter\" class=\"headerlink\" title=\"Filter\"></a>Filter</h1><ul>\n<li>概念：Filter表示过滤器，是Javaweb三大组件（Servlet，Filter，Listener）之一</li>\n<li>过滤器可以把对资源的请求拦截下来，从未实现一些特殊的功能</li>\n<li>过滤器一般完成一些通用的操作，比如：权限控制，统一编码处理，敏感字符处理等等……</li>\n</ul>\n<h2 id=\"快速入门-1\"><a href=\"#快速入门-1\" class=\"headerlink\" title=\"快速入门\"></a>快速入门</h2><p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220719123942.png\"></p>\n<h2 id=\"执行流程\"><a href=\"#执行流程\" class=\"headerlink\" title=\"执行流程\"></a>执行流程</h2><p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220719125716.png\"></p>\n<h2 id=\"使用细节\"><a href=\"#使用细节\" class=\"headerlink\" title=\"使用细节\"></a>使用细节</h2><h3 id=\"拦截路径配置\"><a href=\"#拦截路径配置\" class=\"headerlink\" title=\"拦截路径配置\"></a>拦截路径配置</h3><ul>\n<li><p>Filter可以根据需求，配置不同的拦截资源路径</p>\n<p>@WebFilter(“&#x2F;*”)</p>\n<p>public class FilterDemo</p>\n<ul>\n<li>拦截具体的资源：&#x2F;index.jsp: 只有访问index.jsp时才会被拦截</li>\n<li>目录拦截：&#x2F;user&#x2F;*:访问&#x2F;user下的所有资源，都会被拦截</li>\n<li>后缀名拦截：*.jsp：访问后缀名为jsp的资源，都会被拦截</li>\n<li>拦截所有：&#x2F;*：访问所有的资源，都会被拦截</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"过滤器链\"><a href=\"#过滤器链\" class=\"headerlink\" title=\"过滤器链\"></a>过滤器链</h3><ul>\n<li>一个Web应用，可以配置多个过滤器，这多个过滤器称为过滤器链</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220719135729.png\"></p>\n<ul>\n<li>注解配置的Filter，优先级按照过滤器类名（字符串）的自然排序</li>\n</ul>\n<h1 id=\"Listener\"><a href=\"#Listener\" class=\"headerlink\" title=\"Listener\"></a>Listener</h1><ul>\n<li><p>概念：Listener是监听器，是JavaWeb三大组件(Servlet,Filter,Listener)之一</p>\n</li>\n<li><p>监听器可以监听就是在application，session，request三个对象创建，销毁或者往其中添加修改删除属性时自动执行代码的功能组件</p>\n</li>\n<li><p>Listener分类：JavaWeb提供了8个监听器</p>\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220719143535.png\"></p>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220719143954.png\"></p>\n<h1 id=\"AJAX\"><a href=\"#AJAX\" class=\"headerlink\" title=\"AJAX\"></a>AJAX</h1><ul>\n<li><p>概念：异步的Javascript和XML</p>\n</li>\n<li><p>AJAX作用：</p>\n<p>1.与服务器进行数据交换：通过AJAX可以给服务器发送请求，并获取服务器响应的数据</p>\n<ul>\n<li>使用了AJAX和服务器进行通信，就可以使用HTML+AJAX来替换JSP页面了</li>\n</ul>\n<p>2.异步交互：可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术，如：搜索联想，用户名是否可用校验，等等……</p>\n<h2 id=\"异步和同步\"><a href=\"#异步和同步\" class=\"headerlink\" title=\"异步和同步\"></a>异步和同步</h2><p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220724084331.png\"></p>\n</li>\n</ul>\n<h2 id=\"AJAX快速入门\"><a href=\"#AJAX快速入门\" class=\"headerlink\" title=\"AJAX快速入门\"></a>AJAX快速入门</h2><p>1.编写AjaxServlet，并使用response输出字符串</p>\n<ol start=\"2\">\n<li></li>\n</ol>\n","feature":true,"text":"Web概述JavaWeb技术栈 B&#x2F;S架构：Browser&#x2F;Server，浏览器&#x2F;服务器 架构模式，它的特点是，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web资源，服务器把Web资源发送给浏览器即可 好处...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"14 mins."},"categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","count":1,"path":"api/tags/JavaWeb.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Web%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">Web概述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JavaWeb%E6%8A%80%E6%9C%AF%E6%A0%88\"><span class=\"toc-text\">JavaWeb技术栈</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#HTTP\"><span class=\"toc-text\">HTTP</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">请求数据格式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">响应数据格式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E7%8A%B6%E6%80%81%E7%A0%81%E5%A4%A7%E7%B1%BB\"><span class=\"toc-text\">一、状态码大类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81\"><span class=\"toc-text\">二、常见的响应状态码</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Tomcat\"><span class=\"toc-text\">Tomcat</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">基本使用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE\"><span class=\"toc-text\">部署项目</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#IDEA%E4%B8%AD%E5%88%9B%E5%BB%BAMaven-Web%E9%A1%B9%E7%9B%AE\"><span class=\"toc-text\">IDEA中创建Maven Web项目</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%EF%BC%9A\"><span class=\"toc-text\">项目结构：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">创建方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E3%80%81\"><span class=\"toc-text\">1、</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%E3%80%81\"><span class=\"toc-text\">2、</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#IDEA%E9%9B%86%E6%88%90%E6%9C%AC%E5%9C%B0Tomcat\"><span class=\"toc-text\">IDEA集成本地Tomcat</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Tomcat-Tomcat-Maven%E6%8F%92%E4%BB%B6\"><span class=\"toc-text\">IDEA中使用Tomcat - Tomcat Maven插件</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Servlet\"><span class=\"toc-text\">Servlet</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Servlet%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8\"><span class=\"toc-text\">Servlet快速入门</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Servlet%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">Servlet执行流程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Servlet%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">Servlet生命周期</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Servlet%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">Servlet方法介绍</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Servlet%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">Servlet体系结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Servlet-urlPattern%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">Servlet urlPattern配置</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#XML%E9%85%8D%E7%BD%AEServlet\"><span class=\"toc-text\">XML配置Servlet</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Request\"><span class=\"toc-text\">Request</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Request%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB\"><span class=\"toc-text\">Request继承体系</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Request%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">Request获取数据请求参数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Request%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E8%A1%8C%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">Request获取请求行数据</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%A4%B4%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">获取请求头数据</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E4%BD%93%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">获取请求体数据</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E9%80%9A%E7%94%A8%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">获取请求参数的通用方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E5%A4%84%E7%90%86\"><span class=\"toc-text\">请求参数中文乱码处理</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Request%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91\"><span class=\"toc-text\">Request请求转发</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Response\"><span class=\"toc-text\">Response</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Response%E8%AE%BE%E7%BD%AE%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">Response设置响应数据功能介绍</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Response%E5%AE%8C%E6%88%90%E9%87%8D%E5%AE%9A%E5%90%91\"><span class=\"toc-text\">Response完成重定向</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">资源路径问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Response%E5%93%8D%E5%BA%94%E5%AD%97%E7%AC%A6%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">Response响应字符数据</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Response%E5%93%8D%E5%BA%94%E5%AD%97%E8%8A%82%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">Response响应字节数据</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#SqlSessionFactory%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">SqlSessionFactory代码优化</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#JSP\"><span class=\"toc-text\">JSP</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8\"><span class=\"toc-text\">快速入门</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">缺点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#EL%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><span class=\"toc-text\">EL表达式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JSTL%E6%A0%87%E7%AD%BE\"><span class=\"toc-text\">JSTL标签</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#MVC%E6%A8%A1%E5%BC%8F%E5%92%8C%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">MVC模式和三层架构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#MVC\"><span class=\"toc-text\">MVC</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">三层架构</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A1%88%E4%BE%8B\"><span class=\"toc-text\">案例</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">会话跟踪技术</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Cookie\"><span class=\"toc-text\">Cookie</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Cookie%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">Cookie基本使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%91%E9%80%81Cookie\"><span class=\"toc-text\">发送Cookie</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%8E%B7%E5%8F%96Cookie\"><span class=\"toc-text\">获取Cookie</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Cookie%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">Cookie原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Cookie%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82\"><span class=\"toc-text\">Cookie使用细节</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Session\"><span class=\"toc-text\">Session</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Session%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">Session基本使用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Session%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">Session原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Session%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82\"><span class=\"toc-text\">Session使用细节</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">小结</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Filter\"><span class=\"toc-text\">Filter</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-1\"><span class=\"toc-text\">快速入门</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">执行流程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82\"><span class=\"toc-text\">使用细节</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8B%A6%E6%88%AA%E8%B7%AF%E5%BE%84%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">拦截路径配置</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE\"><span class=\"toc-text\">过滤器链</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Listener\"><span class=\"toc-text\">Listener</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#AJAX\"><span class=\"toc-text\">AJAX</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%82%E6%AD%A5%E5%92%8C%E5%90%8C%E6%AD%A5\"><span class=\"toc-text\">异步和同步</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#AJAX%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8\"><span class=\"toc-text\">AJAX快速入门</span></a></li></ol></li></ol>","author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"计算机组成原理","uid":"56c491e94a7396878a3a1e31f971413b","slug":"计算机组成原理","date":"2022-07-13T13:29:14.000Z","updated":"2022-07-13T13:50:13.422Z","comments":true,"path":"api/articles/计算机组成原理.json","keywords":null,"cover":null,"text":"第一章1.21.2.1 冯诺依曼计算机的特点： 计算机有哦运算器，存储器，控制器，输入设备和输出设备五大部件组成 指令和数据以同等地位存放于存储器中，并可按地址寻访 指令和数据均用二进制数表示 指令由操作码和地址码组成，操作码用来表示操作的性质，地址码用来表示操作数在存储器中的位...","link":"","photos":[],"count_time":{"symbolsCount":690,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"java的值传递和引用传递","uid":"cf5277bd1519d645b084515a79fe0c20","slug":"java的值传递和引用传递","date":"2022-07-05T08:53:49.000Z","updated":"2022-07-05T09:04:19.413Z","comments":true,"path":"api/articles/java的值传递和引用传递.json","keywords":null,"cover":[],"text":"一、基本类型和引用类型的理解Java中的数据类型分为两种为基本类型和引用类型。 1、基本类型的变量保存原始值，所以变量就是数据本身。 常见的基本类型：byte,short,int,long,char,float,double,Boolean,returnAddress。 2、引用...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"java基础知识","slug":"java基础知识","count":1,"path":"api/tags/java基础知识.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}