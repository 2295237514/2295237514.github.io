{"title":"Leetcode高频题总结","uid":"711e99b247f8f70b0f4cf84df30732b2","slug":"Leetcode高频题总结","date":"2022-07-05T03:05:06.000Z","updated":"2022-11-21T03:16:48.125Z","comments":true,"path":"api/articles/Leetcode高频题总结.json","keywords":null,"cover":null,"content":"<h1 id=\"剑指Offer\"><a href=\"#剑指Offer\" class=\"headerlink\" title=\"剑指Offer\"></a>剑指Offer</h1><h2 id=\"06-从尾到头打印链表\"><a href=\"#06-从尾到头打印链表\" class=\"headerlink\" title=\"06 从尾到头打印链表\"></a>06 <a href=\"https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/?envType=study-plan&id=lcof&plan=lcof&plan_progress=4qkzzs2\">从尾到头打印链表</a></h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    int i;\n    int j;\n    int[] res;\n    public int[] reversePrint(ListNode head) &#123;\n        solve(head);\n        return res;\n    &#125;\n\n    public void solve(ListNode head)&#123;\n        if(head &#x3D;&#x3D; null)&#123;\n            res &#x3D; new int[i];\n            return;\n        &#125;\n        i ++;\n        solve(head.next);\n        res[j] &#x3D; head.val;\n        j ++;\n    &#125;\n&#125;</code></pre>\n\n\n\n<h2 id=\"15-二进制中1的个数\"><a href=\"#15-二进制中1的个数\" class=\"headerlink\" title=\"15 二进制中1的个数\"></a>15 <a href=\"https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/?favorite=xb9nqhhg\">二进制中1的个数</a></h2><ol>\n<li><p>位移法 时间复杂度O(N) N为二进制数的位数</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Solution &#123;\n    &#x2F;&#x2F; you need to treat n as an unsigned value\n    public int hammingWeight(int n) &#123;\n        int res &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; 32; i ++)&#123;\n            if((n &amp; (1 &lt;&lt; i)) !&#x3D; 0)&#123;\n                res ++;\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;</code></pre>\n</li>\n<li><p>“与”操作法 【最优解法】时间复杂度O(K) K为二进制数中1的个数</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Solution &#123;\n    &#x2F;&#x2F; you need to treat n as an unsigned value\n    public int hammingWeight(int n) &#123;\n        int res &#x3D; 0;\n        while(n !&#x3D; 0)&#123;\n            res ++;\n            n &#x3D; n &amp; (n - 1);\n            &#x2F;&#x2F;n &amp; (n-1)会将二进制代码中最后一位的1变成0\n        &#125;\n        return res;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n<h2 id=\"18-删除链表的节点\"><a href=\"#18-删除链表的节点\" class=\"headerlink\" title=\"18 删除链表的节点\"></a>18 <a href=\"https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/\">删除链表的节点</a></h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public ListNode deleteNode(ListNode head, int val) &#123;\n        while(head !&#x3D; null)&#123;\n            if(head.val !&#x3D; val)&#123;\n                break;\n            &#125;\n            head &#x3D; head.next;\n        &#125; &#x2F;&#x2F;找到第一个非空的头结点，用于返回和执行下步操作\n        ListNode pre &#x3D; head;\n        ListNode cur &#x3D; head;\n        while(cur !&#x3D; null)&#123;\n            if(cur.val &#x3D;&#x3D; val)&#123;\n                pre.next &#x3D; cur.next;\n            &#125;else&#123;\n                pre &#x3D; cur;\n            &#125;\n            cur &#x3D; cur.next;\n        &#125;\n        return head;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"24-反转链表\"><a href=\"#24-反转链表\" class=\"headerlink\" title=\"24 反转链表\"></a>24 <a href=\"https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/\">反转链表</a></h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public ListNode reverseList(ListNode head) &#123;\n        ListNode pre &#x3D; null;\n        ListNode next &#x3D; head;\n        while(next!&#x3D;null)&#123;\n            next &#x3D; head.next;\n            head.next &#x3D; pre;\n            pre &#x3D; head;\n            head &#x3D; next;\n        &#125;\n        return pre;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"35-复杂链表的复制\"><a href=\"#35-复杂链表的复制\" class=\"headerlink\" title=\"35 复杂链表的复制\"></a>35 <a href=\"https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/solutions/\">复杂链表的复制</a></h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    Map&lt;Node, Node&gt; res &#x3D; new HashMap&lt;&gt;();\n    public Node copyRandomList(Node head) &#123;\n        if(head &#x3D;&#x3D; null) return null;\n        if(!res.containsKey(head))&#123;\n            Node clone &#x3D; new Node(head.val);\n            res.put(head, clone);\n            clone.next &#x3D; copyRandomList(head.next);\n            clone.random &#x3D; copyRandomList(head.random);\n        &#125;\n        return res.get(head);\n    &#125;\n&#125;</code></pre>\n\n\n\n<h2 id=\"65-不用加减乘除做加法\"><a href=\"#65-不用加减乘除做加法\" class=\"headerlink\" title=\"65 不用加减乘除做加法\"></a>65 <a href=\"https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/\">不用加减乘除做加法</a></h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;*\n思路：\n      首先看十进制是如何做的： 5+7&#x3D;12，三步走 第一步：相加各位的值，不算进位，得到2。\n      第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。\n      第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。 同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111 \n      第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。 \n      第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。 \n      第三步重复上述两步， 各位相加 010^1010&#x3D;1000，进位值为100&#x3D;(010&amp;1010)&lt;&lt;1。 继续重复上述两步：1000^100 &#x3D; 1100，进位值为0，跳出循环，1100为最终结果。\n*&#x2F;\npublic class Solution &#123;\n    public int Add(int num1,int num2) &#123;\n        while (num2!&#x3D;0) &#123;\n            int temp &#x3D; num1^num2;\n            num2 &#x3D; (num1&amp;num2)&lt;&lt;1;\n            num1 &#x3D; temp;\n        &#125;\n        return num1;\n    &#125;\n&#125;</code></pre>\n\n","text":"剑指Offer06 从尾到头打印链表class Solution &#123; int i; int j; int[] res; public int[] reversePrint(ListNode head) &#123; solve(head); return res; &#...","link":"","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"算法与数据结构","slug":"算法与数据结构","count":2,"path":"api/tags/算法与数据结构.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87Offer\"><span class=\"toc-text\">剑指Offer</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">06 从尾到头打印链表</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#15-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0\"><span class=\"toc-text\">15 二进制中1的个数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">18 删除链表的节点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">24 反转链表</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#35-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6\"><span class=\"toc-text\">35 复杂链表的复制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#65-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95\"><span class=\"toc-text\">65 不用加减乘除做加法</span></a></li></ol></li></ol>","author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"java的值传递和引用传递","uid":"cf5277bd1519d645b084515a79fe0c20","slug":"java的值传递和引用传递","date":"2022-07-05T08:53:49.000Z","updated":"2022-07-05T09:04:19.413Z","comments":true,"path":"api/articles/java的值传递和引用传递.json","keywords":null,"cover":[],"text":"一、基本类型和引用类型的理解Java中的数据类型分为两种为基本类型和引用类型。 1、基本类型的变量保存原始值，所以变量就是数据本身。 常见的基本类型：byte,short,int,long,char,float,double,Boolean,returnAddress。 2、引用...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"java基础知识","slug":"java基础知识","count":1,"path":"api/tags/java基础知识.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"数据结构与算法学习","uid":"6688690e355db1dd869bd788558b9211","slug":"数据结构与算法学习","date":"2022-07-02T01:51:23.000Z","updated":"2022-10-16T06:31:24.966Z","comments":true,"path":"api/articles/数据结构与算法学习.json","keywords":null,"cover":[],"text":"由于之前并未完整成体系的学习算法，在力扣刷100道题后 感觉到算法知识不成体系，决定看左程云的体系学习班学习算法 学习路线 搞定1,2,3差不多达到面试水平 杂记子问题规模一样的递归可以用Master公式求时间复杂度 T(N) &#x3D; a * T(N&#x2F;b) + O...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[],"tags":[{"name":"算法与数据结构","slug":"算法与数据结构","count":2,"path":"api/tags/算法与数据结构.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}