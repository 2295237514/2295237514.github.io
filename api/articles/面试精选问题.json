{"title":"面试精选问题","uid":"81ee9368cecd59974c7ff981e1f45f53","slug":"面试精选问题","date":"2022-09-26T08:13:25.000Z","updated":"2022-12-20T01:54:28.227Z","comments":true,"path":"api/articles/面试精选问题.json","keywords":null,"cover":"https://pixabay.com/zh/photos/dog-pet-american-eskimo-palmerian-7651002/","content":"<h2 id=\"JAVA\"><a href=\"#JAVA\" class=\"headerlink\" title=\"JAVA\"></a>JAVA</h2><h2 id=\"1-一道关于Integer的面试题\"><a href=\"#1-一道关于Integer的面试题\" class=\"headerlink\" title=\"1.一道关于Integer的面试题\"></a>1.一道关于Integer的面试题</h2><p>1，来，先来一道考题，你看做对了吗？</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Integer i1 &#x3D; new Integer(66);\nInteger i2 &#x3D; new Integer(66);\nSystem.out.println(i1 &#x3D;&#x3D; i2);\nInteger i3 &#x3D; 66;\nInteger i4 &#x3D; 66;\nint i5 &#x3D; 66;\nSystem.out.println(i3 &#x3D;&#x3D; i4);\nSystem.out.println(i3 &#x3D;&#x3D; i5);\n\nInteger i6 &#x3D; 128;\nInteger i7 &#x3D; 128;\nint i8 &#x3D; 128;\nSystem.out.println(i6 &#x3D;&#x3D; i7);\nSystem.out.println(i6 &#x3D;&#x3D; i8);</code></pre>\n<p>大家可以猜测下结果，然后将程序运行起来，验证自己的答案是否正确</p>\n<p>这道题主要考查大家对Integer实现原理的掌握程度</p>\n<p>下面，我给大家对这里的关键原理做解读，相信理解之后，你心中自然有答案了</p>\n<p>答案揭晓</p>\n<p>分情况来比较</p>\n<ul>\n<li>都定义为Integer的比较：</li>\n</ul>\n<p>new：一旦new，就是开辟一块新内存，结果肯定是false<br>不new：<br>看范围<br>Integer做了缓存，-128至127，当你取值在这个范围的时候，会采用缓存的对象，所以会相等<br>当不在这个范围，内部创建新的对象，此时不相等</p>\n<ul>\n<li>Integer和int的比较：</li>\n</ul>\n<p>实际比较的是数值，Integer会做拆箱的动作，来跟基本数据类型做比较<br>此时跟是否在缓存范围内或是否new都没关系</p>\n<hr>\n<p>源码分析：</p>\n<p>当我们写Integer i &#x3D; 126,实际上做了自动装箱：Integer i &#x3D; Integer.valueOf(126);<br>分析这段源码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static Integer valueOf(int i) &#123;\n    if (i &gt;&#x3D; IntegerCache.low &amp;&amp; i &lt;&#x3D; IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n&#125;\n&#x2F;&#x2F;IntegerCache是Integer的内部类\nprivate static class IntegerCache &#123;\n    static final int low &#x3D; -128;\n    static final int high;\n    static final Integer cache[];\n    static &#123;\n        &#x2F;&#x2F; high value may be configured by property\n        int h &#x3D; 127;\n    &#x2F;&#x2F;...\n&#125;</code></pre>\n\n<h2 id=\"2-StringBuffer，StringBuilder开发中如何做选择？\"><a href=\"#2-StringBuffer，StringBuilder开发中如何做选择？\" class=\"headerlink\" title=\"2.StringBuffer，StringBuilder开发中如何做选择？\"></a>2.StringBuffer，StringBuilder开发中如何做选择？</h2><ul>\n<li>String是final类型，每次声明的都是不可变的对象，</li>\n<li>所以每次操作都会产生新的String对象，然后将指针指向新的String对象。</li>\n<li>StringBuffer，StringBuilder都是在原有对象上进行操作</li>\n</ul>\n<p>所以，如果需要经常改变字符串内容，则建议采用StringBuffer 和 StringBuilder</p>\n<p><strong>StringBuffer是线程安全的，StringBuilder是线程不安全的。</strong><br>线程不安全的StringBuilder性能更高，所以在开发中，优先采用StringBuilder.<br><em>StringBuilder &gt; StringBuffer &gt; String</em><br>注意：</p>\n<p>我们在开发中为什么会选择StringBuilder？</p>\n<p>这个要看场景，有同学说可以为了性能放弃安全，这是不对的。</p>\n<p>大家想想，什么情况下需要考虑线程安全的问题？</p>\n<ul>\n<li><em>有一个前提条件就是：多线程访问同一个资源，且有更新操作</em></li>\n</ul>\n<p>所以，只要不是这样的场景，我们就可以放心使用StringBuilder</p>\n<p><em>而我们在开发中，通常使用StringBuilder在方法内来创建对象和拼接信息，而这种情况是一个线程对应一个StringBuilder对象</em></p>\n","feature":true,"text":"JAVA1.一道关于Integer的面试题1，来，先来一道考题，你看做对了吗？ Integer i1 &#x3D; new Integer(66); Integer i2 &#x3D; new Integer(66); System.out.println(i1 &#x3D;&#...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JAVA\"><span class=\"toc-text\">JAVA</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E4%B8%80%E9%81%93%E5%85%B3%E4%BA%8EInteger%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98\"><span class=\"toc-text\">1.一道关于Integer的面试题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-StringBuffer%EF%BC%8CStringBuilder%E5%BC%80%E5%8F%91%E4%B8%AD%E5%A6%82%E4%BD%95%E5%81%9A%E9%80%89%E6%8B%A9%EF%BC%9F\"><span class=\"toc-text\">2.StringBuffer，StringBuilder开发中如何做选择？</span></a></li></ol>","author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Java集合框架","uid":"de47803b5d69541ea546c3889eeeba14","slug":"Java集合框架","date":"2022-11-20T08:41:47.000Z","updated":"2022-11-24T04:04:31.750Z","comments":true,"path":"api/articles/Java集合框架.json","keywords":null,"cover":[],"text":"集合概述 概念：对象的容器，定义了对多个对象进项操作的的常用方法。可实现数组的功能。 和数组的区别： 数组长度固定，集合长度不固定。 数组可以存储基本类型和引用类型，集合只能存储引用类型。 位置： java.util.*; Collection Collection父接口 特点：...","link":"","photos":[],"count_time":{"symbolsCount":520,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"JVM","uid":"0b1381c4a63c09e41167c5168339035a","slug":"JVM","date":"2022-07-28T00:37:05.000Z","updated":"2022-07-28T06:11:20.945Z","comments":true,"path":"api/articles/JVM.json","keywords":null,"cover":[],"text":"定义： Java Virtual Machine - java程序的运行环境 (java二进制字节码的运行环境) 好处： 一次编写，到处运行 自动内存管理，垃圾回收功能 数据下标越界检查 多态 比较： ​ JRE: Java Runtime Enviroment（） 常见的JVM...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[],"tags":[],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}