{"title":"java的值传递和引用传递","uid":"cf5277bd1519d645b084515a79fe0c20","slug":"java的值传递和引用传递","date":"2022-07-05T08:53:49.000Z","updated":"2022-07-05T09:04:19.413Z","comments":true,"path":"api/articles/java的值传递和引用传递.json","keywords":null,"cover":[],"content":"<h2 id=\"一、基本类型和引用类型的理解\"><a href=\"#一、基本类型和引用类型的理解\" class=\"headerlink\" title=\"一、基本类型和引用类型的理解\"></a>一、基本类型和引用类型的理解</h2><p><strong>Java中的数据类型分为两种为基本类型和引用类型。</strong></p>\n<p>1、基本类型的变量保存原始值，所以变量就是数据本身。</p>\n<p>  常见的基本类型：byte,short,int,long,char,float,double,<a href=\"https://so.csdn.net/so/search?q=Boolean&spm=1001.2101.3001.7020\">Boolean</a>,returnAddress。</p>\n<p>2、引用类型的变量保存引用值，所谓的引用值就是对象所在内存空间的“首地址值”，通过对这个引用值来操作对象。</p>\n<p>  常见的引用类型：类类型，接口类型和<a href=\"https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020\">数组</a>。</p>\n<h2 id=\"二、值传递和引用传递的理解\"><a href=\"#二、值传递和引用传递的理解\" class=\"headerlink\" title=\"二、值传递和引用传递的理解\"></a>二、<a href=\"https://so.csdn.net/so/search?q=%E5%80%BC%E4%BC%A0%E9%80%92&spm=1001.2101.3001.7020\">值传递</a>和引用传递的理解</h2><h3 id=\"1、值传递\"><a href=\"#1、值传递\" class=\"headerlink\" title=\"1、值传递\"></a>1、值传递</h3><p>  在方法的调用过程中，实参把它的实际值传递给形参，此传递过程就是将实参的值复制一份传递到函数中，这样如果在函数中对该值（形参的值）进行了操作将不会影响实参的值。因为是直接复制，所以这种方式在传递大量数据时，运行效率会特别低下。</p>\n<h3 id=\"2、引用传递\"><a href=\"#2、引用传递\" class=\"headerlink\" title=\"2、引用传递\"></a>2、<a href=\"https://so.csdn.net/so/search?q=%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92&spm=1001.2101.3001.7020\">引用传递</a></h3><p>  引用传递弥补了值传递的不足，如果传递的数据量很大，直接复过去的话，会占用大量的内存空间，而引用传递就是将对象的地址值传递过去，函数接收的是原始值的首地址值。在方法的执行过程中，形参和实参的内容相同，指向同一块内存地址，也就是说操作的其实都是源数据，所以方法的执行将会影响到实际对象。</p>\n<p>举例说明：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">public class Example &#123;\n    String str &#x3D; new String(&quot;hello&quot;);\n    char[] ch &#x3D; &#123;&#39;a&#39;, &#39;b&#39;&#125;;\n    public static void main(String[] args) &#123;\n        Example ex &#x3D; new Example();\n        ex.change(ex.str, ex.ch);\n        System.out.println(ex.str + &quot; and&quot;);\n        System.out.println(ex.ch);\n    &#125;\n\n    public void change(String str, char[] ch) &#123;\n        str &#x3D; &quot;ok&quot;;\n        ch[0] &#x3D; &#39;c&#39;;\n    &#125;\n&#125;\n\n输出是：\nhello and\ncb</code></pre>\n\n<p>过程分析：</p>\n<p>1、为对象分配空间</p>\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220705165644.png\"></p>\n<p>2、执行change()方法</p>\n<p>执行前实参（黑色）和形参（红色）的指向如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220705165845.png\"></p>\n<p>因为String是不可变类且为值传递，而ch[]是引用传递，所以方法中的str &#x3D; “ok”,相当于重新创建一个对象并没有改变实参str的值，数组是引用传递，直接改变，所以执行完方法后，指向关系如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220705165923.png\"></p>\n<h3 id=\"3-结论\"><a href=\"#3-结论\" class=\"headerlink\" title=\"3.结论\"></a>3.结论</h3><p>通过上面的分析我们可以得出以下结论：</p>\n<p>基本数据类型传值，对形参的修改不会影响实参；<br>引用类型传引用，形参和实参指向同一个内存地址（同一个对象），所以对参数的修改会影响到实际的对象。<br>String, Integer, Double等immutable的类型特殊处理，可以理解为传值，最后的操作不会修改实参对象。</p>\n<h2 id=\"哈希表中的特殊情况\"><a href=\"#哈希表中的特殊情况\" class=\"headerlink\" title=\"哈希表中的特殊情况\"></a>哈希表中的特殊情况</h2><p><strong>只要是哈希表中的原生类型，如Integer，String，尽管他们平时是引用传递，但在哈希表中是按值传递！！！</strong></p>\n<p>非原生类型，按值传递，如自己定义的类型。</p>\n","text":"一、基本类型和引用类型的理解Java中的数据类型分为两种为基本类型和引用类型。 1、基本类型的变量保存原始值，所以变量就是数据本身。 常见的基本类型：byte,short,int,long,char,float,double,Boolean,returnAddress。 2、引用...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"java基础知识","slug":"java基础知识","count":1,"path":"api/tags/java基础知识.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">一、基本类型和引用类型的理解</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">二、值传递和引用传递的理解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%80%BC%E4%BC%A0%E9%80%92\"><span class=\"toc-text\">1、值传递</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2%E3%80%81%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92\"><span class=\"toc-text\">2、引用传递</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E7%BB%93%E8%AE%BA\"><span class=\"toc-text\">3.结论</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5\"><span class=\"toc-text\">哈希表中的特殊情况</span></a></li></ol>","author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Web核心","uid":"2d34257e8e68ae00ecf08b330efedcd5","slug":"Web核心","date":"2022-07-06T06:27:05.000Z","updated":"2022-07-25T02:35:28.121Z","comments":true,"path":"api/articles/Web核心.json","keywords":null,"cover":[],"text":"Web概述JavaWeb技术栈 B&#x2F;S架构：Browser&#x2F;Server，浏览器&#x2F;服务器 架构模式，它的特点是，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web资源，服务器把Web资源发送给浏览器即可 好处...","link":"","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","count":1,"path":"api/tags/JavaWeb.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Leetcode高频题总结","uid":"711e99b247f8f70b0f4cf84df30732b2","slug":"Leetcode高频题总结","date":"2022-07-05T03:05:06.000Z","updated":"2022-11-21T03:16:48.125Z","comments":true,"path":"api/articles/Leetcode高频题总结.json","keywords":null,"cover":null,"text":"剑指Offer06 从尾到头打印链表class Solution &#123; int i; int j; int[] res; public int[] reversePrint(ListNode head) &#123; solve(head); return res; &#...","link":"","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"算法与数据结构","slug":"算法与数据结构","count":2,"path":"api/tags/算法与数据结构.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}