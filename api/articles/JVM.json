{"title":"JVM","uid":"0b1381c4a63c09e41167c5168339035a","slug":"JVM","date":"2022-07-28T00:37:05.000Z","updated":"2022-07-28T06:11:20.945Z","comments":true,"path":"api/articles/JVM.json","keywords":null,"cover":[],"content":"<p>定义： Java Virtual Machine - java程序的运行环境 (java二进制字节码的运行环境)</p>\n<p>好处：</p>\n<ul>\n<li>一次编写，到处运行</li>\n<li>自动内存管理，垃圾回收功能</li>\n<li>数据下标越界检查</li>\n<li>多态</li>\n</ul>\n<p>比较：</p>\n<p>​\tJRE: Java Runtime Enviroment（）</p>\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220728084611.png\"></p>\n<p>常见的JVM:</p>\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220728085107.png\"></p>\n<p>学习路线：</p>\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220728085230.png\"></p>\n<h1 id=\"内存结构\"><a href=\"#内存结构\" class=\"headerlink\" title=\"内存结构\"></a>内存结构</h1><h2 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h2><ul>\n<li>Program Counter Register 程序计数器（寄存器）</li>\n</ul>\n<h3 id=\"作用：\"><a href=\"#作用：\" class=\"headerlink\" title=\"作用：\"></a>作用：</h3><p>​\t用于保存下一条JVM指令的执行地址地址</p>\n<h3 id=\"特点：\"><a href=\"#特点：\" class=\"headerlink\" title=\"特点：\"></a>特点：</h3><p>​\t1.是线程私有的:</p>\n<ul>\n<li><p>CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码</p>\n</li>\n<li><p>程序计数器是<strong>每个线程</strong>所<strong>私有</strong>的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令</p>\n</li>\n</ul>\n<p>​\t2.不会存在内存溢出</p>\n<h2 id=\"虚拟机栈\"><a href=\"#虚拟机栈\" class=\"headerlink\" title=\"虚拟机栈\"></a>虚拟机栈</h2><h3 id=\"定义：\"><a href=\"#定义：\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><ul>\n<li>每个线程运行时所需要的内存，称为虚拟机栈</li>\n<li>每个栈由多个栈帧组成，对应着每次方法调用时所占用的内存</li>\n<li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li>\n</ul>\n<p> 问题辨析：</p>\n<p>1.垃圾回收是否涉及栈内存？</p>\n<ul>\n<li>不涉及，因为虚拟机栈是有一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。</li>\n</ul>\n<p>2.栈内存的分配越大越好吗？</p>\n<ul>\n<li>不是，因为<em>物理内存是一定的</em>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越来越少</li>\n</ul>\n<p>3.方法内的局部变量是否是线程安全的？</p>\n<ul>\n<li>如果方法内<em>局部变量没有逃离方法的作用范围</em>，则是<em>线程安全</em>的</li>\n<li>如果局部变量引用了对象，并逃离了方法的作用范围，则需要考虑线程安全问题</li>\n</ul>\n<h3 id=\"栈内存溢出\"><a href=\"#栈内存溢出\" class=\"headerlink\" title=\"栈内存溢出\"></a>栈内存溢出</h3><p><strong>Java.lang.stackOverflowError</strong> 栈内存溢出</p>\n<ul>\n<li>栈帧过多导致栈内存溢出（无限递归）</li>\n<li>栈帧过大导致内存溢出</li>\n</ul>\n<h3 id=\"线程运行诊断\"><a href=\"#线程运行诊断\" class=\"headerlink\" title=\"线程运行诊断\"></a>线程运行诊断</h3><p>CPU占用过高</p>\n<ul>\n<li>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这是需要定位占用CPU过高的线程<ul>\n<li>ps H -en pid, tid, %cpu | grep 刚才通过top查到的进程号 通过ps命令进一步查看是哪个线程占用CPU过高</li>\n<li><em>jstack 进程id</em> 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来对比定位，注意jstack查找出的线程id是16禁止的，需要转换</li>\n</ul>\n</li>\n</ul>\n<p>迟迟得不到结果</p>\n<ul>\n<li>可能发生了死锁</li>\n</ul>\n<h2 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h2><p>一些带有<strong>native关键字</strong>的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法</p>\n<h2 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>通过new关键字，创建的对象都会使用堆内存</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>他是线程共享的，堆中对象都需要考虑线程安全的问题</li>\n<li>有垃圾回收机制</li>\n</ul>\n<h3 id=\"堆内存溢出\"><a href=\"#堆内存溢出\" class=\"headerlink\" title=\"堆内存溢出\"></a>堆内存溢出</h3><p><strong>java.lang.OutofMemoryError</strong> ：java heap space</p>\n<h3 id=\"堆内存诊断\"><a href=\"#堆内存诊断\" class=\"headerlink\" title=\"堆内存诊断\"></a>堆内存诊断</h3><p>1.jps工具</p>\n<ul>\n<li>查看当前系统中有哪些java进程</li>\n</ul>\n<p>2.jmap工具</p>\n<ul>\n<li>查看堆内存占用情况</li>\n</ul>\n<p>3.jconsole工具</p>\n<ul>\n<li>图形界面的，多功能的监测工具，可以连续监测</li>\n</ul>\n<p>4.jvirsalvm</p>\n<h2 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h2><h3 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>方法区（Method Area）与Java堆一样，是各个线程共享的<a href=\"https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020\">内存</a>区域。</p>\n<p><img src=\"https://raw.githubusercontent.com/2295237514/image/main/20220728132737.png\"></p>\n<h3 id=\"方法区内存溢出\"><a href=\"#方法区内存溢出\" class=\"headerlink\" title=\"方法区内存溢出\"></a>方法区内存溢出</h3><ul>\n<li>1.8以前会导致永久代内存溢出</li>\n<li>1.8之后会导致元空间内存溢出</li>\n</ul>\n<h3 id=\"通过反编译来查看类的信息\"><a href=\"#通过反编译来查看类的信息\" class=\"headerlink\" title=\"通过反编译来查看类的信息\"></a><strong>通过反编译来查看类的信息</strong></h3><ul>\n<li><p>获得对应类的.class文件</p>\n<ul>\n<li><p>在JDK对应的bin目录下运行cmd，<strong>也可以在IDEA控制台输入</strong></p>\n</li>\n<li><p>输入 <strong>javac 对应类的绝对路径</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">F:\\JAVA\\JDK8.0\\bin&gt;javac F:\\Thread_study\\src\\com\\nyima\\JVM\\day01\\Main.javaCopy</code></pre>\n\n<p>输入完成后，对应的目录下就会出现类的.class文件</p>\n</li>\n</ul>\n</li>\n<li><p>在控制台输入 javap -v 类的绝对路径</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">javap -v F:\\Thread_study\\src\\com\\nyima\\JVM\\day01\\Main.classCopy</code></pre>\n</li>\n<li><p>然后能在控制台看到反编译以后类的信息了</p>\n</li>\n</ul>\n<h3 id=\"运行时常量池\"><a href=\"#运行时常量池\" class=\"headerlink\" title=\"运行时常量池\"></a>运行时常量池</h3><ul>\n<li>常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息</li>\n<li>运行时常量池，常量池是*.class文件中的，当该类被加载，他的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</li>\n</ul>\n","feature":true,"text":"定义： Java Virtual Machine - java程序的运行环境 (java二进制字节码的运行环境) 好处： 一次编写，到处运行 自动内存管理，垃圾回收功能 数据下标越界检查 多态 比较： ​ JRE: Java Runtime Enviroment（） 常见的JVM...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">内存结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8\"><span class=\"toc-text\">程序计数器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8%EF%BC%9A\"><span class=\"toc-text\">作用：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%89%B9%E7%82%B9%EF%BC%9A\"><span class=\"toc-text\">特点：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88\"><span class=\"toc-text\">虚拟机栈</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89%EF%BC%9A\"><span class=\"toc-text\">定义：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%88%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA\"><span class=\"toc-text\">栈内存溢出</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%AF%8A%E6%96%AD\"><span class=\"toc-text\">线程运行诊断</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88\"><span class=\"toc-text\">本地方法栈</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A0%86\"><span class=\"toc-text\">堆</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">特点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A0%86%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA\"><span class=\"toc-text\">堆内存溢出</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A0%86%E5%86%85%E5%AD%98%E8%AF%8A%E6%96%AD\"><span class=\"toc-text\">堆内存诊断</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E5%8C%BA\"><span class=\"toc-text\">方法区</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89-1\"><span class=\"toc-text\">定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E5%8C%BA%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA\"><span class=\"toc-text\">方法区内存溢出</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%BF%87%E5%8F%8D%E7%BC%96%E8%AF%91%E6%9D%A5%E6%9F%A5%E7%9C%8B%E7%B1%BB%E7%9A%84%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">通过反编译来查看类的信息</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0\"><span class=\"toc-text\">运行时常量池</span></a></li></ol></li></ol></li></ol>","author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"SSM","uid":"5bf9428aa95fdc2b26bf23a606aad789","slug":"SSM","date":"2022-07-26T08:33:15.000Z","updated":"2022-07-31T08:43:21.603Z","comments":true,"path":"api/articles/SSM.json","keywords":null,"cover":[],"text":"spring官网 Spring Spring Framework是Spring生态圈中最基础的项目，是其他项目的根基 学习路线 核心容器的核心概念 代码书写现状 代码耦合度高 解决方案 使用对象时，在程序中不要主动使用new产生对象，转换为由外部提供对象 IoC(Inversio...","link":"","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"17 mins."},"categories":[],"tags":[],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}