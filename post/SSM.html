<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Keep Team">
    
    <title>
        
            SSM |
        
        Keep Theme
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"2295237514.github.io","root":"/","language":"en"};
    KEEP.theme_config = {"toc":{"enable":false,"number":false,"expand_all":false,"init_open":false},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":false,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":false}}},"local_search":{"enable":false,"preload":false},"code_copy":{"enable":false,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                Keep Theme
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">SSM</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Keep Team</span>
                        
                            <span class="author-label">Lv2</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2022-07-26 16:33:15</span>
        <span class="mobile">2022-07-26 16:33</span>
    </span>
    
    

    
    
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p><a class="link"   target="_blank" rel="noopener" href="https://spring.io/" >spring官网<i class="fas fa-external-link-alt"></i></a></p>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><ul>
<li>Spring Framework是Spring生态圈中最基础的项目，是其他项目的根基</li>
</ul>
<p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220726165418.png"></p>
<h2 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h2><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220726165701.png"></p>
<h2 id="核心容器的核心概念"><a href="#核心容器的核心概念" class="headerlink" title="核心容器的核心概念"></a>核心容器的核心概念</h2><ul>
<li><p>代码书写现状</p>
<ul>
<li>代码耦合度高</li>
</ul>
</li>
<li><p>解决方案</p>
<ul>
<li>使用对象时，在程序中不要主动使用new产生对象，转换为由<em>外部</em>提供对象</li>
</ul>
</li>
<li><p><strong>IoC(Inversion of Control) 控制反转</strong></p>
<ul>
<li>对象的创建控制权由程序转移到<em>外部</em>，这种思想称为控制反转</li>
<li>目标：解耦</li>
</ul>
</li>
<li><p>Spring技术对IoC思想进行了实现</p>
<ul>
<li>Spring提供了一个容器，称为IoC容器，用来充当IoC思想的<em>外部</em></li>
<li>IoC容器负责对象的创建、初始化等一系列工作，被创建或被管理的对象在IoC容器中统称为Bean</li>
</ul>
</li>
<li><p><strong>DI(Dependency Injection)依赖注入</strong></p>
<ul>
<li>在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入</li>
</ul>
</li>
</ul>
<hr>
<p><strong>本节总结：</strong></p>
<ul>
<li><strong>目标：充分解耦</strong><ul>
<li><strong>在IoC容器中管理bean（IoC）</strong></li>
<li><strong>在IoC容器内将有依赖关系的bean进行关系绑定（DI）</strong></li>
</ul>
</li>
<li><strong>最终效果</strong><ul>
<li><strong>使用对象时不仅可以直接从IoC容器中获取，并且获取的bean已经绑定了所有的依赖关系</strong></li>
</ul>
</li>
</ul>
<h2 id="IoC入门案例思路分析"><a href="#IoC入门案例思路分析" class="headerlink" title="IoC入门案例思路分析"></a>IoC入门案例思路分析</h2><p> 1.管理什么？(Service与Dao)</p>
<p>2.如何将被管理的对象告知IoC容器？(配置)</p>
<p>3.被管理的对象交给IoC容器，如何获取到IoC容器？(接口)</p>
<p>4.IoC容器得到后，如何从容器中获取bean？(接口方法)</p>
<p>5.使用Spring时怎么导入坐标(pom.xml)</p>
<p>使用步骤：</p>
<p>1.导jar包</p>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt;
    &lt;version&gt;5.2.10.RELEASE&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;</code></pre>

<p>2.定义spring管理的类（接口）</p>
<p>3.创建Spirng配置文件，配置对应类作为Spring管理的bean</p>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;
&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;
       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;
       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;

    &lt;bean id&#x3D;&quot;bookDaoBean&quot; class&#x3D;&quot;com.itheima.dao.impl.BookDaoImpl&quot;&#x2F;&gt;
    &lt;bean id&#x3D;&quot;bookServiceBean&quot; class&#x3D;&quot;com.itheima.service.impl.BookServiceImpl&quot;&#x2F;&gt;
&lt;&#x2F;beans&gt;</code></pre>

<p>注意事项：bean定义式id属性在同一个上下文中不能重复</p>
<p>4.初始化IoC容器，通过容器获取bean</p>
<pre class="line-numbers language-none"><code class="language-none">ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);

需要获取的对象的类型 bookDao &#x3D; (需要获取的对象类型)applicationContext.getBean(&quot;bookDaoBean&quot;);</code></pre>

<p>applicationContext.getBean(“”)获取的是一个Object类型的对象，应对其进行强制类型转换</p>
<h2 id="DI入门案例"><a href="#DI入门案例" class="headerlink" title="DI入门案例"></a>DI入门案例</h2><p>1.基于IoC管理bean</p>
<p>2.Service中使用new形式创建的Dao对象是否保留？(否)</p>
<p>3.Service中需要的Dao对象如何进入到Service中？(提供方法)</p>
<p>4.Service与Dao间的关系如何描述？(配置)</p>
<p>使用步骤：</p>
<p>1.删除使用new的形式创建对象的代码</p>
<p>private BookDao bookDao <del>&#x3D; new BookDaoImpl()</del>;</p>
<p>public void save(){<br>    System.out.println(“book service 。。。”);<br>    bookDao.save();<br>}</p>
<p>2.提供依赖对象对应的setter方法</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class BookServiceImpl implements BookService &#123;

    private BookDao bookDao;

    public void save()&#123;
        System.out.println(&quot;book service 。。。。。。&quot;);
        bookDao.save();
    &#125;

    public void setBookDao(BookDao bookDao) &#123;
        this.bookDao &#x3D; bookDao;
    &#125;
&#125;</code></pre>

<p>3.配置service与dao之间的关系</p>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;bean id&#x3D;&quot;bookServiceBean&quot; class&#x3D;&quot;com.itheima.service.impl.BookServiceImpl&quot;&gt;
        &lt;property name&#x3D;&quot;bookDao&quot; ref&#x3D;&quot;bookDaoBean&quot;&#x2F;&gt;
&lt;&#x2F;bean&gt;
&#x2F;&#x2F; property 标签中 name是 id&#x3D;&quot;bookServiceBean&quot;对象里属性的名称   ref则是bean对象的名称</code></pre>

<h2 id="bean基础配置"><a href="#bean基础配置" class="headerlink" title="bean基础配置"></a>bean基础配置</h2><h3 id="别名配置"><a href="#别名配置" class="headerlink" title="别名配置"></a>别名配置</h3><p>姓名：name</p>
<p>类型：属性</p>
<p>所属：bean标签</p>
<p>范例</p>
<pre class="line-numbers language-none"><code class="language-none">&lt;bean id&#x3D;&quot;bookServiceBean&quot; name&#x3D;&quot;FirstBean,SecondBean&quot; class&#x3D;&quot;com.itheima.service.impl.BookServiceImpl&quot;&gt;
        &lt;property name&#x3D;&quot;bookDao&quot; ref&#x3D;&quot;bookDaoBean&quot;&#x2F;&gt;
    &lt;&#x2F;bean&gt;</code></pre>

<p><strong>注意事项</strong></p>
<p>获取bean无论是通过id还是name获取，如果无法获取到，将抛出异常NoSuchBeanDefinitionException</p>
<p>NoSuchBeanDefinitionException: No bean named ‘bookServiceImpl’ available</p>
<h3 id="bean作用范围说明"><a href="#bean作用范围说明" class="headerlink" title="bean作用范围说明"></a>bean作用范围说明</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220730095635.png"></p>
<p>可见，Spring默认给我们创建的bean是一个单例模式，</p>
<p>我们可以通过在 bean标签中设置属性 scope&#x3D;”prototype”来讲bean设置成非单例</p>
<ul>
<li>适合交给容器进行管理的bean<ul>
<li>表现层对象</li>
<li>业务层对象</li>
<li>数据层对象</li>
<li>工具对象</li>
</ul>
</li>
<li>不适合交给容器进行管理的bean<ul>
<li>封装实体的域对象</li>
</ul>
</li>
</ul>
<h3 id="单例bean与原型bean的区别"><a href="#单例bean与原型bean的区别" class="headerlink" title="单例bean与原型bean的区别"></a>单例bean与原型bean的区别</h3><p><em>单例bean：如果一个bean被声明为单例的时候，在处理多次请求的时候在Spring容器里只实例化出一个bean，后续的请求都公用这个对象，这个对象会保存在一个map里面。<br>当有请求来的时候会先从缓存(map)里查看有没有，有的话直接使用这个对象，没有的话才实例化一个新的对象，所以这是个单例的。（ThreadLocal ）创建完后，后面都会复用这个bean</em></p>
<p><em>原型(prototype)bean来说当每次请求来的时候直接实例化新的bean，没有缓存以及从缓存查的过程。</em></p>
<p>结论：</p>
<p><em>单例的bean只有第一次创建新的bean 后面都会复用该bean，所以不会频繁创建对象。</em></p>
<p><em>原型的bean每次都会新创建</em></p>
<p>单例bean的优势<br>由于不会每次都新创建新对象所以有一下几个性能上的优势：</p>
<p><strong>1.减少了新生成实例的消耗</strong><br>新生成实例消耗包括两方面，第一，Spring会通过反射或者cglib来生成bean实例这都是耗性能的操作，其次给对象分配内存也会涉及复杂算法。</p>
<p><strong>2.减少jvm垃圾回收</strong><br>由于不会给每个请求都新生成bean实例，所以自然回收的对象少了。</p>
<p><strong>3.可以快速获取到bean</strong><br>因为单例的获取bean操作除了第一次生成之外其余的都是从缓存里获取的所以很快。</p>
<p><em><strong>单例bean的劣势</strong></em><br>单例的bean一个很大的劣势就是他不能做到线程安全！！！尤其是高并发情况下。</p>
<p>由于所有请求都共享一个bean实例，所以这个bean要是有状态的一个bean的话可能在并发场景下出现问题，而原型的bean则不会有这样问题（但也有例外，比如他被单例bean依赖），因为给每个请求都新创建实例。</p>
<h2 id="bean实例化的三种方式"><a href="#bean实例化的三种方式" class="headerlink" title="bean实例化的三种方式"></a>bean实例化的三种方式</h2><h3 id="构造方法（常用）"><a href="#构造方法（常用）" class="headerlink" title="构造方法（常用）"></a>构造方法（常用）</h3><ul>
<li>bean本质上就是对象，创建bean使用构造方法完成</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class BookDaoImpl implements BookDao &#123;

&#x2F;&#x2F;    private BookDaoImpl()&#123;
&#x2F;&#x2F;        System.out.println(&quot;book dao struct is running......&quot;);
&#x2F;&#x2F;    &#125;
    public void save() &#123;
        System.out.println(&quot;BookDao 我他吗来啦&quot;);
    &#125;
&#125;</code></pre>



<ul>
<li>提供可访问的构造方法</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;bean id&#x3D;&quot;bookDaoBean&quot; class&#x3D;&quot;com.itheima.dao.impl.BookDaoImpl&quot;&#x2F;&gt;</code></pre>

<h3 id="静态工厂（了解）"><a href="#静态工厂（了解）" class="headerlink" title="静态工厂（了解）"></a>静态工厂（了解）</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220730114100.png"></p>
<h3 id="实例工厂"><a href="#实例工厂" class="headerlink" title="实例工厂"></a>实例工厂</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220730114017.png"></p>
<h3 id="FactoryBean（实用）"><a href="#FactoryBean（实用）" class="headerlink" title="FactoryBean（实用）"></a>FactoryBean（实用）</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220730130510.png"></p>
<h2 id="bean生命周期"><a href="#bean生命周期" class="headerlink" title="bean生命周期"></a>bean生命周期</h2><ul>
<li>生命周期：从创建到销毁的完整过程</li>
<li>bean生命周期控制：在bean创建后到销毁前做一些事情</li>
</ul>
<p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220730133209.png"></p>
<p>接口控制（了解）</p>
<p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220730133605.png"></p>
<h3 id="bean生命周期-1"><a href="#bean生命周期-1" class="headerlink" title="bean生命周期"></a>bean生命周期</h3><ul>
<li><p>初始化容器</p>
<p>1.创建对象（内存分配）</p>
<p>2.执行构造方法</p>
<p>3.执行属性注入（set操作）</p>
<p>4.执行bean初始化方法</p>
</li>
<li><p>使用bean</p>
<p>1.执行业务操作</p>
</li>
<li><p>关闭&#x2F;销毁容器</p>
<p>1.执行bean销毁方法</p>
</li>
</ul>
<h3 id="bean销毁时机"><a href="#bean销毁时机" class="headerlink" title="bean销毁时机"></a>bean销毁时机</h3><ul>
<li><p>容器关闭前触发bean的销毁</p>
</li>
<li><p>关闭容器方式：</p>
<ul>
<li><p>手工关闭容器</p>
<p>ConfigurableApplicationContext接口close（）方法</p>
</li>
<li><p>注册关闭钩子，在虚拟机退出前先关闭容器再退出虚拟机</p>
<p>ConfigurableApplicationContext接口registerShutdownHook（）操作</p>
</li>
</ul>
</li>
</ul>
<h2 id="依赖注入方式"><a href="#依赖注入方式" class="headerlink" title="依赖注入方式"></a>依赖注入方式</h2><ul>
<li><p>思考：向一个类中传递数据的方式有几种？</p>
<ul>
<li>普通方法（set方法）</li>
<li>构造方法</li>
</ul>
</li>
<li><p>思考：依赖注入描述了在容器中简历bean与bean之间依赖关系的过程，如果bean运行需要的是数据或字符串呢？</p>
</li>
<li><p>setter注入</p>
<ul>
<li><p>简单类型</p>
<p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220730140922.png"></p>
</li>
<li><p>引用类型</p>
<p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220730140856.png"></p>
</li>
</ul>
</li>
<li><p>构造器注入</p>
<ul>
<li><p>简单类型</p>
<p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220730163208.png"></p>
</li>
<li><p>引用类型</p>
<p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220730163117.png"></p>
</li>
</ul>
</li>
</ul>
<h3 id="依赖注入方式选择"><a href="#依赖注入方式选择" class="headerlink" title="依赖注入方式选择"></a>依赖注入方式选择</h3><p>1.强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现</p>
<p>2.可选依赖使用setter注入进行，灵活性强</p>
<p>3.Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨</p>
<p>4.如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入</p>
<p>5.实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入</p>
<p><strong>6.自己开发的模块推荐使用setter注入</strong></p>
<h3 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h3><ul>
<li><p>IoC容器根据bean所以来的资源在容器中自动查找并注入到bean中的过程称为自动装配</p>
</li>
<li><p>自动装配方式</p>
<ul>
<li>按类型（常用）</li>
<li>按名称</li>
<li>按构造方法</li>
<li>不启用自动装配</li>
</ul>
</li>
<li><p>配种中使用bean标签autowire</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220731085314.png"></p>
<ul>
<li>自动装配用于引用类型依赖注入，不能对简单类型进行操作</li>
<li>使用按类型装配时(byType)必须保障容器中想同类型的bean唯一，推荐使用</li>
<li>使用按名称装配时(byName)必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用</li>
<li>自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效</li>
</ul>
<h3 id="集合注入"><a href="#集合注入" class="headerlink" title="集合注入"></a>集合注入</h3><p><em>数组，List，Set，Map,Properties</em></p>
<p><strong>bean所依赖的实现类</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class BookDaoImpl implements BookDao &#123;

    private int[] array;

    private List&lt;String&gt; list;

    private Set&lt;String&gt; set;

    private Map&lt;String,String&gt; map;

    private Properties properties;




    public void setArray(int[] array) &#123;
        this.array &#x3D; array;
    &#125;

    public void setList(List&lt;String&gt; list) &#123;
        this.list &#x3D; list;
    &#125;

    public void setSet(Set&lt;String&gt; set) &#123;
        this.set &#x3D; set;
    &#125;

    public void setMap(Map&lt;String, String&gt; map) &#123;
        this.map &#x3D; map;
    &#125;

    public void setProperties(Properties properties) &#123;
        this.properties &#x3D; properties;
    &#125;




    public void save() &#123;
        System.out.println(&quot;book dao save ...&quot;);

        System.out.println(&quot;遍历数组:&quot; + Arrays.toString(array));

        System.out.println(&quot;遍历List&quot; + list);

        System.out.println(&quot;遍历Set&quot; + set);

        System.out.println(&quot;遍历Map&quot; + map);

        System.out.println(&quot;遍历Properties&quot; + properties);
    &#125;
&#125;</code></pre>

<p>applicationContext.xml</p>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;
&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;
       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;
       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;
    &lt;bean id&#x3D;&quot;bookDao&quot; class&#x3D;&quot;com.itheima.dao.impl.BookDaoImpl&quot;&gt;
        &lt;!--数组注入--&gt;
        &lt;property name&#x3D;&quot;array&quot;&gt;
            &lt;array&gt;
                &lt;value&gt;100&lt;&#x2F;value&gt;
                &lt;value&gt;200&lt;&#x2F;value&gt;
                &lt;value&gt;300&lt;&#x2F;value&gt;
            &lt;&#x2F;array&gt;
        &lt;&#x2F;property&gt;
        &lt;!--list集合注入--&gt;
        &lt;property name&#x3D;&quot;list&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;itcast&lt;&#x2F;value&gt;
                &lt;value&gt;itheima&lt;&#x2F;value&gt;
                &lt;value&gt;boxuegu&lt;&#x2F;value&gt;
                &lt;value&gt;chuanzhihui&lt;&#x2F;value&gt;
            &lt;&#x2F;list&gt;
        &lt;&#x2F;property&gt;
        &lt;!--set集合注入--&gt;
        &lt;property name&#x3D;&quot;set&quot;&gt;
            &lt;set&gt;
                &lt;value&gt;itcast&lt;&#x2F;value&gt;
                &lt;value&gt;itheima&lt;&#x2F;value&gt;
                &lt;value&gt;boxuegu&lt;&#x2F;value&gt;
                &lt;value&gt;boxuegu&lt;&#x2F;value&gt;
            &lt;&#x2F;set&gt;
        &lt;&#x2F;property&gt;
        &lt;!--map集合注入--&gt;
        &lt;property name&#x3D;&quot;map&quot;&gt;
            &lt;map&gt;
                &lt;entry key&#x3D;&quot;country&quot; value&#x3D;&quot;china&quot;&#x2F;&gt;
                &lt;entry key&#x3D;&quot;province&quot; value&#x3D;&quot;henan&quot;&#x2F;&gt;
                &lt;entry key&#x3D;&quot;city&quot; value&#x3D;&quot;kaifeng&quot;&#x2F;&gt;
            &lt;&#x2F;map&gt;
        &lt;&#x2F;property&gt;
        &lt;!--Properties注入--&gt;
        &lt;property name&#x3D;&quot;properties&quot;&gt;
            &lt;props&gt;
                &lt;prop key&#x3D;&quot;country&quot;&gt;china&lt;&#x2F;prop&gt;
                &lt;prop key&#x3D;&quot;province&quot;&gt;henan&lt;&#x2F;prop&gt;
                &lt;prop key&#x3D;&quot;city&quot;&gt;kaifeng&lt;&#x2F;prop&gt;
            &lt;&#x2F;props&gt;
        &lt;&#x2F;property&gt;
    &lt;&#x2F;bean&gt;
&lt;&#x2F;beans&gt;
</code></pre>

<h2 id="第三方资源配置管理"><a href="#第三方资源配置管理" class="headerlink" title="第三方资源配置管理"></a>第三方资源配置管理</h2><ul>
<li><p>导入druid坐标</p>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;
            &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;
            &lt;version&gt;1.1.16&lt;&#x2F;version&gt;
        &lt;&#x2F;dependency&gt;</code></pre>
</li>
<li><p>配置数据源对象作为spring管理的bean</p>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;bean class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
        &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;
        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;spring_db&quot;&#x2F;&gt;
        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;&quot;&#x2F;&gt;
        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;&quot;&#x2F;&gt;
&lt;&#x2F;bean&gt;</code></pre></li>
</ul>
<h2 id="加载properties文件"><a href="#加载properties文件" class="headerlink" title="加载properties文件"></a>加载properties文件</h2><p>由于上次学习将数据库的用户名，密码，全配置在applicationContext.xml之中，非常的危险，故应该使用properties文件记录数据库信息</p>
<p>1.开启context命名空间</p>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;
&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;
       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;
       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;
       xsi:schemaLocation&#x3D;&quot;
            http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans
            http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd
            http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context
            http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd
            &quot;&gt;
    &lt;!--  将含有beans的代码复制一份并用context替换beans--&gt;</code></pre>



<p>2.使用context空间加载properties文件</p>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;context:property-placeholder location&#x3D;&quot;classpath*:*.properties&quot; system-properties-mode&#x3D;&quot;NEVER&quot;&#x2F;&gt;</code></pre>



<ol start="3">
<li>使用属性占位符${}读取properties文件中的属性</li>
</ol>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;bean class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
        &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;$&#123;jdbc.Driver&#125;&quot;&#x2F;&gt;
        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot;&#x2F;&gt;
        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot;&#x2F;&gt;
        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&#x2F;&gt;
&lt;&#x2F;bean&gt;</code></pre>

<p>4.自己配置的 jdbc.properties文件内容</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">jdbc.driver&#x3D;com.mysql.jdbc.Driver
jdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;spring_db
jdbc.username&#x3D;root
jdbc.password&#x3D;root</code></pre>

<p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220731110143.png"></p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220731114926.png"></p>
<h3 id="获取bean"><a href="#获取bean" class="headerlink" title="获取bean"></a>获取bean</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220731115010.png"></p>
<h3 id="容器类结构层次"><a href="#容器类结构层次" class="headerlink" title="容器类结构层次"></a>容器类结构层次</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220731131448.png"></p>
<h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><ul>
<li>类路径加载配置文件</li>
</ul>
<p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220731131508.png"></p>
<h2 id="核心容器总结"><a href="#核心容器总结" class="headerlink" title="核心容器总结"></a>核心容器总结</h2><ul>
<li>BeanFactory是IoC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载</li>
<li>ApplicationContext接口是Spring容器的核心接口，初始化时bean立即加载</li>
<li>ApplicationContext接口提供基础的bean操作相关方法，通过其他接口扩展其功能</li>
<li>ApplicationContext接口常用初始化类<ul>
<li>ClassPathXmlApplicationContext</li>
<li>FileSystemXmlApplicationContext</li>
</ul>
</li>
</ul>
<h3 id="bean相关"><a href="#bean相关" class="headerlink" title="bean相关"></a>bean相关</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220731132707.png"></p>
<h3 id="依赖注入相关"><a href="#依赖注入相关" class="headerlink" title="依赖注入相关"></a>依赖注入相关</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220731132729.png"></p>
<h2 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h2><h3 id="注解开发定义bean"><a href="#注解开发定义bean" class="headerlink" title="注解开发定义bean"></a>注解开发定义bean</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220731140547.png"></p>
<p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220731140608.png"></p>
<p><strong>同时这几个注解后面也可以添加一些参数，比如比较常用的一个是注解的括号中加value属性，来表示这个组件在容器中的ID，如果不设置value值时，默认的ID是类名的全称（第一个字母小写）。</strong></p>
<p><strong>在这里有一点需要注意：事实上Spring并没有能力识别一个组件到底是不是它所标记的类型，</strong>即使将@Respository注解用在一个表述层控制器组件上面也不会产生任何错误，所以@Respository、@Service、@Controller这几个注解仅仅是为了让开发人员自己明确当前的组件扮演的角色。方便将组件加入到容器中去。</p>
<h3 id="纯注解开发"><a href="#纯注解开发" class="headerlink" title="纯注解开发"></a>纯注解开发</h3><ul>
<li><p>Spring3.0升级了纯注解开发模式，使用java类替代配置文件，开启了Spring快速开发赛道</p>
</li>
<li><p>读取Spring核心配置文件初始化容器对象切换为读取Java配置类初始化容器对象</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;加载配置文件初始化容器
ApplicationContext ctx &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
&#x2F;&#x2F;加载配置类初始化容器    
ApplicationContext ctx &#x3D; new AnnotationConfigApplicationContext(SpringConfig.class);</code></pre>






</li>
<li><p>Java类替代Spring核心配置文件</p>
</li>
</ul>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;
&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;
       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;
       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;
       xsi:schemaLocation&#x3D;&quot;
        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd
        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;

    &lt;context:component-scan base-package&#x3D;&quot;com.itheima&quot;&#x2F;&gt;

&lt;&#x2F;beans&gt;


&#x2F;&#x2F;配置文件被替换为


&#x2F;&#x2F;声明当前类为Spring配置类
@Configuration
&#x2F;&#x2F;设置bean扫描路径，多个路径书写为字符串数组格式
@ComponentScan(&#123;&quot;com.itheima.service&quot;,&quot;com.itheima.dao&quot;&#125;)
public class SpringConfig &#123;
&#125;
</code></pre>

<ul>
<li><p>@Configuration注解用于设定当前类为配置类</p>
</li>
<li><p>@ComponentScan注解用于设定扫描路径，次注解只能添加一次，多个数据请用数组格式</p>
<pre class="line-numbers language-none"><code class="language-none">@ComponentScan(&#123;&quot;com.itheima.service&quot;,&quot;com.itheima.dao&quot;&#125;)</code></pre></li>
</ul>
<h3 id="注解开发小结"><a href="#注解开发小结" class="headerlink" title="注解开发小结"></a>注解开发小结</h3><p>1.定义bean</p>
<ul>
<li>@Component<ul>
<li>@Controller</li>
<li>@Service</li>
<li>@Repository</li>
</ul>
</li>
<li>&lt;context:component-scan&#x2F;&gt;</li>
</ul>
<p>2.纯注解开发</p>
<ul>
<li>@Configuration</li>
<li>@ComponentScan</li>
<li>AnnotationConfigApplicationContext</li>
</ul>
<h3 id="bean作用范围与生命周期管理"><a href="#bean作用范围与生命周期管理" class="headerlink" title="bean作用范围与生命周期管理"></a>bean作用范围与生命周期管理</h3><ul>
<li>使用@Scope定义bean作用范围</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Repository
@Scope(&quot;singleton&quot;)
public class BookDaoImpl implements BookDao&#123;
&#125;</code></pre>

<p>使用@PostConstruct、@PreDestroy定义bean生命周期</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Repository
@Scope(&quot;singleton&quot;)
public class BookDaoImpl implements BookDao&#123;
	public BookDaoImpl()&#123;
		System.out.println(&quot;book dao constructor ...&quot;);
	&#125;
    @PostConstruct
    public void init()&#123;
        System.out.println(&quot;book init ...&quot;);
    &#125;
    @PreDestroy
    public void destroy()&#123;
        System.out.println(&quot;book destroy ...&quot;)
    &#125;
&#125;</code></pre>

<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><ul>
<li>使用@Autowired注解开发自动装配模式(按类型)</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Service
public class bookServiceImpl implements BookService&#123;
	@Autowired
	private BookDao bookDao;
	
	public void save()&#123;
		System.out.println(&quot;book service save ...&quot;);
		bookDao.save();
	&#125;
&#125;</code></pre>

<ul>
<li>注意：自动装配基于反射设计创建对象并暴力反射对应属性为私有属性初始化数据，隐藏无需提供setter方法</li>
<li>注意：自动装配建议使用无参构造方法创建对象(默认)，如果不提供对应构造对象，请提供唯一的构造方法</li>
</ul>
<hr>
<ul>
<li>使用@Qualifier注解开启指定名称装配bean</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Service
public class BookServiceImpl implements BookService &#123;
    &#x2F;&#x2F;@Autowired：注入引用类型，自动装配模式，默认按类型装配
    @Autowired
    &#x2F;&#x2F;@Qualifier：自动装配bean时按bean名称装配
    @Qualifier(&quot;bookDao&quot;)
    private BookDao bookDao;

    public void save() &#123;
        System.out.println(&quot;book service save ...&quot;);
        bookDao.save();
    &#125;
&#125;</code></pre>

<ul>
<li>注意：@Qualifier注解无法单独使用，必须配合@Autowired注解使用</li>
</ul>
<hr>
<ul>
<li>使用@Value实现简单类型注入</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Repository(&quot;bookDao&quot;)
public class BookDaoImpl implements BookDao &#123;
    &#x2F;&#x2F;@Value：注入简单类型（无需提供set方法）
    @Value(&quot;Hello World&quot;)
    private String name;

    public void save() &#123;
        System.out.println(&quot;book dao save ...&quot; + name);
    &#125;
&#125;</code></pre>

<hr>
<h4 id="加载properties文件-1"><a href="#加载properties文件-1" class="headerlink" title="加载properties文件"></a>加载properties文件</h4><ul>
<li>使用@PropertySource注解加载properties文件</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration
@ComponentScan(&quot;com.itheima&quot;)
@PropertySource(&quot;classpath:jdbc.properties&quot;)
public class SpringConfig&#123;
&#125;</code></pre>

<ul>
<li>注意：路径仅支持单一文件配置，多文件请使用数组格式配置，不允许使用通配符*</li>
</ul>
<h3 id="第三方bean"><a href="#第三方bean" class="headerlink" title="第三方bean"></a>第三方bean</h3><h4 id="第三方bean管理"><a href="#第三方bean管理" class="headerlink" title="第三方bean管理"></a>第三方bean管理</h4><ul>
<li>使用@bean配置第三方bean</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration
public class SpringConfig &#123;

    @Bean
    public DataSource dataSource()&#123;
        DruidDataSource ds &#x3D; new DruidDataSource();
        ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
      	ds.setUrl(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;spring_db&quot;);
        ds.setUsername(&quot;root&quot;);
        ds.setPassword(&quot;1234&quot;);
        return ds;
    &#125;
&#125;</code></pre>

<p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220731161957.png"></p>
<p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220731162026.png"></p>
<p><strong>建议使用方式一，因为方式二看不出你用过哪些配置类</strong></p>
<h4 id="第三方bean依赖注入"><a href="#第三方bean依赖注入" class="headerlink" title="第三方bean依赖注入"></a>第三方bean依赖注入</h4><ul>
<li>简单类型依赖注入</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class JdbcConfig &#123;
    &#x2F;&#x2F;1.定义一个方法获得要管理的对象
    @Value(&quot;com.mysql.jdbc.Driver&quot;)
    private String driver;
    @Value(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;spring_db&quot;)
    private String url;
    @Value(&quot;root&quot;)
    private String userName;
    @Value(&quot;root&quot;)
    private String password;
    &#x2F;&#x2F;2.添加@Bean，表示当前方法的返回值是一个bean
    &#x2F;&#x2F;@Bean修饰的方法，形参根据类型自动装配
    @Bean
    public DataSource dataSource(BookDao bookDao)&#123;
        System.out.println(bookDao);
        DruidDataSource ds &#x3D; new DruidDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        ds.setUsername(userName);
        ds.setPassword(password);
        return ds;
    &#125;
&#125;</code></pre>

<ul>
<li>引用类型依赖注入</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Bean
   public DataSource dataSource(BookDao bookDao)&#123;
       System.out.println(bookDao);
       DruidDataSource ds &#x3D; new DruidDataSource();
       ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
       ds.setUrl(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;spring_db&quot;);
       ds.setUsername(&quot;root&quot;);
       ds.setPassword(&quot;1234&quot;);
       return ds;
   &#125;</code></pre>

<p><strong>引用类型注入只需要为bean定义方法设置形参即可，容器会根据类型自动装配对象</strong></p>
<h2 id="注解开发总结"><a href="#注解开发总结" class="headerlink" title="注解开发总结"></a>注解开发总结</h2><h3 id="XML配置对比注解配置"><a href="#XML配置对比注解配置" class="headerlink" title="XML配置对比注解配置"></a>XML配置对比注解配置</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220731163956.png"></p>
<h2 id="Spring整合mybatis"><a href="#Spring整合mybatis" class="headerlink" title="Spring整合mybatis"></a>Spring整合mybatis</h2><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220802102910.png"></p>
<p>![](<a class="link"   target="_blank" rel="noopener" href="https://raw.githubusercontent.com/2295237514/image/main/20220802102956.png" >https://raw.githubusercontent.com/2295237514/image/main/20220802102956.png<i class="fas fa-external-link-alt"></i></a></p>
<p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220802103421.png"></p>
<p><strong>Spring应该管理的bean是SqlsessionFactory</strong></p>
<p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220802153323.png"></p>
<p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220802153412.png"></p>
<h2 id="Spring整合junit"><a href="#Spring整合junit" class="headerlink" title="Spring整合junit"></a>Spring整合junit</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;设置类运行器
@RunWith(SpringJUnit4ClassRunner.class)
&#x2F;&#x2F;设置Spring环境对应的配置类
@ContextConfiguration(classes &#x3D; SpringConfig.class)
public class AccountServiceTest &#123;
    &#x2F;&#x2F;支持自动装配注入bean
    @Autowired
    private AccountService accountService;
    @Test
    public void testFindById()&#123;
        System.out.println(accountService.findById(1));

    &#125;
&#125;</code></pre>

<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><ul>
<li><p>AOP(Aspect Oriented Programming)面向切面编程，一种编程范式，指导开发者如何组织程序结构</p>
<ul>
<li>OOP（Object Oriented Programming）面向对象编程</li>
</ul>
</li>
<li><p>作用：在<em>不惊动原始设计的基础上</em>为其进行<em>功能增强</em></p>
</li>
<li><p>Spring理念：无入侵式&#x2F;无侵入式</p>
</li>
</ul>
<h3 id="AOP核心概念"><a href="#AOP核心概念" class="headerlink" title="AOP核心概念"></a>AOP核心概念</h3><ul>
<li>连接点(JoinPoint):程序执行过程中的任意位置，粒度为执行方法、抛出异常、设置变量等<ul>
<li>在SpringAop中，理解为方法的执行</li>
</ul>
</li>
<li>切入点（Pointcut）：匹配连接点的式子<ul>
<li>在SpringAOP中，一个切入点可以只描述一个具体方法，也可以匹配多个方法<ul>
<li>一个具体方法</li>
<li>匹配多个方法：所有的save方法，所有的get开头的方法，所有以D奥结尾的接口中的任意方法，所有带有一个参数的方法</li>
</ul>
</li>
</ul>
</li>
<li>通知（Advice）：在切入点处执行的操作，也就是共性功能<ul>
<li>在SpringAOP中，功能最终以方法的形式呈现</li>
</ul>
</li>
<li>通知类：定义通知的类</li>
<li>切面(Aspect)：描述通知与切入点的对应关系</li>
<li>目标对象（Target）：原始功能去掉共性功能对应的类产生的对象，这种对象是无法完成最终工作的</li>
<li>代理（Proxy）：目标对象无法直接完成工作，需要对其进行功能回填，通过原始对象的代理对象实现</li>
</ul>
<h3 id="AOP入门案例思路分析"><a href="#AOP入门案例思路分析" class="headerlink" title="AOP入门案例思路分析"></a>AOP入门案例思路分析</h3><p>开发模式：XML 或 <strong>注解</strong></p>
<p>思路分析：</p>
<p>1.导入坐标（pom.xml）</p>
<p>2.制作连接点方法（原始操作，Dao接口与实现类）</p>
<p>3.制作共性功能（通知类与通知）</p>
<p>4.定义切入点</p>
<p>5.绑定切入点与通知关系（切面）</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>1.导入aop相关坐标</p>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependency&gt;
      &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt;
      &lt;artifactId&gt;aspectjweaver&lt;&#x2F;artifactId&gt;
      &lt;version&gt;1.9.4&lt;&#x2F;version&gt;
    &lt;&#x2F;dependency&gt;</code></pre>

<p>2.定义dao接口与实现类</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface BookDao &#123;
    public void save();
    public void update();
&#125;</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Repository
public class BookDaoImpl implements BookDao &#123;

    public void save() &#123;
        System.out.println(System.currentTimeMillis());
        System.out.println(&quot;book dao save ...&quot;);
    &#125;

    public void update()&#123;
        System.out.println(&quot;book dao update ...&quot;);
    &#125;
&#125;</code></pre>

<p>3.定义通知类和切入点</p>
<p><strong>说明：切入点定义依托一个不具有实际意义的方法进行，即无参数，无返回值，方法体无实际逻辑</strong>,</p>
<p>4.最后绑定切入点与通知关系，并指定通知添加到原始连接点的具体执行位置</p>
<p>5.定义通知类受Spring容器管理，并定义当前类为切面类</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Component
&#x2F;&#x2F;设置当前类为切面类类
@Aspect
public class MyAdvice &#123;
    &#x2F;&#x2F;设置切入点，要求配置在方法上方
    @Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)
    private void pt()&#123;&#125;

    &#x2F;&#x2F;设置在切入点pt()的前面运行当前操作（前置通知）
    &#x2F;&#x2F; @Before(&quot;pt()&quot;)
    public void method()&#123;
        System.out.println(System.currentTimeMillis());
    &#125;
&#125;</code></pre>

<p>6.开启Spring对AOP注解驱动支持</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration
@ComponentScan(&quot;com.itheima&quot;)
&#x2F;&#x2F;开启注解开发AOP功能
@EnableAspectJAutoProxy
public class SpringConfig &#123;
&#125;</code></pre>

<h3 id="AOP工作流程"><a href="#AOP工作流程" class="headerlink" title="AOP工作流程"></a>AOP工作流程</h3><p>1.Spring容器启动</p>
<p>2.读取所有切面配置中的切入点</p>
<p>3.初始化bean，判定bean对应的类中的方法是否匹配到任意切入点</p>
<ul>
<li>匹配失败，创建对象</li>
<li>匹配成功，创建原始对象(目标对象)的代理对象</li>
</ul>
<p>4.获取bean执行方法</p>
<ul>
<li>获取bean，调用方法并执行，完成操作</li>
<li>获取的bean是代理对象时，根据代理对象的运行模式运行原始方法与增强的内容，完成操作</li>
</ul>
<h3 id="AOP切入点表达式"><a href="#AOP切入点表达式" class="headerlink" title="AOP切入点表达式"></a>AOP切入点表达式</h3><ul>
<li>切入点：要进行增强的方法</li>
<li>切入点表达式：要进行增强的方法的描述方法</li>
</ul>
<p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220803103702.png"></p>
<ul>
<li>切入点表达式标准格式：动作关键字(访问修饰符 返回值 包名.类&#x2F;接口名.方法名(参数)异常名)</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">execution(public User com.itheima.service.UserService.findById(int))</code></pre>

<ul>
<li>动作关键字：描述切入点的行为动作，例如execution表示执行到指定切入点</li>
<li>访问修饰符：public，private等，可以省略</li>
<li>返回值</li>
<li>包名</li>
<li>类&#x2F;接口名</li>
<li>方法名</li>
<li>参数</li>
<li>异常名：方法定义中抛出指定异常，可以省略</li>
</ul>
<p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220803150303.png"></p>
<p>*****：必有最少一个</p>
<p><strong>..</strong>:可以没有，也可以有任意个</p>
<h4 id="书写技巧"><a href="#书写技巧" class="headerlink" title="书写技巧"></a>书写技巧</h4><ul>
<li><p>所有代码按照规范标准开发，否则以下技巧全部失效</p>
</li>
<li><p>描述切入点<strong>通常描述接口</strong>，而不描述实现类</p>
</li>
<li><p>访问控制修饰符针对接口开发均采用public描述(<strong>可省略访问控制修饰符描述</strong>)</p>
</li>
<li><p>返回值类型对于增删改类使用精准类型加速匹配，对于查询类使用*通配快速描述</p>
</li>
<li><p><strong>包名</strong>书写尽量不使用**..*<em>匹配，效率过低，常用</em>做单个包描述匹配，或精准匹配</p>
</li>
<li><p><strong>接口名</strong>&#x2F;类型书写名称与模块相关的<strong>采用*匹配</strong>，例如UserService书写成*Service，绑定业务层接口</p>
</li>
<li><p><strong>方法名</strong>书写以<strong>动词</strong>进行<strong>精准匹配</strong>，名次采用*匹配，例如getById书写成getBy*</p>
</li>
<li><p>参数规则较为复杂，根据业务方法灵活调整</p>
</li>
<li><p>通常不适用异常作为匹配规则</p>
</li>
</ul>
<h3 id="AOP通知类型"><a href="#AOP通知类型" class="headerlink" title="AOP通知类型"></a>AOP通知类型</h3><ul>
<li><p>AOP通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置</p>
</li>
<li><p>AOP通知共分为5种类型</p>
<ul>
<li>前置通知 @Before</li>
<li>后置通知 @After</li>
<li>环绕通知（重点） @Around</li>
</ul>
<p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220803174820.png"></p>
<ul>
<li>返回后通知（了解）@AfterReturning</li>
<li>抛出异常后通知（了解）@AfterThrowing</li>
</ul>
</li>
</ul>
<h3 id="案例：测量业务层接口执行效率"><a href="#案例：测量业务层接口执行效率" class="headerlink" title="案例：测量业务层接口执行效率"></a>案例：测量业务层接口执行效率</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Component
@Aspect
public class ProjectAdvice &#123;
    &#x2F;&#x2F;匹配业务层的所有方法
    @Pointcut(&quot;execution(* com.itheima.service.*Service.*(..))&quot;)
    private void servicePt()&#123;&#125;

    &#x2F;&#x2F;设置环绕通知，在原始操作的运行前后记录执行时间
    @Around(&quot;ProjectAdvice.servicePt()&quot;)
    public void runSpeed(ProceedingJoinPoint pjp) throws Throwable &#123;
        &#x2F;&#x2F;获取执行的签名对象
        Signature signature &#x3D; pjp.getSignature();
        String className &#x3D; signature.getDeclaringTypeName();
        String methodName &#x3D; signature.getName();

        long start &#x3D; System.currentTimeMillis();
        for (int i &#x3D; 0; i &lt; 10000; i++) &#123;
           pjp.proceed();
        &#125;
        long end &#x3D; System.currentTimeMillis();
        System.out.println(&quot;万次执行：&quot;+ className+&quot;.&quot;+methodName+&quot;----&gt;&quot; +(end-start) + &quot;ms&quot;);
    &#125;
&#125;</code></pre>

<h3 id="AOP通知获取数据"><a href="#AOP通知获取数据" class="headerlink" title="AOP通知获取数据"></a>AOP通知获取数据</h3><ul>
<li>获取切入点方法的参数、<ul>
<li>JoinPoint：适用于前置、后置、返回后、抛出异常后通知</li>
<li>ProceedJoinPoint：适用于环绕通知</li>
<li><img src="https://raw.githubusercontent.com/2295237514/image/main/20220809095445.png"></li>
</ul>
</li>
<li>获取切入点方法返回值<ul>
<li>返回后通知</li>
<li>环绕通知</li>
<li><img src="https://raw.githubusercontent.com/2295237514/image/main/20220809095515.png"></li>
</ul>
</li>
<li>获取切入点方法运行异常信息<ul>
<li>抛出异常后通知</li>
<li>环绕通知</li>
<li><img src="https://raw.githubusercontent.com/2295237514/image/main/20220809095551.png"></li>
</ul>
</li>
</ul>
<h3 id="AOP总结"><a href="#AOP总结" class="headerlink" title="AOP总结"></a>AOP总结</h3><ul>
<li><p>概念：AOP面向切面编程，一种编程范式</p>
</li>
<li><p>作用：在不惊动原始设计的基础上为方法进行功能增强</p>
</li>
<li><p>核心概念：</p>
<ul>
<li><p>代理：SpringAOP的核心本质是采用代理模式实现的</p>
</li>
<li><p>连接点：在SpringAOP中，理解为任意方法的执行</p>
</li>
<li><p>切入点：匹配连接点的式子，也是具有共性功能的方法描述</p>
<ul>
<li><p>切入点表达式标准格式：动作关键字（访问修饰符  返回值  包名.类&#x2F;接口名.方法名（参数）异常名）</p>
<ul>
<li>execution(* com.itheima.service.*Service.*(..))</li>
</ul>
</li>
<li><p>切入点表达式描述通配符：</p>
<ul>
<li>作用：用于快速描述，范围描述</li>
<li>*：匹配任意符号（常用）</li>
<li>..：匹配多个连续的任意符号(常用)</li>
<li>+：匹配子类类型</li>
</ul>
</li>
<li><p>切入点表达式书写技巧</p>
<p>1.按标准规范开发</p>
<p>2.查询操作的返回值建议使用*匹配</p>
<p>3.减少使用..的形式描述包</p>
<p>4.对接口进行描述，使用*表示模块名，例如UserService的匹配描述为*Service</p>
<p>5.方法名书写保留动词，例如get,使用*表示名词，例如getById匹配描述为*getBy*</p>
<p>6.参数根据实际情况灵活调整</p>
</li>
</ul>
</li>
<li><p>通知：若干个方法的共性功能，在切入点处执行，具体体现为一个方法</p>
<ul>
<li>环绕通知：<ul>
<li>环绕通知依赖形参ProceedingJoinPoint才能实现对原始方法的调用</li>
<li>环绕通知可以隔离原始方法的调用执行</li>
<li>环绕通知返回值设置为Object类型</li>
<li>环绕通知中可以对原始方法调用过程中出现的异常进行处理</li>
</ul>
</li>
</ul>
</li>
<li><p>切面：描述通知与切入点的对应关系</p>
</li>
<li><p>目标对象：被代理的原始对象称为目标对象</p>
</li>
</ul>
</li>
</ul>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ul>
<li>Spirng事务作用：在数据层或业务层保障一系列的数据库操作同成功同失败</li>
</ul>
<h3 id="案例：银行账户转账"><a href="#案例：银行账户转账" class="headerlink" title="案例：银行账户转账"></a>案例：银行账户转账</h3><p>1.在业务层接口上添加Spring事务管理</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface AccountService&#123;
	@Transactional
	public void transfer(String out,String in,Double money);
&#125;</code></pre>

<p><strong>注意事项</strong></p>
<ul>
<li><p><em>Spring注解式事务通常添加在业务层接口中而不会添加到业务层实现类中，降低耦合</em></p>
</li>
<li><p><em>注解式事务可以添加到业务方法上表示当前方法开启事务，也可以添加到接口上表示当前接口所有方法开启事务</em></p>
</li>
</ul>
<p>2.设置事务管理器</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Bean
public PlatformTransactionManager transactionManager(DataSource dataSource)&#123;
	DataSourceTransactionManager ptm &#x3D; new DataSourceTransactionManager();
	ptm.setDataSource(dataSource);
    return ptm;
&#125;</code></pre>

<p><strong>注意事项</strong></p>
<ul>
<li><p><em>事务管理器要根据实现技术进行选择</em></p>
</li>
<li><p><em>MyBatis框架使用的是JDBC事务</em></p>
</li>
</ul>
<p>3.开启注解式事务驱动</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration
@ComponentScan(&quot;com.itheima&quot;)
@PropertySource(&quot;classpath:jdbc.properties&quot;)
@Import(&#123;JdbcConfig.class,MybatisConfig.class&#125;)
&#x2F;&#x2F;开启注解式事务驱动
@EnableTransactionManagement
public class SpringConfig &#123;
&#125;</code></pre>

<h3 id="Spring事务角色"><a href="#Spring事务角色" class="headerlink" title="Spring事务角色"></a>Spring事务角色</h3><ul>
<li>事务管理员：发起事务方，在Spring中通常指代业务层开启事务的方法</li>
<li>事务协调员：加入事务方，在Spring中通常代指数据层方法，也可以是业务层方法</li>
</ul>
<h3 id="事务相关配置"><a href="#事务相关配置" class="headerlink" title="事务相关配置"></a>事务相关配置</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220810100955.png"></p>
<p>有些异常默认事务不回滚，如<em>IOEXCEPTION</em>需手动设置	<strong>roolbackFor</strong>属性</p>
<h3 id="案例：转账业务追加日志"><a href="#案例：转账业务追加日志" class="headerlink" title="案例：转账业务追加日志"></a>案例：转账业务追加日志</h3><p>1.在业务层接口上添加Spring事务，设置事务传播行为REQUIRES_NEW(需要新事物)</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Service
public class LogServiceImpl implements LogService &#123;

    @Autowired
    private LogDao logDao;
	
    @Transactional(propagation &#x3D; Propagation.REQUIRES_NEW)
    public void log(String out,String in,Double money ) &#123;
        logDao.log(&quot;转账操作由&quot;+out+&quot;到&quot;+in+&quot;,金额：&quot;+money);
    &#125;
&#125;</code></pre>

<h3 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220810103946.png"></p>
<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><ul>
<li>SpringMVC技术与Servlet技术功能等同，均属于web层开发技术</li>
<li>SpringMVC是一种基于java实现MVC模型的轻量级Web框架</li>
<li>优点<ul>
<li>使用简单，开发便捷（相比于Servlet）</li>
<li>灵活性强</li>
</ul>
</li>
</ul>
<p><em>学习目标：</em></p>
<p><strong>1.掌握基于SpringMVC获取请求参数与响应json数据操作</strong></p>
<p><strong>2.熟练应用基于REST风格的请求路径设置与参数传递</strong></p>
<p>3.能够根据实际业务简历前后端开发通讯协议并进行实现</p>
<p><strong>4.基于SSM整合技术开发任意业务模块功能</strong></p>
<h2 id="SpringMVC入门案例"><a href="#SpringMVC入门案例" class="headerlink" title="SpringMVC入门案例"></a>SpringMVC入门案例</h2><p>1.使用SpringMVC技术需要先导入SpringMVC坐标与Servlet坐标</p>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependency&gt;
      &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;
      &lt;artifactId&gt;javax.servlet-api&lt;&#x2F;artifactId&gt;
      &lt;version&gt;3.1.0&lt;&#x2F;version&gt;
      &lt;scope&gt;provided&lt;&#x2F;scope&gt;
&lt;&#x2F;dependency&gt;
&lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;
      &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;
      &lt;version&gt;5.2.10.RELEASE&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;</code></pre>

<p>2.创建SpringMVC控制器类（等同于Servlet功能）</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controller
public class UserController &#123;

    @RequestMapping(&quot;&#x2F;save&quot;)
    @ResponseBody
    public String save()&#123;
        System.out.println(&quot;user save ...&quot;);
        return &quot;&#123;&#39;info&#39;:&#39;springmvc&#39;&#125;&quot;;
    &#125;
&#125;</code></pre>

<p>3.初始化SpringMVC环境（同Spring环境），设定SpringMVC加载对应的bean</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration
@ComponentScan(&quot;com.itheima.controller&quot;)
public class SpringMvcConfig&#123;

&#125;</code></pre>

<ul>
<li>知识点1：@Controller</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>@Controller</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>类注解</td>
</tr>
<tr>
<td>位置</td>
<td>SpringMVC控制器类定义上方</td>
</tr>
<tr>
<td>作用</td>
<td>设定SpringMVC的核心控制器bean</td>
</tr>
</tbody></table>
<ul>
<li>知识点2：@RequestMapping</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>@RequestMapping</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>类注解或方法注解</td>
</tr>
<tr>
<td>位置</td>
<td>SpringMVC控制器类或方法定义上方</td>
</tr>
<tr>
<td>作用</td>
<td>设置当前控制器方法请求访问路径</td>
</tr>
<tr>
<td>相关属性</td>
<td>value(默认)，请求访问路径</td>
</tr>
</tbody></table>
<ul>
<li>知识点3：@ResponseBody</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>@ResponseBody</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>类注解或方法注解</td>
</tr>
<tr>
<td>位置</td>
<td>SpringMVC控制器类或方法定义上方</td>
</tr>
<tr>
<td>作用</td>
<td>设置当前控制器方法响应内容为当前返回值，无需解析</td>
</tr>
</tbody></table>
<p><strong>注意事项</strong></p>
<ul>
<li>SpringMVC是基于Spring的，在pom.xml只导入了<code>spring-webmvc</code>jar包的原因是它会自动依赖spring相关坐标</li>
<li>AbstractDispatcherServletInitializer类是SpringMVC提供的快速初始化Web3.0容器的抽象类</li>
<li>AbstractDispatcherServletInitializer提供了三个接口方法供用户实现<ul>
<li>createServletApplicationContext方法，创建Servlet容器时，加载SpringMVC对应的bean并放入WebApplicationContext对象范围中，而WebApplicationContext的作用范围为ServletContext范围，即整个web容器范围</li>
<li>getServletMappings方法，设定SpringMVC对应的请求映射路径，即SpringMVC拦截哪些请求</li>
<li>createRootApplicationContext方法，如果创建Servlet容器时需要加载非SpringMVC对应的bean,使用当前方法进行，使用方式和createServletApplicationContext相同。</li>
<li>createServletApplicationContext用来加载SpringMVC环境</li>
<li>createRootApplicationContext用来加载Spring环境</li>
</ul>
</li>
</ul>
<h2 id="入门案例工作流程分析"><a href="#入门案例工作流程分析" class="headerlink" title="入门案例工作流程分析"></a>入门案例工作流程分析</h2><ul>
<li><p>启动服务器初始化过程</p>
<p>1.服务器启动，执行ServletContainerInitConfig类，初始化web容器</p>
<p>2.执行createServletApplicationContext方法，创建了WebApplicationContext对象</p>
<p>3.加载SpringMvcConfig</p>
<p>4.执行@ComponentScan加载对应的bean</p>
<p>5.加载UserController，每个@RequestMapping的名称对应一个具体的方法</p>
<p>6.执行getServletMappings方法，定义所有的请求都通过SpringMVC</p>
</li>
<li><p>单次请求过程</p>
<p>1.发送请求localhost&#x2F;save</p>
<p>2.web容器发现所有请求都经过SpringMVC，将请求交给SpringMVC处理</p>
<p>3.解析请求路径&#x2F;save</p>
<p>4.由&#x2F;save匹配执行对应的方法save()</p>
<p>5.执行save()</p>
<p>6.检测到有@ResponseBody直接将save()方法的返回值作为响应体返回给请求方</p>
</li>
</ul>
<h3 id="bean加载控制"><a href="#bean加载控制" class="headerlink" title="bean加载控制"></a>bean加载控制</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220811093412.png"></p>
<p>方式一:修改Spring配置类，设定扫描范围为精准范围。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration
@ComponentScan(&#123;&quot;com.itheima.service&quot;,&quot;comitheima.dao&quot;&#125;)
public class SpringConfig &#123;
&#125;</code></pre>

<p>方式二:修改Spring配置类，设定扫描范围为com.itheima,排除掉controller包中的bean</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration
@ComponentScan(value&#x3D;&quot;com.itheima&quot;,
    excludeFilters&#x3D;@ComponentScan.Filter(
    	type &#x3D; FilterType.ANNOTATION,
        classes &#x3D; Controller.class
    )
)
public class SpringConfig &#123;
&#125;</code></pre>

<ul>
<li>excludeFilters属性：设置扫描加载bean时，排除的过滤规则</li>
</ul>
<hr>
<p>bean的加载格式：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ServletContainersInitConfig extends AbstractDispatcherServletInitializer &#123;
    protected WebApplicationContext createServletApplicationContext() &#123;
        AnnotationConfigWebApplicationContext ctx &#x3D; new AnnotationConfigWebApplicationContext();
        ctx.register(SpringMvcConfig.class);
        return ctx;
    &#125;
    protected String[] getServletMappings() &#123;
        return new String[]&#123;&quot;&#x2F;&quot;&#125;;
    &#125;
    protected WebApplicationContext createRootApplicationContext() &#123;
      AnnotationConfigWebApplicationContext ctx &#x3D; new AnnotationConfigWebApplicationContext();
        ctx.register(SpringConfig.class);
        return ctx;
    &#125;
&#125;</code></pre>

<p>对于上述的配置方式，Spring还提供了一种更简单的配置方式，可以不用再去创建<code>AnnotationConfigWebApplicationContext</code>对象，不用手动<code>register</code>对应的配置类，如何实现?</p>
<p><strong>简化开发的格式</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123;

    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;
        return new Class[]&#123;SpringConfig.class&#125;;
    &#125;

    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;
        return new Class[]&#123;SpringMvcConfig.class&#125;;
    &#125;

    protected String[] getServletMappings() &#123;
        return new String[]&#123;&quot;&#x2F;&quot;&#125;;
    &#125;
&#125;</code></pre>

<h2 id="请求与响应"><a href="#请求与响应" class="headerlink" title="请求与响应"></a>请求与响应</h2><h3 id="请求映射路径"><a href="#请求映射路径" class="headerlink" title="请求映射路径"></a>请求映射路径</h3><p><strong>优化映射路径</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controller
@RequestMapping(&quot;&#x2F;user&quot;)
public class UserController &#123;

    @RequestMapping(&quot;&#x2F;save&quot;)
    @ResponseBody
    public String save()&#123;
        System.out.println(&quot;user save ...&quot;);
        return &quot;&#123;&#39;module&#39;:&#39;user save&#39;&#125;&quot;;
    &#125;
    
    @RequestMapping(&quot;&#x2F;delete&quot;)
    @ResponseBody
    public String save()&#123;
        System.out.println(&quot;user delete ...&quot;);
        return &quot;&#123;&#39;module&#39;:&#39;user delete&#39;&#125;&quot;;
    &#125;
&#125;

@Controller
@RequestMapping(&quot;&#x2F;book&quot;)
public class BookController &#123;

    @RequestMapping(&quot;&#x2F;save&quot;)
    @ResponseBody
    public String save()&#123;
        System.out.println(&quot;book save ...&quot;);
        return &quot;&#123;&#39;module&#39;:&#39;book save&#39;&#125;&quot;;
    &#125;
&#125;</code></pre>

<p><strong>注意:</strong></p>
<ul>
<li>当类上和方法上都添加了<code>@RequestMapping</code>注解，前端发送请求的时候，要和两个注解的value值相加匹配才能访问到。</li>
<li>@RequestMapping注解value属性前面加不加<code>/</code>都可以</li>
</ul>
<h3 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h3><ul>
<li>Get请求</li>
<li>Post请求</li>
</ul>
<p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220812162630.png"></p>
<p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220812162724.png"></p>
<p><em>Post请求中文乱码处理</em></p>
<ul>
<li>为web容器添加过滤器并指定字符集，Spring-web包中提供了专用的字符过滤器</li>
</ul>
<p>解决方法：配置过滤器</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123;
    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;
        return new Class[0];
    &#125;

    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;
        return new Class[]&#123;SpringMvcConfig.class&#125;;
    &#125;

    protected String[] getServletMappings() &#123;
        return new String[]&#123;&quot;&#x2F;&quot;&#125;;
    &#125;

    &#x2F;&#x2F;乱码处理
    @Override
    protected Filter[] getServletFilters() &#123;
        CharacterEncodingFilter filter &#x3D; new CharacterEncodingFilter();
        filter.setEncoding(&quot;UTF-8&quot;);
        return new Filter[]&#123;filter&#125;;
    &#125;
&#125;</code></pre>

<hr>
<p>发送请求与参数:</p>
<pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;localhost&#x2F;commonParamDifferentName?name&#x3D;张三&amp;age&#x3D;18</code></pre>

<p>后台接收参数:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(&quot;&#x2F;commonParamDifferentName&quot;)
@ResponseBody
public String commonParamDifferentName(String userName , int age)&#123;
    System.out.println(&quot;普通参数传递 userName &#x3D;&#x3D;&gt; &quot;+userName);
    System.out.println(&quot;普通参数传递 age &#x3D;&#x3D;&gt; &quot;+age);
    return &quot;&#123;&#39;module&#39;:&#39;common param different name&#39;&#125;&quot;;
&#125;</code></pre>

<p>因为前端给的是<code>name</code>,后台接收使用的是<code>userName</code>,两个名称对不上，导致接收数据失败:</p>
<p>解决方案:使用@RequestParam注解</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(&quot;&#x2F;commonParamDifferentName&quot;)
    @ResponseBody
    public String commonParamDifferentName(@RequestPaam(&quot;name&quot;) String userName , int age)&#123;
        System.out.println(&quot;普通参数传递 userName &#x3D;&#x3D;&gt; &quot;+userName);
        System.out.println(&quot;普通参数传递 age &#x3D;&#x3D;&gt; &quot;+age);
        return &quot;&#123;&#39;module&#39;:&#39;common param different name&#39;&#125;&quot;;
    &#125;</code></pre>

<p><strong>用集合接收前台参数也需要@RequestParam注解</strong></p>
<hr>
<h3 id="日期类型参数传递"><a href="#日期类型参数传递" class="headerlink" title="日期类型参数传递"></a>日期类型参数传递</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220813105417.png"></p>
<h3 id="类型转换器"><a href="#类型转换器" class="headerlink" title="类型转换器"></a>类型转换器</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220813105817.png"></p>
<h3 id="json数据"><a href="#json数据" class="headerlink" title="json数据"></a>json数据</h3><h4 id="接受请求中json数据"><a href="#接受请求中json数据" class="headerlink" title="接受请求中json数据"></a>接受请求中json数据</h4><p>1.添加json数据转换相关坐标</p>
<pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;&#x2F;artifactId&gt;
    &lt;version&gt;2.9.0&lt;&#x2F;version&gt;
&lt;&#x2F;dependency&gt;</code></pre>

<p>2.设置发送json数据(请求body中添加json数据)</p>
<p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220813101224.png"></p>
<p>3.开启自动转换json数据的支持</p>
<p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220813101309.png"></p>
<p>4.设置接收json数据</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;使用@RequestBody注解将外部传递的json数组数据映射到形参的集合对象中作为数据
    @RequestMapping(&quot;&#x2F;listParamForJson&quot;)
    @ResponseBody
    public String listParamForJson(@RequestBody List&lt;String&gt; likes)&#123;
        System.out.println(&quot;list common(json)参数传递 list &#x3D;&#x3D;&gt; &quot;+likes);
        return &quot;&#123;&#39;module&#39;:&#39;list common for json param&#39;&#125;&quot;;
    &#125;</code></pre>

<p><strong>@RequestBody一个处理器方法只能使用一次</strong></p>
<hr>
<p>@RequestBody与@RequestParam区别</p>
<ul>
<li>区别<ul>
<li>@RequestParam用于接收url地址传参，表单传参</li>
<li>@RequestBody用于接收json数据</li>
</ul>
</li>
<li>应用<ul>
<li>后期开发中，发送json格式数据为主，@RequestBody应用较广</li>
<li>如果发送非json格式数据，选用@RequestParam接收请求参数</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>@ResponseBody</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>&#x3D;&#x3D;方法\类注解&#x3D;&#x3D;</td>
</tr>
<tr>
<td>位置</td>
<td>SpringMVC控制器方法定义上方和控制类上</td>
</tr>
<tr>
<td>作用</td>
<td>设置当前控制器返回值作为响应体,<br/>写在类上，该类的所有方法都有该注解功能</td>
</tr>
<tr>
<td>相关属性</td>
<td>pattern：指定日期时间格式字符串</td>
</tr>
</tbody></table>
<p><strong>说明:</strong></p>
<ul>
<li>该注解可以写在类上或者方法上</li>
<li>写在类上就是该类下的所有方法都有@ReponseBody功能</li>
<li>当方法上有@ReponseBody注解后<ul>
<li>方法的返回值为字符串，会将其作为文本内容直接响应给前端</li>
<li>方法的返回值为对象，会将对象转换成JSON响应给前端</li>
</ul>
</li>
</ul>
<p>此处又使用到了类型转换，内部还是通过Converter接口的实现类完成的，所以Converter除了前面所说的功能外，它还可以实现:</p>
<ul>
<li>对象转Json数据(POJO -&gt; json)</li>
<li>集合转Json数据(Collection -&gt; json)</li>
</ul>
<h2 id="Rest"><a href="#Rest" class="headerlink" title="Rest"></a>Rest</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>REST（Representational State Transfer），表现形式状态转换</li>
</ul>
<p>当我们想表示一个网络资源的时候，可以使用两种方式:</p>
<ul>
<li>传统风格资源描述形式<ul>
<li><code>http://localhost/user/getById?id=1</code> 查询id为1的用户信息</li>
<li><code>http://localhost/user/saveUser</code> 保存用户信息</li>
</ul>
</li>
<li>REST风格描述形式<ul>
<li><code>http://localhost/user/1</code> </li>
<li><code>http://localhost/user</code></li>
</ul>
</li>
</ul>
<ul>
<li>优点：<ul>
<li>隐藏资源的访问行为，无法通过地址得知对资源是何种操作</li>
<li>书写简化</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>按照REST风格访问资源时使用&#x3D;&#x3D;行为动作&#x3D;&#x3D;区分对资源进行了何种操作<ul>
<li><code>http://localhost/users</code>	查询全部用户信息 GET（查询）</li>
<li><code>http://localhost/users/1</code>  查询指定用户信息 GET（查询）</li>
<li><code>http://localhost/users</code>    添加用户信息    POST（新增&#x2F;保存）</li>
<li><code>http://localhost/users</code>    修改用户信息    PUT（修改&#x2F;更新）</li>
<li><code>http://localhost/users/1</code>  删除用户信息    DELETE（删除）</li>
</ul>
</li>
<li>根据REST风格对资源进行访问称为RESTful</li>
</ul>
<p>请求的方式比较多，但是比较常用的就4种，分别是<code>GET</code>,<code>POST</code>,<code>PUT</code>,<code>DELETE</code>。</p>
<p>按照不同的请求方式代表不同的操作类型。</p>
<ul>
<li>发送GET请求是用来做查询</li>
<li>发送POST请求是用来做新增</li>
<li>发送PUT请求是用来做修改</li>
<li>发送DELETE请求是用来做删除</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">注意事项：
上述行为是约定方式，约定不是规范，可以打破，所以称REST风格，而不是REST规范
描述模块的名字通常使用负数，也就是可以加s的格式描述，表示此类资源，而非单个资源，例如：users、books、account......</code></pre>

<h3 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220814093052.png"></p>
<p>(2)如果有多个参数需要传递该如何编写?</p>
<p>前端发送请求的时候使用:<code>http://localhost/users/1/tom</code>,路径中的<code>1</code>和<code>tom</code>就是我们想要传递的两个参数。</p>
<p>后端获取参数，需要做如下修改:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controller
public class UserController &#123;
    &#x2F;&#x2F;设置当前请求方法为DELETE，表示REST风格中的删除操作
	@RequestMapping(value &#x3D; &quot;&#x2F;users&#x2F;&#123;id&#125;&#x2F;&#123;name&#125;&quot;,method &#x3D; RequestMethod.DELETE)
    @ResponseBody
    public String delete(@PathVariable Integer id,@PathVariable String name) &#123;
        System.out.println(&quot;user delete...&quot; + id+&quot;,&quot;+name);
        return &quot;&#123;&#39;module&#39;:&#39;user delete&#39;&#125;&quot;;
    &#125;
&#125;</code></pre>

<hr>
<p>关于接收参数，我们学过三个注解<code>@RequestBody</code>、<code>@RequestParam</code>、<code>@PathVariable</code>,这三个注解之间的区别和应用分别是什么?</p>
<ul>
<li>区别<ul>
<li>@RequestParam用于接收url地址传参或表单传参</li>
<li>@RequestBody用于接收json数据</li>
<li>@PathVariable用于接收路径参数，使用{参数名称}描述路径参数</li>
</ul>
</li>
<li>应用<ul>
<li>后期开发中，发送请求参数超过1个时，以json格式为主，@RequestBody应用较广</li>
<li>如果发送非json格式数据，选用@RequestParam接收请求参数</li>
<li>采用RESTful进行开发，当参数数量较少时，例如1个，可以采用@PathVariable接收请求路径变量，通常用于传递id值</li>
</ul>
</li>
</ul>
<h3 id="RESTful快速开发"><a href="#RESTful快速开发" class="headerlink" title="RESTful快速开发"></a>RESTful快速开发</h3><p>问题1：每个方法的@RequestMapping注解中都定义了访问路径&#x2F;books，重复性太高。</p>
<p>问题2：每个方法的@RequestMapping注解中都要使用method属性定义请求方式，重复性太高。</p>
<p>问题3：每个方法响应json都需要加上@ResponseBody注解，重复性太高。</p>
<p><em>对于刚才的问题，我们都有对应的解决方案：</em></p>
<p>问题1：每个方法的@RequestMapping注解中都定义了访问路径&#x2F;books，重复性太高。</p>
<pre class="line-numbers language-none"><code class="language-none">将@RequestMapping提到类上面，用来定义所有方法共同的访问路径。</code></pre>

<p>问题2：每个方法的@RequestMapping注解中都要使用method属性定义请求方式，重复性太高。</p>
<pre class="line-numbers language-none"><code class="language-none">使用@GetMapping  @PostMapping  @PutMapping  @DeleteMapping代替</code></pre>

<p>问题3：每个方法响应json都需要加上@ResponseBody注解，重复性太高。</p>
<pre class="line-numbers language-none"><code class="language-none">1.将ResponseBody提到类上面，让所有的方法都有@ResponseBody的功能
2.使用@RestController注解替换@Controller与@ResponseBody注解，简化书写</code></pre>

<h4 id="知识点1：-RestController"><a href="#知识点1：-RestController" class="headerlink" title="知识点1：@RestController"></a>知识点1：@RestController</h4><table>
<thead>
<tr>
<th>名称</th>
<th>@RestController</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>&#x3D;&#x3D;类注解&#x3D;&#x3D;</td>
</tr>
<tr>
<td>位置</td>
<td>基于SpringMVC的RESTful开发控制器类定义上方</td>
</tr>
<tr>
<td>作用</td>
<td>设置当前控制器类为RESTful风格，<br/>等同于@Controller与@ResponseBody两个注解组合功能</td>
</tr>
</tbody></table>
<h4 id="知识点2：-GetMapping-PostMapping-PutMapping-DeleteMapping"><a href="#知识点2：-GetMapping-PostMapping-PutMapping-DeleteMapping" class="headerlink" title="知识点2：@GetMapping @PostMapping @PutMapping @DeleteMapping"></a>知识点2：@GetMapping @PostMapping @PutMapping @DeleteMapping</h4><table>
<thead>
<tr>
<th>名称</th>
<th>@GetMapping @PostMapping @PutMapping @DeleteMapping</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>&#x3D;&#x3D;方法注解&#x3D;&#x3D;</td>
</tr>
<tr>
<td>位置</td>
<td>基于SpringMVC的RESTful开发控制器方法定义上方</td>
</tr>
<tr>
<td>作用</td>
<td>设置当前控制器方法请求访问路径与请求动作，每种对应一个请求动作，<br/>例如@GetMapping对应GET请求</td>
</tr>
<tr>
<td>相关属性</td>
<td>value（默认）：请求访问路径</td>
</tr>
</tbody></table>
<h3 id="案例：基于RESTful页面数据交互"><a href="#案例：基于RESTful页面数据交互" class="headerlink" title="案例：基于RESTful页面数据交互"></a>案例：基于RESTful页面数据交互</h3><h5 id="编写Controller类并使用RESTful进行配置"><a href="#编写Controller类并使用RESTful进行配置" class="headerlink" title="编写Controller类并使用RESTful进行配置"></a>编写Controller类并使用RESTful进行配置</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController
@RequestMapping(&quot;&#x2F;books&quot;)
public class BookController &#123;

    @PostMapping
    public String save(@RequestBody Book book)&#123;
        System.out.println(&quot;book save &#x3D;&#x3D;&gt; &quot;+ book);
        return &quot;&#123;&#39;module&#39;:&#39;book save success&#39;&#125;&quot;;
    &#125;

 	@GetMapping
    public List&lt;Book&gt; getAll()&#123;
        System.out.println(&quot;book getAll is running ...&quot;);
        List&lt;Book&gt; bookList &#x3D; new ArrayList&lt;Book&gt;();

        Book book1 &#x3D; new Book();
        book1.setType(&quot;计算机&quot;);
        book1.setName(&quot;SpringMVC入门教程&quot;);
        book1.setDescription(&quot;小试牛刀&quot;);
        bookList.add(book1);

        Book book2 &#x3D; new Book();
        book2.setType(&quot;计算机&quot;);
        book2.setName(&quot;SpringMVC实战教程&quot;);
        book2.setDescription(&quot;一代宗师&quot;);
        bookList.add(book2);


        return bookList;
    &#125;

&#125;</code></pre>

<ul>
<li>SpringMVC需要将静态资源进行放行。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration
public class SpringMvcSupport extends WebMvcConfigurationSupport &#123;
    &#x2F;&#x2F;设置静态资源访问过滤，当前类需要设置为配置类，并被扫描加载
    @Override
    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;
        &#x2F;&#x2F;当访问&#x2F;pages&#x2F;????时候，从&#x2F;pages目录下查找内容
        registry.addResourceHandler(&quot;&#x2F;pages&#x2F;**&quot;).addResourceLocations(&quot;&#x2F;pages&#x2F;&quot;);
        registry.addResourceHandler(&quot;&#x2F;js&#x2F;**&quot;).addResourceLocations(&quot;&#x2F;js&#x2F;&quot;);
        registry.addResourceHandler(&quot;&#x2F;css&#x2F;**&quot;).addResourceLocations(&quot;&#x2F;css&#x2F;&quot;);
        registry.addResourceHandler(&quot;&#x2F;plugins&#x2F;**&quot;).addResourceLocations(&quot;&#x2F;plugins&#x2F;&quot;);
    &#125;
&#125;
</code></pre>

<ul>
<li>该配置类是在config目录下，SpringMVC扫描的是controller包，所以该配置类还未生效，要想生效需要将SpringMvcConfig配置类进行修改</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration
@ComponentScan(&#123;&quot;com.itheima.controller&quot;,&quot;com.itheima.config&quot;&#125;)
@EnableWebMvc
public class SpringMvcConfig &#123;
&#125;

或者

@Configuration
@ComponentScan(&quot;com.itheima&quot;)
@EnableWebMvc
public class SpringMvcConfig &#123;
&#125;</code></pre>

<h3 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合</h3><p>1.创建工程</p>
<p>2.SSM整合</p>
<ul>
<li><p>Spring</p>
<ul>
<li>SpringConfig</li>
</ul>
</li>
<li><p>MyBatis</p>
<ul>
<li><p>MybatisConfig</p>
</li>
<li><p>JdbcConfig</p>
</li>
<li><p>jdbc.properties</p>
</li>
</ul>
</li>
<li><p>SpringMVC</p>
<ul>
<li>ServletConfig</li>
<li>SpirngMvcConfig</li>
</ul>
</li>
</ul>
<p>3.功能模块</p>
<ul>
<li>表与实现类</li>
<li>dao(接口+自动代理)</li>
<li>service(接口+实现类)<ul>
<li>业务层接口测试(整合JUnit)</li>
</ul>
</li>
<li>controller<ul>
<li>表现层接口测试(PostMan)</li>
</ul>
</li>
</ul>
<hr>
<p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220814173947.png"></p>
<p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220814174014.png"></p>
<p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220814174046.png"></p>
<h4 id="异常处理器"><a href="#异常处理器" class="headerlink" title="异常处理器"></a>异常处理器</h4><ul>
<li><p>出现异常现象的常见位置与常见诱因如下：</p>
<ul>
<li>框架内部抛出的异常：因使用不合规导致</li>
<li>数据层抛出的异常：因外部服务器故障导致（例如：服务器访问超时）</li>
<li>业务层抛出的异常：因业务逻辑书写失败导致（例如：遍历业务书写操作，导致索引异常等）</li>
<li>表现层抛出的异常：因数据收集、校验等规则导致（例如：不匹配的数据类型间导致异常）</li>
<li>工具类抛出的异常：因工具类书写不严谨不够健壮导致（例如：必要释放的连接长期未释放导致等）</li>
</ul>
</li>
<li><p><strong>所有异常均抛出到表现层处理</strong></p>
</li>
<li><p>对于上面这些问题及解决方案，SpringMVC已经为我们提供了一套解决方案:</p>
<ul>
<li><p>对于上面这些问题及解决方案，SpringMVC已经为我们提供了一套解决方案:</p>
<ul>
<li><strong>异常处理器:</strong><ul>
<li>集中的、统一的处理项目中出现的异常。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestControllerAdvice
public class ProjectExceptionAdvice &#123;
    @ExceptionHandler(Exception.class)
    public void doException(Exception ex)&#123;
        System.out.println(&quot;出现异常了&quot;);
    &#125;
&#125;</code></pre></li>
</ul>
</li>
</ul>
<p>知识点1：@RestControllerAdvice</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>@RestControllerAdvice</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>&#x3D;&#x3D;类注解&#x3D;&#x3D;</td>
</tr>
<tr>
<td>位置</td>
<td>Rest风格开发的控制器增强类定义上方</td>
</tr>
<tr>
<td>作用</td>
<td>为Rest风格开发的控制器类做增强</td>
</tr>
</tbody></table>
<p>**说明:**此注解自带@ResponseBody注解与@Component注解，具备对应的功能</p>
<hr>
<p>知识点2：@ExceptionHandler</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>@ExceptionHandler</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>&#x3D;&#x3D;方法注解&#x3D;&#x3D;</td>
</tr>
<tr>
<td>位置</td>
<td>专用于异常处理的控制器方法上方</td>
</tr>
<tr>
<td>作用</td>
<td>设置指定异常的处理方案，功能等同于控制器方法，<br/>出现异常后终止原始控制器执行,并转入当前方法执行</td>
</tr>
</tbody></table>
<p><strong>说明：</strong>此类方法可以根据处理的异常不同，制作多个方法分别处理对应的异常</p>
<h4 id="项目异常分类及处理"><a href="#项目异常分类及处理" class="headerlink" title="项目异常分类及处理"></a>项目异常分类及处理</h4><p><strong>项目异常分类</strong></p>
<ul>
<li><p>业务异常（BusinessException）</p>
<ul>
<li><p>规范的用户行为产生的异常</p>
<ul>
<li>用户在页面输入内容的时候未按照指定格式进行数据填写，如在年龄框输入的是字符串</li>
</ul>
</li>
<li><p>不规范的用户行为操作产生的异常</p>
<ul>
<li>如用户故意传递错误数据</li>
</ul>
</li>
</ul>
</li>
<li><p>系统异常（SystemException）</p>
<ul>
<li>项目运行过程中可预计但无法避免的异常<ul>
<li>比如数据库或服务器宕机</li>
</ul>
</li>
</ul>
</li>
<li><p>其他异常（Exception）</p>
<ul>
<li>编程人员未预期到的异常，如:用到的文件不存在</li>
</ul>
</li>
</ul>
<p><strong>处理方案</strong></p>
<ul>
<li>业务异常（BusinessException）<ul>
<li>发送对应消息传递给用户，提醒规范操作<ul>
<li>大家常见的就是提示用户名已存在或密码格式不正确等</li>
</ul>
</li>
</ul>
</li>
<li>系统异常（SystemException）<ul>
<li>发送固定消息传递给用户，安抚用户<ul>
<li>系统繁忙，请稍后再试</li>
<li>系统正在维护升级，请稍后再试</li>
<li>系统出问题，请联系系统管理员等</li>
</ul>
</li>
<li>发送特定消息给运维人员，提醒维护<ul>
<li>可以发送短信、邮箱或者是公司内部通信软件</li>
</ul>
</li>
<li>记录日志<ul>
<li>发消息和记录日志对用户来说是不可见的，属于后台程序</li>
</ul>
</li>
</ul>
</li>
<li>其他异常（Exception）<ul>
<li>发送固定消息传递给用户，安抚用户</li>
<li>发送特定消息给编程人员，提醒维护（纳入预期范围内）<ul>
<li>一般是程序没有考虑全，比如未做非空校验等</li>
</ul>
</li>
<li>记录日志</li>
</ul>
</li>
</ul>
<h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><ul>
<li>拦截器是一种动态拦截方法调用的机制，在SpirngMVC中动态拦截控制器方法的执行</li>
<li>作用：<ul>
<li>在指定的方法调用前后执行预先设定的代码</li>
<li>阻止原始方法的执行</li>
</ul>
</li>
</ul>
<h4 id="拦截器和过滤器区别"><a href="#拦截器和过滤器区别" class="headerlink" title="拦截器和过滤器区别"></a>拦截器和过滤器区别</h4><ul>
<li>归属不同：Filter输入Servlet技术，Interceptor呼入SpringMVC技术</li>
<li>拦截内容不同：Filter对所有访问进行增强，Interceptor仅针对SpringMVC的访问进行增强</li>
</ul>
<h4 id="拦截器入门案例"><a href="#拦截器入门案例" class="headerlink" title="拦截器入门案例"></a>拦截器入门案例</h4><ol>
<li><p>创建拦截器类</p>
<p>让类实现HandlerInterceptor接口，重写接口中的三个方法</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Component
&#x2F;&#x2F;定义拦截器类，实现HandlerInterceptor接口
&#x2F;&#x2F;注意当前类必须受Spring容器控制
public class ProjectInterceptor implements HandlerInterceptor &#123;
    @Override
    &#x2F;&#x2F;原始方法调用前执行的内容
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        System.out.println(&quot;preHandle...&quot;);
        return true;
    &#125;

    @Override
    &#x2F;&#x2F;原始方法调用后执行的内容
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;
        System.out.println(&quot;postHandle...&quot;);
    &#125;

    @Override
    &#x2F;&#x2F;原始方法调用完成后执行的内容
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;
        System.out.println(&quot;afterCompletion...&quot;);
    &#125;
&#125;</code></pre>
</li>
<li><p>配置拦截器类</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration
public class SpringMvcSupport extends WebMvcConfigurationSupport &#123;
    @Autowired
    private ProjectInterceptor projectInterceptor;

    @Override
    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;
        registry.addResourceHandler(&quot;&#x2F;pages&#x2F;**&quot;).addResourceLocations(&quot;&#x2F;pages&#x2F;&quot;);
    &#125;

    @Override
    protected void addInterceptors(InterceptorRegistry registry) &#123;
        &#x2F;&#x2F;配置拦截器
        registry.addInterceptor(projectInterceptor).addPathPatterns(&quot;&#x2F;books&quot; );
    &#125;
&#125;</code></pre>
</li>
<li><p>SpringMVC添加SpringMvcSupport包扫描</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration
@ComponentScan(&#123;&quot;com.itheima.controller&quot;,&quot;com.itheima.config&quot;&#125;)
@EnableWebMvc
public class SpringMvcConfig&#123;
   
&#125;</code></pre></li>
</ol>
<p><strong>简化SpringMvcSupport的编写</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration
@ComponentScan(&#123;&quot;com.itheima.controller&quot;&#125;)
@EnableWebMvc
&#x2F;&#x2F;实现WebMvcConfigurer接口可以简化开发，但具有一定的侵入性
public class SpringMvcConfig implements WebMvcConfigurer &#123;
    @Autowired
    private ProjectInterceptor projectInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) &#123;
        &#x2F;&#x2F;配置多拦截器
        registry.addInterceptor(projectInterceptor).addPathPatterns(&quot;&#x2F;books&quot;,&quot;&#x2F;books&#x2F;*&quot;);
    &#125;
&#125;</code></pre>



<p><strong>拦截器中的<code>preHandler</code>方法，如果返回true,则代表放行，会执行原始Controller类中要请求的方法，如果返回false，则代表拦截，后面的就不会再执行了。</strong></p>
<p>当有拦截器后，请求会先进入preHandle方法，</p>
<p>​	如果方法返回true，则放行继续执行后面的handle[controller的方法]和后面的方法</p>
<p>​	如果返回false，则直接跳过后面方法的执行。</p>
<h4 id="多拦截器执行顺序"><a href="#多拦截器执行顺序" class="headerlink" title="多拦截器执行顺序"></a>多拦截器执行顺序</h4><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220922125322.png"></p>

        </div>

        

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/post/JVM.html"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">JVM</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.html"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">计算机组成原理</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Keep Team</a>
        </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>








<div class="post-scripts">
    
</div>



</body>
</html>
