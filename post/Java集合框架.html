<!DOCTYPE html>
<html lang="en">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  
  
  <title>Java集合框架 | Hexo</title>
  <meta name="author" content="GLK" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="" />
  
  <meta name="description" content="HashMap方法1：put方法：put(key，value)，我们经常用存储一些常用的数据，比如flag、百分比之类的，我们就可以返回map结构，如果key相同则值会覆盖，允许key和value为null。 2：get方法：get(key)，主要用来取map中存储的数据，我们根据其key值，可以取到对应的value值，没有该key对应的值则返回null。  3：remove方法：remove(k">
<meta property="og:type" content="article">
<meta property="og:title" content="Java集合框架">
<meta property="og:url" content="https://2295237514.github.io/post/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="HashMap方法1：put方法：put(key，value)，我们经常用存储一些常用的数据，比如flag、百分比之类的，我们就可以返回map结构，如果key相同则值会覆盖，允许key和value为null。 2：get方法：get(key)，主要用来取map中存储的数据，我们根据其key值，可以取到对应的value值，没有该key对应的值则返回null。  3：remove方法：remove(k">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/2295237514/image/main/20230213224322.png">
<meta property="og:image" content="https://raw.githubusercontent.com/2295237514/image/main/20230213224456.png">
<meta property="og:image" content="https://raw.githubusercontent.com/2295237514/image/main/20230213224716.png">
<meta property="og:image" content="https://raw.githubusercontent.com/2295237514/image/main/20230213224914.png">
<meta property="og:image" content="https://raw.githubusercontent.com/2295237514/image/main/20221120165256.png">
<meta property="article:published_time" content="2022-11-20T08:41:47.000Z">
<meta property="article:modified_time" content="2023-02-28T07:22:44.918Z">
<meta property="article:author" content="GLK">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/2295237514/image/main/20230213224322.png">
  <link rel="alternate" href="atom.xml" type="application/atom+xml">
  <!-- 站点验证相关 -->
  
    
    
    
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" media="all"></script>
  
    <link rel="stylesheet" id="darkmode-css" href="/css/kr-color-dark.min.css" media="(prefers-color-scheme: dark)"></script>
    <script src="/js/kr-dark.min.js"></script>
  
  
  <link rel="stylesheet" id="fontawe-css" href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" media="all"></script>
  <link rel="stylesheet" id="nprogress-css" href="/vendors/nprogress@0.2.0/nprogress.css" media="all"></script>
  
  
    <link rel="stylesheet" href="/vendors/aplayer@1.10.1/dist/APlayer.min.css"></script>
  
  
    <link rel="stylesheet" href="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"></script>
  
  <!-- 不得不预先加载的一些JS文件 -->
  <script src="/vendors/jquery@3.6.0/dist/jquery.min.js"></script>
  
    <script src="/vendors/qrcode_js@1.0.0/qrcode.min.js"></script>
  
  
  <style>
    
    
  </style>
  
<meta name="generator" content="Hexo 6.1.0"></head>


    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <header id="kratos-desktop-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="nav-header">
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    
                                    
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
            <header id="kratos-mobile-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="color-logo"><a href="/">Hexo</a></div>
                    <div class="nav-toggle">
                        <a class="kratos-nav-toggle js-kratos-nav-toggle">
                            <i></i>
                        </a>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>Hexo</h2> <br />
                        <span></span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">
                    

        

            <section class="col-md-8">

        

            <article itemscope itemtype="https://schema.org/Article">
    
    <link itemprop="mainEntityOfPage" href="https://2295237514.github.io/post/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6.html">
    <div class="kratos-hentry kratos-post-inner clearfix">
        <header class="kratos-entry-header">
            
                <h1 class="kratos-entry-title text-center" itemprop="name headline">Java集合框架</h1>
            
            
            <ul class="kratos-post-meta text-center">
                <li><time datetime="2022-11-20T08:41:47.000Z" itemprop="datePublished"><i class="fa fa-calendar"></i> 2022-11-20</time></li>
                <li itemprop="author" itemscope itemtype="https://schema.org/Person">
                    <i class="fa fa-user"></i> 作者 <span itemprop="name">GLK</span>
                </li>
                <li>
                    <i class="fa fa-edit"></i> 
                    
                    
                        ~16.01K
                    
                    字
                </li>
                
            </ul>
        </header>
        <div class="kratos-post-content">
            
            <div id="expire-alert" class="alert alert-warning hidden" role="alert">
                <div class="icon"><i class="fa fa-warning"></i></div>
                <div class="text"><p>本文最后编辑于 <time datetime="1677568964918"></time> 前，其中的内容可能需要更新。</p></div>
            </div>
            
            
            
            <hr />
            <div itemprop="articleBody"><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>1：put方法：put(key，value)，我们经常用存储一些常用的数据，比如flag、百分比之类的，我们就可以返回map结构，如果key相同则值会覆盖，允许key和value为null。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">2：get方法：get(key)，主要用来取map中存储的数据，我们根据其key值，可以取到对应的value值，没有该key对应的值则返回null。

3：remove方法：remove(key)，主要用来删除map中对应的key及其value值。

4：clear方法，用法：clear()，会清空map中的数据。

5：containsKey(key)，判断map集合中是否包含某个key。

6：containsValue(value)，判断map集合中是否包含某个value。

7：entrySet()：hashmap.entrySet().iterator()，entrySet()的效率比keySet()要高。key和value存储在entry对象里面，遍历的时候，拿到entry对象就可以取到value了。

8：keySet()：hashmap.keySet().iterator()，keySet是把key放到一个set集合中，通过迭代器遍历，再用hashmap.get(key)来取到value的值。</code></pre>
<p>9：Map.getOrDefault(key，默认值)；</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">map.put(curr.val, map.getOrDefault(curr.val, 0) + 1);
&#x2F;&#x2F;Map中会存储一一对应的key和value。
&#x2F;&#x2F;如果 在Map中存在key，则返回key所对应的的value。
&#x2F;&#x2F;如果 在Map中不存在key，则返回默认值。</code></pre>



<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>HashMap基于哈希表的Map接口实现，是以key-value存储形式存在，即主要用来存放键值对。HashMap的实现不是同步的，这意味着他不是线程安全的，它的key、value都可以为null，此外，HashMap中的映射不是有序的。</p>
<ol>
<li><p>JDK 1.8之前是由数组+链表组成的。数组是HashMap的主体，链表则是主要为了解决哈希冲突**(两个对象调用的hashCode方法计算的哈希码值一致导致计算的数组索引值相同)**而存在的(‘拉链法解决hash冲突’)</p>
</li>
<li><p>JDK1.8 以后，<strong>当链表长度大于阈值（或者红黑树的边界值，默认为 8）并且当前数组的长度大于64时，此时此索引位置上的所有数据改为使用红黑树存储。</strong></p>
</li>
</ol>
<p>补充：将链表转换成红黑树前会判断，即使阈值大于8，但是数组长度小于64，此时并不会将链表变为红黑树。而是选择进行数组扩容。</p>
<p>这样做的目的是因为数组比较小，尽量避开红黑树结构，这种情况下变为红黑树结构，反而会降低效率，因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡 。同时数组长度小于64时，搜索时间相对要快些。所以综上所述为了提高性能和减少搜索时间，底层在阈值大于8并且数组长度大于64时，链表才转换为红黑树。具体可以参考 <code>treeifyBin</code>方法。</p>
<p>当然虽然增了红黑树作为底层数据结构，结构变得复杂了，但是阈值大于8并且数组长度大于64时，链表转换为红黑树时，效率也变的更高效。</p>
<h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><p>1.存取无序的</p>
<p>2.键和值位置都可以是null，但是键位置只能是一个null</p>
<p>3.键位置是唯一的，底层的数据结构控制键的</p>
<p>4.jdk1.8前数据结构是：链表 + 数组  jdk1.8之后是 ： 链表 + 数组  + 红黑树</p>
<p>5.阈值(边界值) &gt; 8 并且数组长度大于64，才将链表转换为红黑树，变为红黑树的目的是为了高效的查询。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20230213224322.png"></p>
<p>说明：</p>
<p>1.面试题：HashMap中hash函数是怎么实现的？还有哪些hash函数的实现方式？</p>
<pre class="line-numbers language-none"><code class="language-none">对于key的hashCode做hash操作，无符号右移16位然后做异或运算。
还有平方取中法，伪随机数法和取余数法。这三种效率都比较低。而无符号右移16位异或运算效率是最高的。至于底层是如何计算的我们下面看源码时给大家讲解。</code></pre>

<p>2.面试题：当两个对象的hashCode相等时会怎么样？</p>
<pre class="line-numbers language-none"><code class="language-none">会产生哈希碰撞，若key值内容相同则替换旧的value.不然连接到链表后面，链表长度超过阈值8就转换为红黑树存储。</code></pre>

<p>3.面试题：何时发生哈希碰撞和什么是哈希碰撞,如何解决哈希碰撞？</p>
<pre class="line-numbers language-none"><code class="language-none">只要两个元素的key计算的哈希码值相同就会发生哈希碰撞。jdk8前使用链表解决哈希碰撞。jdk8之后使用链表+红黑树解决哈希碰撞。</code></pre>

<p>4.面试题：如果两个键的hashcode相同，如何存储键值对？</p>
<pre class="line-numbers language-none"><code class="language-none">hashcode相同，通过equals比较内容是否相同。
相同：则新的value覆盖之前的value
不相同：则将新的键值对添加到哈希表中</code></pre>

<p>5.在不断的添加数据的过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。</p>
<p>6.通过上述描述，当位于一个链表中的元素较多，即hash值相等但是内容不相等的元素较多时，通过key值依次查找的效率较低。而<strong>JDK1.8</strong>中，哈希表存储采用数组+链表+红黑树实现，当链表长度(阀值)超过 8 时且当前数组的长度 &gt; 64时，将链表转换为红黑树，这样大大减少了查找时间。jdk8在哈希表中引入红黑树的原因只是为了查找效率更高。</p>
<p>简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的。如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/2295237514/image/main/20230213224456.png"></p>
<p> <strong>但是这样的话问题来了，传统hashMap的缺点，1.8为什么引入红黑树？这样结构的话不是更麻烦了吗，为何阈值大于8换成红黑树？</strong></p>
<p> JDK 1.8 以前 HashMap 的实现是 数组+链表，即使哈希函数取得再好，也很难达到元素百分百均匀分布。当 HashMap 中有大量的元素都存放到同一个桶中时，这个桶下有一条长长的链表，这个时候 HashMap 就相当于一个单链表，假如单链表有 n 个元素，遍历的时间复杂度就是 O(n)，完全失去了它的优势。针对这种情况，JDK 1.8 中引入了 红黑树（查找时间复杂度为 O(logn)）来优化这个问题。 当链表长度很小的时候，即使遍历，速度也非常快，但是当链表长度不断变长，肯定会对查询性能有一定的影响，所以才需要转成树。</p>
<p>至于为什么阈值是8，我想，去源码中找寻答案应该是最可靠的途径。 下面我们在分析源码的时候会介绍。</p>
<p><strong>jdk8存储过程:</strong></p>
<p><img src="https://raw.githubusercontent.com/2295237514/image/main/20230213224716.png"></p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20230213224914.png"></p>
<p>说明：</p>
<ul>
<li>Cloneable 空接口，表示可以克隆。 创建并返回HashMap对象的一个副本。</li>
<li>Serializable 序列化接口。属于标记性接口。HashMap对象可以被序列化和反序列化。 </li>
<li>AbstractMap 父类提供了Map实现接口。以最大限度地减少实现此接口所需的工作。</li>
</ul>
<p>补充：通过上述继承关系我们发现一个很奇怪的现象， 就是HashMap已经继承了AbstractMap而AbstractMap类实现了Map接口，那为什么HashMap还要在实现Map接口呢？同样在ArrayList中LinkedList中都是这种结构。 </p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">据 java 集合框架的创始人Josh Bloch描述，这样的写法是一个失误。在java集合框架中，类似这样的写法很多，最开始写java集合框架的时候，他认为这样写，在某些地方可能是有价值的，直到他意识到错了。显然的，JDK的维护者，后来不认为这个小小的失误值得去修改，所以就这样存在下来了。</code></pre>

<h2 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h2><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>1.序列化版本号</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">private static final long serialVersionUID &#x3D; 362498820763181265L;</code></pre>

<p>2.集合的初始化容量( <strong>必须是二的n次幂</strong> )</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;默认的初始容量是16 -- 1&lt;&lt;4相当于1*2的4次方---1*16
static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4;   </code></pre>

<p>问题： <strong>为什么必须是2的n次幂？如果输入值不是2的幂比如10会怎么样？</strong> </p>
<p>HashMap构造方法还可以指定集合的初始化容量大小：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">HashMap(int initialCapacity) 构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap。</code></pre>

<p> 根据上述讲解我们已经知道，当向HashMap中添加一个元素的时候，需要根据key的hash值，去确定其在数组中的具体位置。 HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现就在把数据存到哪个链表中的算法。</p>
<p>这个算法实际就是取模，hash%length，计算机中直接求余效率不如位移运算(这点上述已经讲解)。所以源码中做了优化,使用 hash&amp;(length-1)，而实际上hash%length等于hash&amp;(length-1)的前提是length是2的n次幂。</p>
<p>为什么这样能均匀分布减少碰撞呢？2的n次方实际就是1后面n个0，2的n次方-1  实际就是n个1；</p>
<p>小结：</p>
<p>​	1.由上面可以看出，当我们根据key的hash确定其在数组的位置时，如果n为2的幂次方，可以保证数据的均匀插入，如果n不是2的幂次方，可能数组的一些位置永远不会插入数据，浪费数组的空间，加大hash冲突。</p>
<p>​    2.另一方面，一般我们可能会想通过 % 求余来确定位置，这样也可以，只不过性能不如 &amp; 运算。而且当n是2的幂次方时：hash &amp; (length - 1) &#x3D;&#x3D; hash % length</p>
<p>​	3.因此，HashMap 容量为2次幂的原因，就是为了数据的的均匀分布，减少hash冲突，毕竟hash冲突越大，代表数组中一个链的长度越大，这样的话会降低hashmap的性能</p>
<p>​	<strong>4.如果创建HashMap对象时，输入的数组长度是10，不是2的幂，HashMap通过一通位移运算和或运算得到的肯定是2的幂次数，并且是离那个数最近的数字。</strong></p>
<p>源代码如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;创建HashMap集合的对象，指定数组长度是10，不是2的幂
HashMap hashMap &#x3D; new HashMap(10);
public HashMap(int initialCapacity) &#123;&#x2F;&#x2F;initialCapacity&#x3D;10
   this(initialCapacity, DEFAULT_LOAD_FACTOR);
 &#125;
public HashMap(int initialCapacity, float loadFactor) &#123;&#x2F;&#x2F;initialCapacity&#x3D;10
     if (initialCapacity &lt; 0)
            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                               initialCapacity);
        if (initialCapacity &gt; MAXIMUM_CAPACITY)
            initialCapacity &#x3D; MAXIMUM_CAPACITY;
        if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                               loadFactor);
    this.loadFactor &#x3D; loadFactor;
    this.threshold &#x3D; tableSizeFor(initialCapacity);&#x2F;&#x2F;initialCapacity&#x3D;10
&#125;
  &#x2F;**
   * Returns a power of two size for the given target capacity.
  *&#x2F;
    static final int tableSizeFor(int cap) &#123;&#x2F;&#x2F;int cap &#x3D; 10
        int n &#x3D; cap - 1;
        n |&#x3D; n &gt;&gt;&gt; 1;
        n |&#x3D; n &gt;&gt;&gt; 2;
        n |&#x3D; n &gt;&gt;&gt; 4;
        n |&#x3D; n &gt;&gt;&gt; 8;
        n |&#x3D; n &gt;&gt;&gt; 16;
        return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    &#125;</code></pre>



<ol>
<li>默认的负载因子，默认值是0.75</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</code></pre>

<ol start="2">
<li>当链表的值超过8则会转红黑树(<strong>1.8新增</strong>)</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;当桶(bucket)上的结点数大于这个值时会转成红黑树
static final int TREEIFY_THRESHOLD &#x3D; 8;</code></pre>

<p>因为树节点的大小大约是普通节点的两倍，所以我们只在箱子包含足够的节点时才使用树节点(参见TREEIFY_THRESHOLD)。当它们变得太小(由于删除或调整大小)时，就会被转换回普通的桶。在使用分布良好的用户hashcode时，很少使用树箱。理想情况下，在随机哈希码下，箱子中节点的频率服从<strong>泊松分布</strong></p>
<p>因为树节点的大小大约是普通节点的两倍，所以我们只在箱子包含足够的节点时才使用树节点(参见TREEIFY_THRESHOLD)。当它们变得太小(由于删除或调整大小)时，就会被转换回普通的桶。在使用分布良好的用户hashcode时，很少使用树箱。理想情况下，在随机哈希码下，箱子中节点的频率服从泊松分布</p>
<p><strong>红黑树的平均查找长度是log(n)，如果长度为8，平均查找长度为log(8)&#x3D;3，链表的平均查找长度为n&#x2F;2，当长度为8时，平均查找长度为8&#x2F;2&#x3D;4，这才有转换成树的必要；链表长度如果是小于等于6，6&#x2F;2&#x3D;3，而log(6)&#x3D;2.6，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。</strong></p>
<ol start="3">
<li>集合最大容量</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;集合最大容量的上限是：2的30次幂
static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;</code></pre>

<p>原因：</p>
<p>1 int类型是32位整型，占4个字节。</p>
<p>2 Java的原始类型里没有无符号类型。 –&gt; 所以首位是符号位 正数为0，负数为1</p>
<p>3 java中存放的是补码，1左移31位的为 16进制的0x80000000代表的是-2147483648–&gt;所以最大只能是30</p>
<p><strong>1 &lt;&lt; 30 &#x3D; 1073741824</strong><br><strong>1 &lt;&lt; 31 &#x3D; -2147483648</strong><br>1 &lt;&lt; 32 &#x3D; 1<br>1 &lt;&lt; 33 &#x3D; 2<br>1 &lt;&lt; -1 &#x3D; -2147483648</p>
<hr>
<ol start="4">
<li><strong>当链表的值小于6则会从红黑树转回链表</strong></li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;当桶(bucket)上的结点数小于这个值时树转链表
static final int UNTREEIFY_THRESHOLD &#x3D; 6;</code></pre>

<ol start="5">
<li><strong>当Map里面的数量超过这个值时，表中的桶才能进行树形化 ，否则桶内元素太多时会扩容，而不是树形化 为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD (8)</strong></li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;桶中结构转化为红黑树对应的数组长度最小的值 
static final int MIN_TREEIFY_CAPACITY &#x3D; 64;</code></pre>

<ol start="6">
<li><strong>table用来初始化(必须是二的n次幂)(重点)</strong></li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;存储元素的数组 
transient Node&lt;K,V&gt;[] table;</code></pre>

<p><strong>table</strong>在JDK1.8中我们了解到HashMap是由数组加链表加红黑树来组成的结构其中table就是HashMap中的数组，jdk8之前数组类型是Entry&lt;K,V&gt;类型。从jdk1.8之后是Node&lt;K,V&gt;类型。只是换了个名字，都实现了一样的接口：Map.Entry&lt;K,V&gt;。负责存储键值对数据的。</p>
<ol start="7">
<li>用来存放缓存</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;存放具体元素的集合
transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</code></pre>

<ol start="8">
<li><strong>HashMap中存放元素的个数(重点)</strong></li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;存放元素的个数，注意这个不等于数组的长度。
 transient int size;</code></pre>

<p><strong>size</strong>为HashMap中K-V的实时数量，不是数组table的长度。</p>
<ol start="9">
<li>用来记录HashMap的修改次数</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 每次扩容和更改map结构的计数器
 transient int modCount;  </code></pre>

<ol start="10">
<li>用来调整大小下一个容量的值计算方式为(容量*负载因子)</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 临界值 当实际大小(容量*负载因子)超过临界值时，会进行扩容
int threshold;</code></pre>

<ol start="11">
<li><strong>哈希表的加载因子(重点)</strong></li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 加载因子
final float loadFactor;</code></pre>

<p><strong>说明：</strong></p>
<p>1.<strong>loadFactor</strong>加载因子，是用来衡量 HashMap 满的程度，<strong>表示HashMap的疏密程度，影响hash操作到同一个数组位置的概率</strong>，计算HashMap的实时加载因子的方法为：size&#x2F;capacity，而不是占用桶的数量去除以capacity。capacity 是桶的数量，也就是 table 的长度length。</p>
<p><strong>loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值</strong>。</p>
<p><strong>当HashMap里面容纳的元素已经达到HashMap数组长度的75%时，表示HashMap太挤了，需要扩容，而扩容这个过程涉及到 rehash、复制数据等操作，非常消耗性能。，所以开发中尽量减少扩容的次数，可以通过创建HashMap集合对象时指定初始容量来尽量避免。</strong></p>
<p><strong>同时在HashMap的构造器中可以定制loadFactor。</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">构造方法：
HashMap(int initialCapacity, float loadFactor) 构造一个带指定初始容量和加载因子的空 HashMap。</code></pre>



<p>2.为什么加载因子设置为0.75,初始化临界值是12？</p>
<p>loadFactor越趋近于1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。</p>
<hr>
<ul>
<li><strong>threshold</strong>计算公式：capacity(数组长度默认16) * loadFactor(负载因子默认0.75)。这个值是当前已占用数组长度的最大值。<strong>当Size&gt;&#x3D;threshold</strong>的时候，那么就要考虑对数组的resize(扩容)，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。 扩容后的 HashMap 容量是之前容量的两倍.</li>
</ul>
<h2 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HashMapStudy &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F;一般来说,最好初始化一下, 小于12的就不要初始化了
        &#x2F;&#x2F; 默认的就是16,因为加载因子是0.75,也就是到16*0.75&#x3D;12的时候会扩容
        Map&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;(3);

        map.put(&quot;welcome&quot;,&quot;to&quot;);
        map.put(&quot;java&quot;,&quot;study&quot;);
        map.put(&quot;wechat&quot;,&quot;best396975802&quot;);

        &#x2F;&#x2F;遍历方法1: 先遍历key , 再取出value
        System.out.println(&quot;遍历方法1: 先遍历key , 再取出value&quot;);
        for (String key : map.keySet()) &#123;
            System.out.println(&quot;key is &quot;+key);
            System.out.println(&quot;value is &quot;+ map.get(key));
        &#125;
        &#x2F;&#x2F;遍历方法2: 直接遍历value
        System.out.println(&quot;遍历方法2: 直接遍历value&quot;);
        for (String value : map.values()) &#123;
            System.out.println(&quot;value is &quot;+value);
        &#125;

        &#x2F;&#x2F;遍历方法3: 通过遍历entry来取Key和value,推荐的方法!!!
        System.out.println(&quot;遍历方法3: 通过遍历entry来取Key和value,推荐的方法!!!&quot;);
        for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;
            System.out.println(&quot;key is &quot;+entry.getKey());
            System.out.println(&quot;value is &quot;+ entry.getValue());
        &#125;

        &#x2F;&#x2F;遍历方法4: 通过forEach方法直接遍历key和value
        System.out.println(&quot;遍历方法4: 通过forEach方法直接遍历&quot;);
        map.forEach((key,value)-&gt;&#123;
            System.out.println(&quot;key is &quot;+ key);
            System.out.println(&quot;value is &quot;+ value);
        &#125;);
    &#125;
&#125;</code></pre>

<h2 id="容量的初始化"><a href="#容量的初始化" class="headerlink" title="容量的初始化"></a>容量的初始化</h2><p>把默认容量的数字设置成  initialCapacity&#x2F; 0.75F + 1.0F</p>
<h1 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h1><ul>
<li><strong>概念</strong>：对象的容器，定义了对多个对象进项操作的的常用方法。可实现数组的功能。</li>
<li><strong>和数组的区别</strong>：</li>
</ul>
<ol>
<li>数组长度固定，集合长度不固定。</li>
<li>数组可以存储基本类型和引用类型，集合只能存储引用类型。</li>
</ol>
<ul>
<li><strong>位置</strong>： java.util.*;</li>
</ul>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20221120165256.png"></p>
<h3 id="Collection父接口"><a href="#Collection父接口" class="headerlink" title="Collection父接口"></a>Collection父接口</h3><ul>
<li><p>特点：代表一组任意类型的对象，无序，无下标，不能重复。</p>
</li>
<li><p>方法：</p>
<ul>
<li><code>boolean add(Object obj) //添加一个对象。</code></li>
<li><code>boolean addAll(Collection c) //讲一个集合中的所有对象添加到此集合中。</code></li>
<li><code>void clear() //清空此集合中的所有对象。</code></li>
<li><code>boolean contains(Object o) //检查此集合中是否包含o对象。</code></li>
<li><code>boolean equals(Object o) //比较此集合是否与指定对象相等。</code></li>
<li><code>boolean isEmpty() //判断此集合是否为空。</code></li>
<li><code>boolean remove(Object o) //在此集合中移除o对象。</code></li>
<li><code>int size() //返回此集合中的元素个数。</code></li>
<li><code>Object[] toArray() //姜此集合转换成数组。</code></li>
</ul>
</li>
</ul>
<h3 id="Collection子接口"><a href="#Collection子接口" class="headerlink" title="Collection子接口"></a>Collection子接口</h3><h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><p><strong>增加：</strong><br>add(E e)：在链表后添加一个元素；   通用方法<br>addFirst(E e)：在链表头部插入一个元素；  特有方法<br>addLast(E e)：在链表尾部添加一个元素；  特有方法<br>push(E e)：与addFirst方法一致<br>offer(E e)：在链表尾部插入一个元素<br>add(int index, E element)：在指定位置插入一个元素。<br>offerFirst(E e)：JDK1.6版本之后，在头部添加； 特有方法<br>offerLast(E e)：JDK1.6版本之后，在尾部添加； 特有方法</p>
<p><strong>删除：</strong><br>remove() ：移除链表中第一个元素;    通用方法<br>remove(E e)：移除指定元素；   通用方法<br>removeFirst(E e)：删除头，获取元素并删除；  特有方法<br>removeLast(E e)：删除尾；  特有方法<br>pollFirst()：删除头；  特有方法<br>pollLast()：删除尾；  特有方法<br>pop()：和removeFirst方法一致，删除头。<br>poll()：查询并移除第一个元素     特有方法    </p>
<p><strong>查：</strong><br>get(int index)：按照下标获取元素；  通用方法<br>getFirst()：获取第一个元素；  特有方法<br>getLast()：获取最后一个元素； 特有方法<br>peek()：获取第一个元素，但是不移除；  特有方法<br>peekFirst()：获取第一个元素，但是不移除；<br>peekLast()：获取最后一个元素，但是不移除；<br>pollFirst()：查询并删除头；  特有方法<br>pollLast()：删除尾；  特有方法<br>poll()：查询并移除第一个元素     特有方法</p>
<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><p>1、add(Object element) 方法<br>2、size()  方法<br>3、get(int  index)   方法<br>4、add(int index, Object element)  方法<br>5、set(int i, Object element) 方法<br>6、clear() 方法<br>7、isEmpty() 方法<br>8、iterator()  方法<br>9、contains(Object o)  方法<br>10、remove(int  index)  方法<br>11、remove(Object o)  方法</p>
<h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p>add	增加一个元索	如果队列已满，则抛出一个IIIegaISlabEepeplian异常<br>remove	移除并返回队列头部的元素	如果队列为空，则抛出一个NoSuchElementException异常<br>element	返回队列头部的元素	如果队列为空，则抛出一个NoSuchElementException异常<br>offer	添加一个元素并返回true	如果队列已满，则返回false<br>poll	移除并返问队列头部的元素	如果队列为空，则返回null<br>peek	返回队列头部的元素	如果队列为空，则返回null<br>put	添加一个元素	如果队列满，则阻塞<br>take	移除并返回队列头部的元素	如果队列为空，则阻塞</p>
<h1 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h1><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 最小堆完整代码
import java.util.PriorityQueue;
public class App &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 创建一个最小堆实例
        PriorityQueue&lt;Integer&gt; minHeap &#x3D; new PriorityQueue&lt;&gt;();
       
        &#x2F;&#x2F; 创建一个空的最大堆
		&#x2F;&#x2F;PriorityQueue&lt;Integer&gt; maxHeap &#x3D; new PriorityQueue&lt;&gt;(Collections.reverseOrder());

		&#x2F;&#x2F; 创建带初始值的「堆」， 或者称为「堆化」操作，此时的「堆」为「最小堆」
		&#x2F;&#x2F;PriorityQueue&lt;Integer&gt; heapWithValues&#x3D; new PriorityQueue&lt;&gt;(Arrays.asList(3,1,2));
        
        
        &#x2F;&#x2F; 分别往最小堆中添加3，1，2
        minHeap.add(3);
        minHeap.add(1);
        minHeap.add(2);
        &#x2F;&#x2F; 查看最小堆的所有元素，结果为：[1, 3, 2]
        System.out.println(&quot;minHeap: &quot;+minHeap.toString());
        &#x2F;&#x2F; 获取最小堆的堆顶元素
        int peekNum &#x3D; minHeap.peek();
        &#x2F;&#x2F; 结果为：1
        System.out.println(&quot;peek number: &quot;+peekNum);
        &#x2F;&#x2F; 删除最小堆的堆顶元素
        int pollNum &#x3D; minHeap.poll();
        &#x2F;&#x2F; 结果为：1
        System.out.println(&quot;poll number: &quot;+pollNum);
        &#x2F;&#x2F; 查看删除1后最小堆的堆顶元素，结果为：2
        System.out.println(&quot;peek number: &quot;+minHeap.peek());
        &#x2F;&#x2F; 查看新的最小堆的所有元素，结果为：[2,3]
        System.out.println(&quot;minHeap: &quot;+minHeap.toString());
        &#x2F;&#x2F; 查看最小堆的元素个数，也是最小堆的长度
        int heapSize &#x3D; minHeap.size();
        &#x2F;&#x2F; 结果为：2
        System.out.println(&quot;minHeap size: &quot;+heapSize);
        &#x2F;&#x2F; 判断最小堆是否还有元素
        boolean isEmpty &#x3D; minHeap.isEmpty();
        &#x2F;&#x2F; 结果为： false
        
        System.out.println(&quot;isEmpty: &quot;+isEmpty);
    &#125;
&#125;</code></pre>

<h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1><pre class="line-numbers language-none"><code class="language-none">public class Main &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 1. 初始化哈希集合
        Set&lt;Integer&gt; hashSet &#x3D; new HashSet&lt;&gt;();     
        &#x2F;&#x2F; 2. 新增键
        hashSet.add(3);
        hashSet.add(2);
        hashSet.add(1);
        &#x2F;&#x2F; 3. 删除键
        hashSet.remove(2);        
        &#x2F;&#x2F; 4. 查询键是否包含在哈希集合中
        if (!hashSet.contains(2)) &#123;
            System.out.println(&quot;键 2 不在哈希集合中&quot;);
        &#125;
        &#x2F;&#x2F; 5. 哈希集合的大小
        System.out.println(&quot;哈希集合的大小为: &quot; + hashSet.size());     
        &#x2F;&#x2F; 6. 遍历哈希集合
        for (Integer i : hashSet) &#123;
            System.out.print(i + &quot; &quot;);
        &#125;
        System.out.println(&quot;在哈希集合中&quot;);
        &#x2F;&#x2F; 7. 清空哈希集合
        hashSet.clear();
        &#x2F;&#x2F; 8. 查看哈希集合是否为空
        if (hashSet.isEmpty()) &#123;
            System.out.println(&quot;哈希集合为空！&quot;);
        &#125;
    &#125;
&#125;

public class Main &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 1. 初始化哈希表
        Map&lt;Integer, Integer&gt; hashmap &#x3D; new HashMap&lt;&gt;();
        &#x2F;&#x2F; 2. 插入一个新的（键，值）对
        hashmap.putIfAbsent(0, 0);
        hashmap.putIfAbsent(2, 3);
        &#x2F;&#x2F; 3. 插入一个新的（键，值）对，或者更新值
        hashmap.put(1, 1);
        hashmap.put(1, 2);
        &#x2F;&#x2F; 4. 获得特定键对应的值
        System.out.println(&quot;键 1 对应的值为: &quot; + hashmap.get(1));
        &#x2F;&#x2F; 5. 删除键
        hashmap.remove(2);
        &#x2F;&#x2F; 6. 检查键是否存在于哈希表中
        if (!hashmap.containsKey(2)) &#123;
            System.out.println(&quot;键 2 不在哈希表中&quot;);
        &#125;
        &#x2F;&#x2F; 7. 哈希表的大小
        System.out.println(&quot;哈希表的大小为: &quot; + hashmap.size()); 
        &#x2F;&#x2F; 8. 遍历哈希表
        for (Map.Entry&lt;Integer, Integer&gt; entry : hashmap.entrySet()) &#123;
            System.out.print(&quot;(&quot; + entry.getKey() + &quot;,&quot; + entry.getValue() + &quot;) &quot;);
        &#125;
        System.out.println(&quot;在哈希表中&quot;);
        &#x2F;&#x2F; 9. 清空哈希表
        hashmap.clear();
        &#x2F;&#x2F; 10. 检查哈希表是否为空
        if (hashmap.isEmpty()) &#123;
            System.out.println(&quot;哈希表为空！&quot;);
        &#125;
    &#125;
&#125;</code></pre>

</div>
        </div>
        
            <div class="kratos-copyright text-center clearfix">
                <h5 itemprop="copyrightNotice">本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</h5>
            </div>
        
        <footer class="kratos-entry-footer clearfix">
            
                <div class="post-like-donate text-center clearfix" id="post-like-donate">
                
                
                    <a class="share" href="javascript:;"><i class="fa fa-share-alt"></i> 分享</a>
                    <div class="share-wrap" style="display: none;">
    <div class="share-group">
        <a href="javascript:;" class="share-plain qq" onclick="share('qq');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-qq"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain qzone" onclick="share('qzone');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-star"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weixin pop style-plain" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weixin"></i>
            </div>
            <div class="share-int">
                <div class="qrcode" id="wechat-qr"></div>
                <p>打开微信“扫一扫”，打开网页后点击屏幕右上角分享按钮</p>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weibo" onclick="share('weibo');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weibo"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain facebook style-plain" onclick="share('facebook');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-facebook"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain twitter style-plain" onclick="share('twitter');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-twitter"></i>
            </div>
        </a>
    </div>
    <script type="text/javascript">
        $(()=>{
            new QRCode("wechat-qr", {
                text: "https://2295237514.github.io/post/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6.html",
                width: 150,
                height: 150,
                correctLevel : QRCode.CorrectLevel.H
            });
        });
        function share(dest) {
            const qqBase        = "https://connect.qq.com/widget/shareqq/index.html?";
            const weiboBase     = "https://service.weibo.com/share/share.php?";
            const qzoneBase     = "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?";
            const facebookBase  = "https://www.facebook.com/sharer/sharer.php?";
            const twitterBase   = "https://twitter.com/intent/tweet?";
            const hostUrl       = "https://2295237514.github.io/post/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6.html";
            const title         = "「Java集合框架」";
            const excerpt       = `HashMap方法1：put方法：put(key，value)，我们经常用存储一些常用的数据，比如flag、百分比之类的，我们就可以返回map结构，如果key相同则值会覆盖，允许key和value为null。
2：get方法：get(...`;
            let _URL;
            switch (dest) {
                case "qq"       : _URL = qqBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";     break;
                case "weibo"    : _URL = weiboBase+"url="+hostUrl+"&title="+title+excerpt;                                 break;
                case "qzone"    : _URL = qzoneBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";  break;
                case "facebook" : _URL = facebookBase+"u="+hostUrl;                                                        break;
                case "twitter"  : _URL = twitterBase+"text="+title+excerpt+"&url="+hostUrl;                                break;
            }
            window.open(_URL);
        };
    </script>
</div>
                
                </div>
            
            <div class="footer-tag clearfix">
                <div class="pull-left">
                <i class="fa fa-tags"></i>
                    
                </div>
                <div class="pull-date">
                    <time datetime="2023-02-28T07:22:44.918Z" itemprop="dateModified">最后编辑：2023-02-28</time>
                </div>
            </div>
        </footer>
    </div>
    
        <nav class="navigation post-navigation clearfix" role="navigation">
            
            <div class="nav-previous clearfix">
                <a title=" 面试精选问题" target="_blank" rel="noopener" href="//post/面试精选问题.html">&lt; 上一篇</a>
            </div>
            
            
            <div class="nav-next clearfix">
                <a title=" Redis入门" target="_blank" rel="noopener" href="//post/Redis入门.html">下一篇 &gt;</a>
            </div>
            
        </nav>
    
    
</article>

        

            </section>

        

                
            

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="/images/avatar.webp" loading="lazy" decoding="auto" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center"></p>
    </div>
    <div class="site-meta">
        <a class="meta-item" href="/archives/">
            <span class="title">
                文章
            </span>
            <span class="count">
                17
            </span>
        </a>
        <a class="meta-item" href="/categories/">
            <span class="title">
                分类
            </span>
            <span class="count">
                0
            </span>
        </a>
        <a class="meta-item" href="/tags/">
            <span class="title">
                标签
            </span>
            <span class="count">
                4
            </span>
        </a>
    </div>
</aside>
            
                    <div class="sticky-area">
                
                

            
                
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4>
      <div class="tag-clouds">
        <a href="/tags/JavaWeb/" style="font-size: 0.6em;">JavaWeb</a> <a href="/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 0.6em;">java基础知识</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 0.6em;">前端</a> <a href="/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 0.8em;">算法与数据结构</a>
      </div>
  </aside>

            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/post/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Spring.html"><i class="fa  fa-book"></i> 深入学习Spring</a>
            
          
        
          
          
            <a class="list-group-item" href="/post/Mysql%E8%BF%9B%E9%98%B6%E7%AF%87.html"><i class="fa  fa-book"></i> Mysql进阶篇</a>
            
          
        
          
          
            <a class="list-group-item" href="/post/Redis%E5%85%A5%E9%97%A8.html"><i class="fa  fa-book"></i> Redis入门</a>
            
          
        
          
          
            <a class="list-group-item" href="/post/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6.html"><i class="fa  fa-book"></i> Java集合框架</a>
            
          
        
          
          
            <a class="list-group-item" href="/post/%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89%E9%97%AE%E9%A2%98.html"><i class="fa  fa-book"></i> 面试精选问题</a>
            
          
        
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
      </ul>
  </div>
  </aside>

            
    </div>
</section>
        
        </div>
    </div>
</div>
<footer>
    <div id="footer"  class="ap-lrc"  >
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        <!-- Keep for compatibility -->
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <!-- New links -->
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2023 Hexo 版权所有.</li>
                            <li>本站已运行<span id="span_dt">Loading...</span></li>
                        </div>
                        <div>
                            <li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li>
                            <li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by GLK.</li>
                        </div>
                        <div>
                            <li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li>
                            <li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li>
                        </div>
                        <div>
                            
                            
                        </div>
                    </ul>
                </div>
            </div>
        </div>
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search/">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                
                    <div class="box theme-box" id="darkmode-switch">
                        <span class="fa fa-adjust"></span>
                    </div>
                
                
                
            </div>
            <div class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
    </div>
</footer>
</div>
</div>

        <script defer src="/vendors/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>
<script defer src="/vendors/nprogress@0.2.0/nprogress.js"></script>
<script>
    if (!window.kr) {
        window.kr = {};
    }
    window.kr.notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));
    window.kr.siteRoot = "/";
</script>


    <script async src="/js/candy.min.js"></script>



    <script defer src="/vendors/aplayer@1.10.1/dist/APlayer.min.js"></script>
    
    <script defer src="/vendors/meting@2.0.1/dist/Meting.min.js"></script>
    <meting-js
        server="netease"
        type="playlist"
        id="3204190542"
        order="random"
        fixed="true"
    >
    </meting-js>



    <script defer src="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script defer src="/js/kratosr.min.js"></script>
<script defer src="/js/pjax.min.js"></script>



<!-- Extra support for third-party plguins  -->


    </body>
</html>