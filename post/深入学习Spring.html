<!DOCTYPE html>
<html lang="en">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  
  
  <title>深入学习Spring | Hexo</title>
  <meta name="author" content="GLK" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="" />
  
  <meta name="description" content="Spring是什么？Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。 Spring的优点通过控制反转和依赖注入实现松耦合。 支持面向切面的编程，并且把应用业务逻辑和系统服务分开。 通过切面和模板减少样板式代码。 声明式事务的支持。可以从单调繁冗的事务管理代码中解脱出来，通过声明式方式灵活地进行事务的管理，提高开发效率和质量。 方便集成各种优秀框架。内部提供了对各种优秀框">
<meta property="og:type" content="article">
<meta property="og:title" content="深入学习Spring">
<meta property="og:url" content="https://2295237514.github.io/post/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Spring.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Spring是什么？Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。 Spring的优点通过控制反转和依赖注入实现松耦合。 支持面向切面的编程，并且把应用业务逻辑和系统服务分开。 通过切面和模板减少样板式代码。 声明式事务的支持。可以从单调繁冗的事务管理代码中解脱出来，通过声明式方式灵活地进行事务的管理，提高开发效率和质量。 方便集成各种优秀框架。内部提供了对各种优秀框">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/2295237514/image/main/20230328162714.png">
<meta property="og:image" content="https://raw.githubusercontent.com/2295237514/image/main/20230328163829.png">
<meta property="article:published_time" content="2023-03-24T02:01:28.000Z">
<meta property="article:modified_time" content="2023-03-28T09:07:43.676Z">
<meta property="article:author" content="GLK">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/2295237514/image/main/20230328162714.png">
  <link rel="alternate" href="atom.xml" type="application/atom+xml">
  <!-- 站点验证相关 -->
  
    
    
    
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" media="all"></script>
  
    <link rel="stylesheet" id="darkmode-css" href="/css/kr-color-dark.min.css" media="(prefers-color-scheme: dark)"></script>
    <script src="/js/kr-dark.min.js"></script>
  
  
  <link rel="stylesheet" id="fontawe-css" href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" media="all"></script>
  <link rel="stylesheet" id="nprogress-css" href="/vendors/nprogress@0.2.0/nprogress.css" media="all"></script>
  
  
    <link rel="stylesheet" href="/vendors/aplayer@1.10.1/dist/APlayer.min.css"></script>
  
  
    <link rel="stylesheet" href="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"></script>
  
  <!-- 不得不预先加载的一些JS文件 -->
  <script src="/vendors/jquery@3.6.0/dist/jquery.min.js"></script>
  
    <script src="/vendors/qrcode_js@1.0.0/qrcode.min.js"></script>
  
  
  <style>
    
    
  </style>
  
<meta name="generator" content="Hexo 6.1.0"></head>


    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <header id="kratos-desktop-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="nav-header">
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    
                                    
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
            <header id="kratos-mobile-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="color-logo"><a href="/">Hexo</a></div>
                    <div class="nav-toggle">
                        <a class="kratos-nav-toggle js-kratos-nav-toggle">
                            <i></i>
                        </a>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>Hexo</h2> <br />
                        <span></span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">
                    

        

            <section class="col-md-8">

        

            <article itemscope itemtype="https://schema.org/Article">
    
    <link itemprop="mainEntityOfPage" href="https://2295237514.github.io/post/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Spring.html">
    <div class="kratos-hentry kratos-post-inner clearfix">
        <header class="kratos-entry-header">
            
                <h1 class="kratos-entry-title text-center" itemprop="name headline">深入学习Spring</h1>
            
            
            <ul class="kratos-post-meta text-center">
                <li><time datetime="2023-03-24T02:01:28.000Z" itemprop="datePublished"><i class="fa fa-calendar"></i> 2023-03-24</time></li>
                <li itemprop="author" itemscope itemtype="https://schema.org/Person">
                    <i class="fa fa-user"></i> 作者 <span itemprop="name">GLK</span>
                </li>
                <li>
                    <i class="fa fa-edit"></i> 
                    
                    
                        ~29.14K
                    
                    字
                </li>
                
            </ul>
        </header>
        <div class="kratos-post-content">
            
            <div id="expire-alert" class="alert alert-warning hidden" role="alert">
                <div class="icon"><i class="fa fa-warning"></i></div>
                <div class="text"><p>本文最后编辑于 <time datetime="1679994463676"></time> 前，其中的内容可能需要更新。</p></div>
            </div>
            
            
            
            <hr />
            <div itemprop="articleBody"><p>Spring是什么？<br>Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。</p>
<p>Spring的优点<br>通过控制反转和依赖注入实现松耦合。</p>
<p>支持面向切面的编程，并且把应用业务逻辑和系统服务分开。</p>
<p>通过切面和模板减少样板式代码。</p>
<p>声明式事务的支持。可以从单调繁冗的事务管理代码中解脱出来，通过声明式方式灵活地进行事务的管理，提高开发效率和质量。</p>
<p>方便集成各种优秀框架。内部提供了对各种优秀框架的直接支持（如：Hessian、Quartz、MyBatis等）。</p>
<p>方便程序的测试。Spring支持Junit4，添加注解便可以测试Spring程序。</p>
<h1 id="Spring-设计模式"><a href="#Spring-设计模式" class="headerlink" title="Spring 设计模式"></a>Spring 设计模式</h1><p>1、简单工厂模式：BeanFactory就是简单工厂模式的体现，根据传入一个唯一标识来获得 Bean 对象。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Override
public Object getBean(String name) throws BeansException &#123;
   assertBeanFactoryActive();
   return getBeanFactory().getBean(name);
&#125;</code></pre>

<p>2、工厂方法模式：FactoryBean就是典型的工厂方法模式。spring在使用getBean()调用获得该bean时，会自动调用该bean的getObject()方法。每个 Bean 都会对应一个 FactoryBean，如 SqlSessionFactory 对应 SqlSessionFactoryBean。</p>
<p>3、单例模式：一个类仅有一个实例，提供一个访问它的全局访问点。Spring 创建 Bean 实例默认是单例的。</p>
<p>4、适配器模式：SpringMVC中的适配器HandlerAdatper。由于应用会有多个Controller实现，如果需要直接调用Controller方法，那么需要先判断是由哪一个Controller处理请求，然后调用相应的方法。当增加新的 Controller，需要修改原来的逻辑，违反了开闭原则（对修改关闭，对扩展开放）。</p>
<p>为此，Spring提供了一个适配器接口，每一种 Controller 对应一种 HandlerAdapter 实现类，当请求过来，SpringMVC会调用getHandler()获取相应的Controller，然后获取该Controller对应的 HandlerAdapter，最后调用HandlerAdapter的handle()方法处理请求，实际上调用的是Controller的handleRequest()。每次添加新的 Controller 时，只需要增加一个适配器类就可以，无需修改原有的逻辑。</p>
<p>常用的处理器适配器：SimpleControllerHandlerAdapter，HttpRequestHandlerAdapter，AnnotationMethodHandlerAdapter。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; Determine handler for the current request.
mappedHandler &#x3D; getHandler(processedRequest);

HandlerAdapter ha &#x3D; getHandlerAdapter(mappedHandler.getHandler());

&#x2F;&#x2F; Actually invoke the handler.
mv &#x3D; ha.handle(processedRequest, response, mappedHandler.getHandler());

public class HttpRequestHandlerAdapter implements HandlerAdapter &#123;

   @Override
   public boolean supports(Object handler) &#123;&#x2F;&#x2F;handler是被适配的对象，这里使用的是对象的适配器模式
       return (handler instanceof HttpRequestHandler);
   &#125;

   @Override
   @Nullable
   public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)
       throws Exception &#123;

       ((HttpRequestHandler) handler).handleRequest(request, response);
       return null;

   &#125;
&#125;</code></pre>

<p>5、代理模式：spring 的 aop 使用了动态代理，有两种方式JdkDynamicAopProxy和Cglib2AopProxy。</p>
<p>6、观察者模式：spring 中 observer 模式常用的地方是 listener 的实现，如ApplicationListener。</p>
<p>7、模板模式： Spring 中 jdbcTemplate、hibernateTemplate 等，就使用到了模板模式。</p>
<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h2 id="什么是AOP？"><a href="#什么是AOP？" class="headerlink" title="什么是AOP？"></a>什么是AOP？</h2><p>面向切面编程，作为面向对象的一种补充，将公共逻辑（事务管理、日志、缓存等）封装成切面，跟业务代码进行分离，可以减少系统的重复代码和降低模块之间的耦合度。切面就是那些与业务无关，但所有业务模块都会调用的公共逻辑。</p>
<h2 id="AOP有哪些实现方式？"><a href="#AOP有哪些实现方式？" class="headerlink" title="AOP有哪些实现方式？"></a>AOP有哪些实现方式？</h2><p>AOP有两种实现方式：静态代理和动态代理。</p>
<p>静态代理</p>
<p>静态代理：代理类在编译阶段生成，在编译阶段将通知织入Java字节码中，也称编译时增强。AspectJ使用的是静态代理。</p>
<p>缺点：代理对象需要与目标对象实现一样的接口，并且实现接口的方法，会有冗余代码。同时，一旦接口增加方法，目标对象与代理对象都要维护。</p>
<p>动态代理</p>
<p>动态代理：代理类在程序运行时创建，AOP框架不会去修改字节码，而是在内存中临时生成一个代理对象，在运行期间对业务方法进行增强，不会生成新类。</p>
<h2 id="Spring-AOP的实现原理"><a href="#Spring-AOP的实现原理" class="headerlink" title="Spring AOP的实现原理"></a>Spring AOP的实现原理</h2><p>Spring的AOP实现原理其实很简单，就是通过动态代理实现的。如果我们为Spring的某个bean配置了切面，那么Spring在创建这个bean的时候，实际上创建的是这个bean的一个代理对象，我们后续对bean中方法的调用，实际上调用的是代理类重写的代理方法。而Spring的AOP使用了两种动态代理，分别是JDK的动态代理，以及CGLib的动态代理。</p>
<p>JDK动态代理和CGLIB动态代理的区别？<br>Spring AOP中的动态代理主要有两种方式：JDK动态代理和CGLIB动态代理。</p>
<h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>如果目标类实现了接口，Spring AOP会选择使用JDK动态代理目标类。代理类根据目标类实现的接口动态生成，不需要自己编写，生成的动态代理类和目标类都实现相同的接口。JDK动态代理的核心是InvocationHandler接口和Proxy类。</p>
<p>缺点：目标类必须有实现的接口。如果某个类没有实现接口，那么这个类就不能用JDK动态代理。</p>
<h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3><p>通过继承实现。如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library）可以在运行时动态生成类的字节码，动态创建目标类的子类对象，在子类对象中增强目标类。</p>
<p>CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</p>
<p>优点：目标类不需要实现特定的接口，更加灵活。</p>
<p>什么时候采用哪种动态代理？</p>
<p>如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP</p>
<p>如果目标对象实现了接口，可以强制使用CGLIB实现AOP</p>
<p>如果目标对象没有实现了接口，必须采用CGLIB库</p>
<p>两者的区别：</p>
<p>jdk动态代理使用jdk中的类Proxy来创建代理对象，它使用反射技术来实现，不需要导入其他依赖。cglib需要引入相关依赖：asm.jar，它使用字节码增强技术来实现。</p>
<p>当目标类实现了接口的时候Spring Aop默认使用jdk动态代理方式来增强方法，没有实现接口的时候使用cglib动态代理方式增强方法。</p>
<p>Spring AOP相关术语<br>（1）切面（Aspect）：切面是通知和切点的结合。通知和切点共同定义了切面的全部内容。</p>
<p>（2）连接点（Join point）：指方法，在Spring AOP中，一个连接点总是代表一个方法的执行。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</p>
<p>（3）通知（Advice）：在AOP术语中，切面的工作被称为通知。</p>
<p>（4）切入点（Pointcut）：切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。</p>
<p>（5）引入（Introduction）：引入允许我们向现有类添加新方法或属性。</p>
<p>（6）目标对象（Target Object）： 被一个或者多个切面（aspect）所通知（advise）的对象。它通常是一个代理对象。</p>
<p>（7）织入（Weaving）：织入是把切面应用到目标对象并创建新的代理对象的过程。在目标对象的生命周期里有以下时间点可以进行织入：</p>
<p>编译期：切面在目标类编译时被织入。AspectJ的织入编译器是以这种方式织入切面的。</p>
<p>类加载期：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入就支持以这种方式织入切面。</p>
<p>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面。</p>
<p>Spring通知有哪些类型？<br>在AOP术语中，切面的工作被称为通知。通知实际上是程序运行时要通过Spring AOP框架来触发的代码段。</p>
<p>Spring切面可以应用5种类型的通知：</p>
<p><strong>前置通知（Before）：在目标方法被调用之前调用通知功能；</strong></p>
<p><strong>后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</strong></p>
<p><strong>返回通知（After-returning ）：在目标方法成功执行之后调用通知；</strong></p>
<p><strong>异常通知（After-throwing）：在目标方法抛出异常后调用通知；</strong></p>
<p><strong>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的逻辑。</strong></p>
<h2 id="什么是依赖注入？"><a href="#什么是依赖注入？" class="headerlink" title="什么是依赖注入？"></a>什么是依赖注入？</h2><p>在Spring创建对象的过程中，把对象依赖的属性注入到对象中。依赖注入主要有两种方式：构造器注入和属性注入。</p>
<h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><p>什么是IOC？<br>IOC：控制反转，由Spring容器管理bean的整个生命周期。通过反射实现对其他对象的控制，包括初始化、创建、销毁等，解放手动创建对象的过程，同时降低类之间的耦合度。</p>
<p>IOC的好处？<br>ioc的思想最核心的地方在于，资源不由使用资源者管理，而由不使用资源的第三方管理，这可以带来很多好处。第一，资源集中管理，实现资源的可配置和易管理。第二，降低了使用资源双方的依赖程度，也就是我们说的耦合度。</p>
<p>也就是说，甲方要达成某种目的不需要直接依赖乙方，它只需要达到的目的告诉第三方机构就可以了，比如甲方需要一双袜子，而乙方它卖一双袜子，它要把袜子卖出去，并不需要自己去直接找到一个卖家来完成袜子的卖出。它也只需要找第三方，告诉别人我要卖一双袜子。这下好了，甲乙双方进行交易活动，都不需要自己直接去找卖家，相当于程序内部开放接口，卖家由第三方作为参数传入。甲乙互相不依赖，而且只有在进行交易活动的时候，甲才和乙产生联系。反之亦然。这样做什么好处么呢，甲乙可以在对方不真实存在的情况下独立存在，而且保证不交易时候无联系，想交易的时候可以很容易的产生联系。甲乙交易活动不需要双方见面，避免了双方的互不信任造成交易失败的问题。因为交易由第三方来负责联系，而且甲乙都认为第三方可靠。那么交易就能很可靠很灵活的产生和进行了。</p>
<p>这就是ioc的核心思想。生活中这种例子比比皆是，支付宝在整个淘宝体系里就是庞大的ioc容器，交易双方之外的第三方，提供可靠性可依赖可灵活变更交易方的资源管理中心。另外人事代理也是，雇佣机构和个人之外的第三方。</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/23277575/answer/24259844">https://www.zhihu.com/question/23277575/answer/24259844</a></p>
<p>IOC容器初始化过程？<br>从XML中读取配置文件。</p>
<p>将bean标签解析成 BeanDefinition，如解析 property 元素， 并注入到 BeanDefinition 实例中。</p>
<p>将 BeanDefinition 注册到容器 BeanDefinitionMap 中。</p>
<p>BeanFactory 根据 BeanDefinition 的定义信息创建实例化和初始化 bean。</p>
<p>单例bean的初始化以及依赖注入一般都在容器初始化阶段进行，只有懒加载（lazy-init为true）的单例bean是在应用第一次调用getBean()时进行初始化和依赖注入。</p>
<p>&#x2F;&#x2F; AbstractApplicationContext<br>&#x2F;&#x2F; Instantiate all remaining (non-lazy-init) singletons.<br>finishBeanFactoryInitialization(beanFactory);</p>
<p>多例bean 在容器启动时不实例化，即使设置 lazy-init 为 false 也没用，只有调用了getBean()才进行实例化。</p>
<p>loadBeanDefinitions采用了模板模式，具体加载 BeanDefinition 的逻辑由各个子类完成。</p>
<p>Bean的生命周期</p>
<p><img src="https://raw.githubusercontent.com/2295237514/image/main/20230328162714.png"></p>
<p>1.调用bean的构造方法创建Bean</p>
<p>2.通过反射调用setter方法进行属性的依赖注入</p>
<p>3.如果Bean实现了BeanNameAware接口，Spring将调用setBeanName()，设置 Bean的name（xml文件中bean标签的id）</p>
<p>4.如果Bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()把bean factory设置给Bean</p>
<p>5.如果存在BeanPostProcessor，Spring将调用它们的postProcessBeforeInitialization（预初始化）方法，在Bean初始化前对其进行处理</p>
<p>6.如果Bean实现了InitializingBean接口，Spring将调用它的afterPropertiesSet方法，然后调用xml定义的 init-method 方法，两个方法作用类似，都是在初始化 bean 的时候执行</p>
<p>7.如果存在BeanPostProcessor，Spring将调用它们的postProcessAfterInitialization（后初始化）方法，在Bean初始化后对其进行处理</p>
<p>8.Bean初始化完成，供应用使用，这里分两种情况：</p>
<p>8.1 如果Bean为单例的话，那么容器会返回Bean给用户，并存入缓存池。如果Bean实现了DisposableBean接口，Spring将调用它的destory方法，然后调用在xml中定义的 destory-method方法，这两个方法作用类似，都是在Bean实例销毁前执行。</p>
<p>8.2 如果Bean是多例的话，容器将Bean返回给用户，剩下的生命周期由用户控制。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface BeanPostProcessor &#123;
	@Nullable
	default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;
 		return bean;
&#125;
@Nullable
default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;
	return bean;
	&#125;
&#125;
public interface InitializingBean &#123;
	void afterPropertiesSet() throws Exception;
&#125;</code></pre>

<p>BeanFactory和FactoryBean的区别？<br>BeanFactory：管理Bean的容器，Spring中生成的Bean都是由这个接口的实现来管理的。</p>
<p>FactoryBean：通常是用来创建比较复杂的bean，一般的bean 直接用xml配置即可，但如果一个bean的创建过程中涉及到很多其他的bean 和复杂的逻辑，直接用xml配置比较麻烦，这时可以考虑用FactoryBean，可以隐藏实例化复杂Bean的细节。</p>
<p>当配置文件中bean标签的class属性配置的实现类是FactoryBean时，通过 getBean()方法返回的不是FactoryBean本身，而是调用FactoryBean#getObject()方法所返回的对象，相当于FactoryBean#getObject()代理了getBean()方法。如果想得到FactoryBean必须使用 ‘&amp;’ + beanName 的方式获取。</p>
<p>Mybatis 提供了 SqlSessionFactoryBean，可以简化 SqlSessionFactory的配置：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SqlSessionFactoryBean implements FactoryBean&lt;SqlSessionFactory&gt;, InitializingBean, 			ApplicationListener&lt;ApplicationEvent&gt; &#123;
 	@Override
 	public void afterPropertiesSet() throws Exception &#123;
   		notNull(dataSource, &quot;Property &#39;dataSource&#39; is required&quot;);
   		notNull(sqlSessionFactoryBuilder, &quot;Property &#39;sqlSessionFactoryBuilder&#39; is required&quot;);
   		state((configuration &#x3D;&#x3D; null &amp;&amp; configLocation &#x3D;&#x3D; null) || !(configuration !&#x3D; null &amp;&amp; configLocation !&#x3D; null),&quot;Property &#39;configuration&#39; and &#39;configLocation&#39; can not specified with together&quot;);
   		this.sqlSessionFactory &#x3D; buildSqlSessionFactory();
 &#125;

 	protected SqlSessionFactory buildSqlSessionFactory() throws IOException &#123;
	&#x2F;&#x2F;复杂逻辑
 	&#125;

 	@Override
 	public SqlSessionFactory getObject() throws Exception &#123;
   			if (this.sqlSessionFactory &#x3D;&#x3D; null) &#123;
     		afterPropertiesSet();
   		&#125;
   		return this.sqlSessionFactory;
    &#125;
&#125;</code></pre>

<p>在 xml 配置 SqlSessionFactoryBean：</p>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;bean id&#x3D;&quot;tradeSqlSessionFactory&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
   &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;trade&quot; &#x2F;&gt;
   &lt;property name&#x3D;&quot;mapperLocations&quot; value&#x3D;&quot;classpath*:mapper&#x2F;trade&#x2F;*Mapper.xml&quot; &#x2F;&gt;
   &lt;property name&#x3D;&quot;configLocation&quot; value&#x3D;&quot;classpath:mybatis-config.xml&quot; &#x2F;&gt;
   &lt;property name&#x3D;&quot;typeAliasesPackage&quot; value&#x3D;&quot;com.bytebeats.mybatis3.domain.trade&quot; &#x2F;&gt;
&lt;&#x2F;bean&gt;</code></pre>

<p>Spring 将会在应用启动时创建 SqlSessionFactory，并使用 sqlSessionFactory 这个名字存储起来。</p>
<p>BeanFactory和ApplicationContext有什么区别？<br>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。</p>
<p>两者区别如下：</p>
<p>1、功能上的区别。BeanFactory是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。</p>
<p>ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能，如继承MessageSource、支持国际化、统一的资源文件访问方式、同时加载多个配置文件等功能。</p>
<p>2、加载方式的区别。BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</p>
<p>而ApplicationContext是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单例Bean，那么在需要的时候，不需要等待创建bean，因为它们已经创建好了。</p>
<p>相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p>
<p>3、创建方式的区别。BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。</p>
<p>4、注册方式的区别。BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</p>
<p>Bean注入容器有哪些方式？<br>1、@Configuration + @Bean</p>
<p>@Configuration用来声明一个配置类，然后使用 @Bean 注解，用于声明一个bean，将其加入到Spring容器中。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration
public class MyConfiguration &#123;
   	@Bean
   	public Person person() &#123;
       	Person person &#x3D; new Person();
       	person.setName(&quot;小明&quot;);
       	return person;
   	&#125;
&#125;</code></pre>



<p>2、通过包扫描特定注解的方式</p>
<p>@ComponentScan放置在我们的配置类上，然后可以指定一个路径，进行扫描带有特定注解的bean，然后加至容器中。</p>
<p>特定注解包括@Controller、@Service、@Repository、@Component</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Component
public class Person &#123;
   &#x2F;&#x2F;...
&#125;

@ComponentScan(basePackages &#x3D; &quot;com.dabin.test.*&quot;)
public class Demo1 &#123;
   public static void main(String[] args) &#123;
       AnnotationConfigApplicationContext applicationContext &#x3D; new AnnotationConfigApplicationContext(Demo1.class);
       Person bean &#x3D; applicationContext.getBean(Person.class);
       System.out.println(bean);
   &#125;
&#125;</code></pre>



<p>3、@Import注解导入</p>
<p>@Import注解平时开发用的不多，但是也是非常重要的，在进行Spring扩展时经常会用到，它经常搭配自定义注解进行使用，然后往容器中导入一个配置文件。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@ComponentScan &#x2F;*把用到的资源导入到当前容器中*&#x2F; @Import(&#123;Person.class&#125;) 
public class App &#123;     
	public static void main(String[] args) throws Exception &#123;
		ConfigurableApplicationContext context &#x3D; SpringApplication.run(App.class, args);
		System.out.println(context.getBean(Person.class));         
		context.close();     
	&#125; 
&#125;</code></pre>



<p>4、实现BeanDefinitionRegistryPostProcessor进行后置处理。</p>
<p>在Spring容器启动的时候会执行 BeanDefinitionRegistryPostProcessor 的 postProcessBeanDefinitionRegistry 方法，就是等beanDefinition加载完毕之后，对beanDefinition进行后置处理，可以在此进行调整IOC容器中的beanDefinition，从而干扰到后面进行初始化bean。</p>
<p>在下面的代码中，我们手动向beanDefinitionRegistry中注册了person的BeanDefinition。最终成功将person加入到applicationContext中。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Demo1 &#123;     
	public static void main(String[] args) &#123;         
		AnnotationConfigApplicationContext applicationContext &#x3D; new AnnotationConfigApplicationContext();           MyBeanDefinitionRegistryPostProcessor beanDefinitionRegistryPostProcessor &#x3D; new MyBeanDefinitionRegistryPostProcessor();
    	applicationContext.addBeanFactoryPostProcessor(beanDefinitionRegistryPostProcessor);
    	applicationContext.refresh();         Person bean &#x3D; applicationContext.getBean(Person.class); 
    	System.out.println(bean);     
    &#125; 
&#125;   
class MyBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor &#123;     
    @Override     
    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException &#123;           AbstractBeanDefinition beanDefinition &#x3D; BeanDefinitionBuilder.rootBeanDefinition(Person.class).getBeanDefinition();         
    	registry.registerBeanDefinition(&quot;person&quot;, beanDefinition);     
    &#125;         
    @Override     
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;&#125; 
&#125;</code></pre>



<p>5、使用FactoryBean接口</p>
<p>如下图代码，使用@Configuration + @Bean的方式将 PersonFactoryBean 加入到容器中，这里没有向容器中直接注入 Person，而是注入 PersonFactoryBean，然后从容器中拿Person这个类型的bean。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration public class Demo1 &#123;     
	@Bean     
	public PersonFactoryBean personFactoryBean() &#123;         
		return new PersonFactoryBean();     
	&#125;       
	public static void main(String[] args) &#123;         
	AnnotationConfigApplicationContext applicationContext &#x3D; new AnnotationConfigApplicationContext(Demo1.class);         
	Person bean &#x3D; applicationContext.getBean(Person.class);         
	System.out.println(bean);     
	&#125; 
&#125;   
class PersonFactoryBean implements FactoryBean&lt;Person&gt; &#123;     
    @Override     
    public Person getObject() throws Exception &#123;         
    	return new Person();     
    &#125;     
    @Override     
    public Class&lt;?&gt; getObjectType() &#123;
    	return Person.class;
    &#125; 
&#125;</code></pre>



<p>Bean的作用域<br>1、singleton：单例，Spring中的bean默认都是单例的。</p>
<p>2、prototype：每次请求都会创建一个新的bean实例。</p>
<p>3、request：每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</p>
<p>4、session：每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP session内有效。</p>
<p>5、global-session：全局session作用域。</p>
<p>Spring自动装配的方式有哪些？<br>Spring的自动装配有三种模式：byType(根据类型)，byName(根据名称)、constructor(根据构造函数)。</p>
<p>byType</p>
<p>找到与依赖类型相同的bean注入到另外的bean中，这个过程需要借助setter注入来完成，因此必须存在set方法，否则注入失败。</p>
<p>当xml文件中存在多个相同类型名称不同的实例Bean时，Spring容器依赖注入仍然会失败，因为存在多种适合的选项，Spring容器无法知道该注入那种，此时我们需要为Spring容器提供帮助，指定注入那个Bean实例。可以通过＜bean＞标签的autowire-candidate设置为false来过滤那些不需要注入的实例Bean</p>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;bean id&#x3D;&quot;userDao&quot;  class&#x3D;&quot;com.zejian.spring.springIoc.dao.impl.UserDaoImpl&quot; &#x2F;&gt; 
&lt;!-- autowire-candidate&#x3D;&quot;false&quot; 过滤该类型 --&gt; 
&lt;bean id&#x3D;&quot;userDao2&quot; autowire-candidate&#x3D;&quot;false&quot; class&#x3D;&quot;com.zejian.spring.springIoc.dao.impl.UserDaoImpl&quot; &#x2F;&gt; 
&lt;!-- byType 根据类型自动装配userDao--&gt; 
&lt;bean id&#x3D;&quot;userService&quot; autowire&#x3D;&quot;byType&quot; class&#x3D;&quot;com.zejian.spring.springIoc.service.impl.UserServiceImpl&quot; &#x2F;&gt;</code></pre>

<p>byName</p>
<p>将属性名与bean名称进行匹配，如果找到则注入依赖bean。</p>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;bean id&#x3D;&quot;userDao&quot;  class&#x3D;&quot;com.zejian.spring.springIoc.dao.impl.UserDaoImpl&quot; &#x2F;&gt; 
&lt;bean id&#x3D;&quot;userDao2&quot; class&#x3D;&quot;com.zejian.spring.springIoc.dao.impl.UserDaoImpl&quot; &#x2F;&gt; 
&lt;!-- byName 根据名称自动装配，找到UserServiceImpl名为 userDao属性并注入--&gt; 
&lt;bean id&#x3D;&quot;userService&quot; autowire&#x3D;&quot;byName&quot; class&#x3D;&quot;com.zejian.spring.springIoc.service.impl.UserServiceImpl&quot; &#x2F;&gt;</code></pre>

<p>constructor</p>
<p>存在单个实例则优先按类型进行参数匹配（无论名称是否匹配），当存在多个类型相同实例时，按名称优先匹配，如果没有找到对应名称，则注入失败。</p>
<p>@Autowired和@Resource的区别？<br>Autowire是spring的注解。默认情况下@Autowired是按类型匹配的(byType)。如果需要按名称(byName)匹配的话，可以使用@Qualifier注解与@Autowired结合。@Autowired 可以传递一个required&#x3D;false的属性，false指明当userDao实例存在就注入不存就忽略，如果为true，就必须注入，若userDao实例不存在，就抛出异常。</p>
<p>public class UserServiceImpl implements UserService {     &#x2F;&#x2F;标注成员变量     @Autowired     @Qualifier(“userDao1”)     private UserDao userDao;     }</p>
<p>Resource是j2ee的注解，默认按 byName模式自动注入。@Resource有两个中重要的属性：name和type。name属性指定bean的名字，type属性则指定bean的类型。因此使用name属性，则按byName模式的自动注入策略，如果使用type属性，则按 byType模式自动注入策略。倘若既不指定name也不指定type属性，Spring容器将通过反射技术默认按byName模式注入。</p>
<p>@Resource(name&#x3D;”userDao”)<br>private UserDao  userDao;&#x2F;&#x2F;用于成员变量</p>
<p>&#x2F;&#x2F;也可以用于set方法标注<br>@Resource(name&#x3D;”userDao”)<br>public void setUserDao(UserDao userDao) {<br>  this.userDao&#x3D; userDao;<br>}</p>
<p>上述两种自动装配的依赖注入并不适合简单值类型，如int、boolean、long、String以及Enum等，对于这些类型，Spring容器也提供了@Value注入的方式。</p>
<p>@Value和@Autowired、@Resource类似，也是用来对属性进行注入的，只不过@Value是用来从Properties文件中来获取值的，并且@Value可以解析SpEL(Spring表达式)。</p>
<p>比如，jdbc.properties文件如下：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">jdbc.driver&#x3D;com.mysql.jdbc.Driver
jdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;test?characterEncoding&#x3D;UTF-8&amp;allowMultiQueries&#x3D;true
jdbc.username&#x3D;root
jdbc.password&#x3D;root</code></pre>

<p>利用注解@Value获取jdbc.url和jdbc.username的值，实现如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class UserServiceImpl implements UserService &#123;
   &#x2F;&#x2F;占位符方式
   @Value(&quot;$&#123;jdbc.url&#125;&quot;)
   private String url;
   &#x2F;&#x2F;SpEL表达方式，其中代表xml配置文件中的id值configProperties
   @Value(&quot;#&#123;configProperties[&#39;jdbc.username&#39;]&#125;&quot;)
   private String userName;
&#125;</code></pre>



<p>@Qualifier 注解有什么作用<br>当需要创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个 bean 来消除歧义。</p>
<p>@Bean和@Component有什么区别？<br>都是使用注解定义 Bean。@Bean 是使用 Java 代码装配 Bean，@Component 是自动装配 Bean。</p>
<p>@Component 注解用在类上，表明一个类会作为组件类，并告知Spring要为这个类创建bean，每个类对应一个 Bean。</p>
<p>@Bean 注解用在方法上，表示这个方法会返回一个 Bean。@Bean 需要在配置类中使用，即类上需要加上@Configuration注解。</p>
<p>@Component public class Student {     private String name &#x3D; “lkm”;       public String getName() {         return name;     } } @Configuration public class WebSocketConfig {     @Bean     public Student student(){         return new Student();     } }</p>
<p>@Bean 注解更加灵活。当需要将第三方类装配到 Spring 容器中，因为没办法源代码上添加@Component注解，只能使用@Bean 注解的方式，当然也可以使用 xml 的方式。</p>
<p>@Component、@Controller、@Repositor和@Service 的区别？<br>@Component：最普通的组件，可以被注入到spring容器进行管理。</p>
<p>@Controller：将类标记为 Spring Web MVC 控制器。</p>
<p>@Service：将类标记为业务层组件。</p>
<p>@Repository：将类标记为数据访问组件，即DAO组件。</p>
<p>Spring 事务实现方式有哪些？<br>事务就是一系列的操作原子执行。Spring事务机制主要包括声明式事务和编程式事务。</p>
<p>编程式事务：通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。</p>
<p>声明式事务：将事务管理代码从业务方法中分离出来，通过aop进行封装。Spring声明式事务使得我们无需要去处理获得连接、关闭连接、事务提交和回滚等这些操作。使用 @Transactional 注解开启声明式事务。</p>
<p>@Transactional相关属性如下：</p>
<p>属性类型描述valueString可选的限定描述符，指定使用的事务管理器propagationenum: Propagation可选的事务传播行为设置isolationenum: Isolation可选的事务隔离级别设置readOnlyboolean读写或只读事务，默认读写timeoutint (in seconds granularity)事务超时时间设置rollbackForClass对象数组，必须继承自Throwable导致事务回滚的异常类数组rollbackForClassName类名数组，必须继承自Throwable导致事务回滚的异常类名字数组noRollbackForClass对象数组，必须继承自Throwable不会导致事务回滚的异常类数组noRollbackForClassName类名数组，必须继承自Throwable不会导致事务回滚的异常类名字数组</p>
<p>有哪些事务传播行为？<br>在TransactionDefinition接口中定义了七个事务传播行为：</p>
<p>PROPAGATION_REQUIRED如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。如果嵌套调用的两个方法都加了事务注解，并且运行在相同线程中，则这两个方法使用相同的事务中。如果运行在不同线程中，则会开启新的事务。</p>
<p>PROPAGATION_SUPPORTS 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。</p>
<p>PROPAGATION_MANDATORY 如果已经存在一个事务，支持当前事务。如果不存在事务，则抛出异常IllegalTransactionStateException。</p>
<p>PROPAGATION_REQUIRES_NEW 总是开启一个新的事务。需要使用JtaTransactionManager作为事务管理器。</p>
<p>PROPAGATION_NOT_SUPPORTED 总是非事务地执行，并挂起任何存在的事务。需要使用JtaTransactionManager作为事务管理器。</p>
<p>PROPAGATION_NEVER 总是非事务地执行，如果存在一个活动事务，则抛出异常。</p>
<p>PROPAGATION_NESTED 如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务, 则按PROPAGATION_REQUIRED 属性执行。</p>
<p>PROPAGATION_NESTED 与PROPAGATION_REQUIRES_NEW的区别:</p>
<p>使用PROPAGATION_REQUIRES_NEW时，内层事务与外层事务是两个独立的事务。一旦内层事务进行了提交后，外层事务不能对其进行回滚。两个事务互不影响。</p>
<p>使用PROPAGATION_NESTED时，外层事务的回滚可以引起内层事务的回滚。而内层事务的异常并不会导致外层事务的回滚，它是一个真正的嵌套事务。</p>
<p>Spring事务在什么情况下会失效？<br>1.访问权限问题</p>
<p>java的访问权限主要有四种：private、default、protected、public，它们的权限从左到右，依次变大。</p>
<p>如果事务方法的访问权限不是定义成public，这样会导致事务失效，因为spring要求被代理方法必须是public的。</p>
<p>翻开源码，可以看到，在AbstractFallbackTransactionAttributeSource类的computeTransactionAttribute方法中有个判断，如果目标方法不是public，则返回null，即不支持事务。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">protected TransactionAttribute computeTransactionAttribute(Method method, @Nullable Class&lt;?&gt; targetClass) &#123;     &#x2F;&#x2F; Don&#39;t allow no-public methods as required.     
    if (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;       return null;     &#125; 		&#x2F;&#x2F;... 
&#125;</code></pre>



<ol start="2">
<li>方法用final修饰</li>
</ol>
<p>如果事务方法用final修饰，将会导致事务失效。因为spring事务底层使用了aop，也就是通过jdk动态代理或者cglib，帮我们生成了代理类，在代理类中实现的事务功能。</p>
<p>但如果某个方法用final修饰了，那么在它的代理类中，就无法重写该方法，而添加事务功能。</p>
<p>同理，如果某个方法是static的，同样无法通过动态代理，变成事务方法。</p>
<p>3.对象没有被spring管理</p>
<p>使用spring事务的前提是：对象要被spring管理，需要创建bean实例。如果类没有加@Controller、@Service、@Component、@Repository等注解，即该类没有交给spring去管理，那么它的方法也不会生成事务。</p>
<p>4.表不支持事务</p>
<p>如果MySQL使用的存储引擎是myisam，这样的话是不支持事务的。因为myisam存储引擎不支持事务。</p>
<p>5.方法内部调用</p>
<p>如下代码所示，update方法上面没有加 @Transactional 注解，调用有 @Transactional 注解的 updateOrder 方法，updateOrder 方法上的事务会失效。</p>
<p>因为发生了自身调用，调用该类自己的方法，而没有经过 Spring 的代理类，只有在外部调用事务才会生效。</p>
<p>@Service public class OrderServiceImpl implements OrderService {     public void update(Order order) {         this.updateOrder(order);     }     @Transactional     public void updateOrder(Order order) {         &#x2F;&#x2F; update order     } }</p>
<p>解决方法：</p>
<p>1、再声明一个service，将内部调用改为外部调用</p>
<p>2、使用编程式事务</p>
<p>3、使用AopContext.currentProxy()获取代理对象</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servcie 
public class OrderServiceImpl implements OrderService &#123;         
	public void update(Order order) &#123;         
		((OrderService)AopContext.currentProxy()).updateOrder(order);
	&#125;     
	@Transactional     
	public void updateOrder(Order order) &#123;
		&#x2F;&#x2F; update order
	&#125;  
&#125;</code></pre>

<p>6.未开启事务</p>
<p>如果是spring项目，则需要在配置文件中手动配置事务相关参数。如果忘了配置，事务肯定是不会生效的。</p>
<p>如果是springboot项目，那么不需要手动配置。因为springboot已经在DataSourceTransactionManagerAutoConfiguration类中帮我们开启了事务。</p>
<p>7.吞了异常</p>
<p>有时候事务不会回滚，有可能是在代码中手动catch了异常。因为开发者自己捕获了异常，又没有手动抛出，把异常吞掉了，这种情况下spring事务不会回滚。</p>
<p>如果想要spring事务能够正常回滚，必须抛出它能够处理的异常。如果没有抛异常，则spring认为程序是正常的。</p>
<p>Spring怎么解决循环依赖的问题？<br>首先，有两种Bean注入的方式。</p>
<p>构造器注入和属性注入。</p>
<p>对于构造器注入的循环依赖，Spring处理不了，会直接抛出BeanCurrentlylnCreationException异常。</p>
<p>对于属性注入的循环依赖（单例模式下），是通过三级缓存处理来循环依赖的。</p>
<p>而非单例对象的循环依赖，则无法处理。</p>
<p>下面分析单例模式下属性注入的循环依赖是怎么处理的：</p>
<p>首先，Spring单例对象的初始化大略分为三步：</p>
<p>createBeanInstance：实例化bean，使用构造方法创建对象，为对象分配内存。</p>
<p>populateBean：进行依赖注入。</p>
<p>initializeBean：初始化bean。</p>
<p>Spring为了解决单例的循环依赖问题，使用了三级缓存：</p>
<p>singletonObjects：完成了初始化的单例对象map，bean name –&gt; bean instance</p>
<p>earlySingletonObjects：完成实例化未初始化的单例对象map，bean name –&gt; bean instance</p>
<p>singletonFactories： 单例对象工厂map，bean name –&gt; ObjectFactory，单例对象实例化完成之后会加入singletonFactories。</p>
<p>在调用createBeanInstance进行实例化之后，会调用addSingletonFactory，将单例对象放到singletonFactories中。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">protected void addSingletonFactory(String beanName, ObjectFactory&lt;?&gt; singletonFactory) &#123;
   Assert.notNull(singletonFactory, &quot;Singleton factory must not be null&quot;);
   synchronized (this.singletonObjects) &#123;
       if (!this.singletonObjects.containsKey(beanName)) &#123;
           this.singletonFactories.put(beanName, singletonFactory);
           this.earlySingletonObjects.remove(beanName);
           this.registeredSingletons.add(beanName);
       &#125;
   &#125;
&#125;</code></pre>



<p>假如A依赖了B的实例对象，同时B也依赖A的实例对象。</p>
<p>A首先完成了实例化，并且将自己添加到singletonFactories中</p>
<p>接着进行依赖注入，发现自己依赖对象B，此时就尝试去get(B)</p>
<p>发现B还没有被实例化，对B进行实例化</p>
<p>然后B在初始化的时候发现自己依赖了对象A，于是尝试get(A)，尝试一级缓存singletonObjects和二级缓存earlySingletonObjects没找到，尝试三级缓存singletonFactories，由于A初始化时将自己添加到了singletonFactories，所以B可以拿到A对象，然后将A从三级缓存中移到二级缓存中</p>
<p>B拿到A对象后顺利完成了初始化，然后将自己放入到一级缓存singletonObjects中</p>
<p>此时返回A中，A此时能拿到B的对象顺利完成自己的初始化</p>
<p>由此看出，属性注入的循环依赖主要是通过将实例化完成的bean添加到singletonFactories来实现的。而使用构造器依赖注入的bean在实例化的时候会进行依赖注入，不会被添加到singletonFactories中。比如A和B都是通过构造器依赖注入，A在调用构造器进行实例化的时候，发现自己依赖B，B没有被实例化，就会对B进行实例化，此时A未实例化完成，不会被添加到singtonFactories。而B依赖于A，B会去三级缓存寻找A对象，发现不存在，于是又会实例化A，A实例化了两次，从而导致抛异常。</p>
<p>总结：1、利用缓存识别已经遍历过的节点； 2、利用Java引用，先提前设置对象地址，后完善对象。</p>
<p>Spring启动过程<br>读取web.xml文件。</p>
<p>创建 ServletContext，为 ioc 容器提供宿主环境。</p>
<p>触发容器初始化事件，调用 contextLoaderListener.contextInitialized()方法，在这个方法会初始化一个应用上下文WebApplicationContext，即 Spring 的 ioc 容器。ioc 容器初始化完成之后，会被存储到 ServletContext 中。</p>
<p>初始化web.xml中配置的Servlet。如DispatcherServlet，用于匹配、处理每个servlet请求。</p>
<p>Spring 的单例 Bean 是否有并发安全问题？<br>当多个用户同时请求一个服务时，容器会给每一个请求分配一个线程，这时多个线程会并发执行该请求对应的业务逻辑，如果业务逻辑有对单例状态的修改（体现为此单例的成员属性），则必须考虑线程安全问题。</p>
<p>无状态bean和有状态bean</p>
<p>有实例变量的bean，可以保存数据，是非线程安全的。</p>
<p>没有实例变量的bean，不能保存数据，是线程安全的。</p>
<p>在Spring中无状态的Bean适合用单例模式，这样可以共享实例提高性能。有状态的Bean在多线程环境下不安全，一般用Prototype模式或者使用ThreadLocal解决线程安全问题。</p>
<p>Spring Bean如何保证并发安全？<br>Spring的Bean默认都是单例的，某些情况下，单例是并发不安全的。</p>
<p>以 Controller 举例，假如我们在 Controller 中定义了成员变量。当多个请求来临，进入的都是同一个单例的 Controller 对象，并对此成员变量的值进行修改操作，因此会互相影响，会有并发安全的问题。</p>
<p>应该怎么解决呢？</p>
<p>为了让多个HTTP请求之间不互相影响，可以采取以下措施：</p>
<p>1、单例变原型</p>
<p>对 web 项目，可以 Controller 类上加注解 @Scope(“prototype”) 或 @Scope(“request”)，对非 web 项目，在 Component 类上添加注解 @Scope(“prototype”) 。</p>
<p>这种方式实现起来非常简单，但是很大程度上增大了 Bean 创建实例化销毁的服务器资源开销。</p>
<p>2、尽量避免使用成员变量</p>
<p>在业务允许的条件下，可以将成员变量替换为方法中的局部变量。这种方式个人认为是最恰当的。</p>
<p>3、使用并发安全的类</p>
<p>如果非要在单例Bean中使用成员变量，可以考虑使用并发安全的容器，如 ConcurrentHashMap、ConcurrentHashSet 等等，将我们的成员变量包装到这些并发安全的容器中进行管理即可。</p>
<p>4、分布式或微服务的并发安全</p>
<p>如果还要进一步考虑到微服务或分布式服务的影响，方式3便不合适了。这种情况下可以借助于可以共享某些信息的分布式缓存中间件，如Redis等。这样即可保证同一种服务的不同服务实例都拥有同一份共享信息了。</p>
<p>@Async注解的原理<br>当我们调用第三方接口或者方法的时候，我们不需要等待方法返回才去执行其它逻辑，这时如果响应时间过长，就会极大的影响程序的执行效率。所以这时就需要使用异步方法来并行执行我们的逻辑。在springboot中可以使用@Async注解实现异步操作。</p>
<p>使用@Async注解实现异步操作的步骤：</p>
<p>1.首先在启动类上添加 @EnableAsync 注解。</p>
<p>@Configuration @EnableAsync public class App {     public static void main(String[] args) {          ApplicationContext ctx &#x3D; new                AnnotationConfigApplicationContext(App.class);         MyAsync service &#x3D; ctx.getBean(MyAsync.class);         System.out.println(service.getClass());         service.async1();         System.out.println(“main thread finish…”);     } }</p>
<p>2.在对应的方法上添加@Async注解。</p>
<p>@Component public class MyAsync {     @Async     public void asyncTest() {         try {             TimeUnit.SECONDS.sleep(20);         } catch (InterruptedException e) {             e.printStackTrace();         }         System.out.println(“asyncTest…”);     } }</p>
<p>运行代码，控制台输出：</p>
<p>main thread finish… asyncTest…</p>
<p>证明asyncTest方法异步执行了。</p>
<p>原理：</p>
<p>我们在主启动类上贴了一个@EnableAsync注解，才能使用@Async生效。@EnableAsync的作用是通过@import导入了AsyncConfigurationSelector。在AsyncConfigurationSelector的selectImports方法将ProxyAsyncConfiguration定义为Bean注入容器。在ProxyAsyncConfiguration中通过@Bean的方式注入AsyncAnnotationBeanPostProcessor类。</p>
<p><img src="https://raw.githubusercontent.com/2295237514/image/main/20230328163829.png"></p>
<p>代码如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Import(AsyncConfigurationSelector.class)
public @interface EnableAsync &#123;
&#125;

public class AsyncConfigurationSelector extends AdviceModeImportSelector&lt;EnableAsync&gt; &#123;
public String[] selectImports(AdviceMode adviceMode) &#123;
 switch (adviceMode) &#123;
  case PROXY:
   return new String[] &#123; ProxyAsyncConfiguration.class.getName() &#125;;
  &#x2F;&#x2F;...
 &#125;
&#125;
&#125;

public class ProxyAsyncConfiguration extends AbstractAsyncConfiguration &#123;
   @Bean(name &#x3D; TaskManagementConfigUtils.ASYNC_ANNOTATION_PROCESSOR_BEAN_NAME)
   public AsyncAnnotationBeanPostProcessor asyncAdvisor() &#123;
       &#x2F;&#x2F;创建postProcessor
       AsyncAnnotationBeanPostProcessor bpp &#x3D; new AsyncAnnotationBeanPostProcessor();
       &#x2F;&#x2F;...
   &#125;
&#125;</code></pre>

<p>AsyncAnnotationBeanPostProcessor往往期创建了一个增强器AsyncAnnotationAdvisor。在AsyncAnnotationAdvisor的buildAdvice方法中，创建了AnnotationAsyncExecutionInterceptor。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class AsyncAnnotationBeanPostProcessor extends AbstractBeanFactoryAwareAdvisingPostProcessor &#123;
   @Override
   public void setBeanFactory(BeanFactory beanFactory) &#123;
       super.setBeanFactory(beanFactory);
       &#x2F;&#x2F;创建一个增强器
       AsyncAnnotationAdvisor advisor &#x3D; new AsyncAnnotationAdvisor(this.executor, this.exceptionHandler);
       &#x2F;&#x2F;...
       advisor.setBeanFactory(beanFactory);
       this.advisor &#x3D; advisor;
   &#125;
&#125;


public class AsyncAnnotationAdvisor extends AbstractPointcutAdvisor implements BeanFactoryAware &#123;
   public AsyncAnnotationAdvisor(
           @Nullable Supplier&lt;Executor&gt; executor, @Nullable Supplier&lt;AsyncUncaughtExceptionHandler&gt; exceptionHandler) &#123;
       &#x2F;&#x2F;增强方法
       this.advice &#x3D; buildAdvice(executor, exceptionHandler);
       this.pointcut &#x3D; buildPointcut(asyncAnnotationTypes);
   &#125;

   &#x2F;&#x2F; 委托给AnnotationAsyncExecutionInterceptor拦截器
   protected Advice buildAdvice(
           @Nullable Supplier&lt;Executor&gt; executor, @Nullable Supplier&lt;AsyncUncaughtExceptionHandler&gt; exceptionHandler) &#123;
       &#x2F;&#x2F;拦截器
       AnnotationAsyncExecutionInterceptor interceptor &#x3D; new AnnotationAsyncExecutionInterceptor(null);
       interceptor.configure(executor, exceptionHandler);
       return interceptor;
   &#125;
&#125;</code></pre>

<p>AnnotationAsyncExecutionInterceptor继承自AsyncExecutionInterceptor，间接实现了MethodInterceptor。该拦截器的实现的invoke方法把原来方法的调用提交到新的线程池执行，从而实现了方法的异步。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class AsyncExecutionInterceptor extends AsyncExecutionAspectSupport implements MethodInterceptor, Ordered &#123;
   public Object invoke(final MethodInvocation invocation) throws Throwable &#123;
       &#x2F;&#x2F;...
       &#x2F;&#x2F;构建放到AsyncTaskExecutor执行Callable Task
       Callable&lt;Object&gt; task &#x3D; () -&gt; &#123;
           &#x2F;&#x2F;...
       &#125;;
       &#x2F;&#x2F;提交到新的线程池执行
       return doSubmit(task, executor, invocation.getMethod().getReturnType());
   &#125;
&#125;</code></pre>

<p>由上面分析可以看到，@Async注解其实是通过代理的方式来实现异步调用的。</p>
<p>那使用@Async有什么要注意的呢？</p>
<p>1.使用@Aysnc的时候最好配置一个线程池Executor以让线程复用节省资源，或者为SimpleAsyncTaskExecutor设置基于线程池实现的ThreadFactory，在否则会默认使用SimpleAsyncTaskExecutor，该executor会在每次调用时新建一个线程。</p>
<p>2.调用本类的异步方法是不会起作用的。这种方式绕过了代理而直接调用了方法，@Async注解会失效。</p>
</div>
        </div>
        
            <div class="kratos-copyright text-center clearfix">
                <h5 itemprop="copyrightNotice">本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</h5>
            </div>
        
        <footer class="kratos-entry-footer clearfix">
            
                <div class="post-like-donate text-center clearfix" id="post-like-donate">
                
                
                    <a class="share" href="javascript:;"><i class="fa fa-share-alt"></i> 分享</a>
                    <div class="share-wrap" style="display: none;">
    <div class="share-group">
        <a href="javascript:;" class="share-plain qq" onclick="share('qq');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-qq"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain qzone" onclick="share('qzone');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-star"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weixin pop style-plain" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weixin"></i>
            </div>
            <div class="share-int">
                <div class="qrcode" id="wechat-qr"></div>
                <p>打开微信“扫一扫”，打开网页后点击屏幕右上角分享按钮</p>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weibo" onclick="share('weibo');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weibo"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain facebook style-plain" onclick="share('facebook');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-facebook"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain twitter style-plain" onclick="share('twitter');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-twitter"></i>
            </div>
        </a>
    </div>
    <script type="text/javascript">
        $(()=>{
            new QRCode("wechat-qr", {
                text: "https://2295237514.github.io/post/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Spring.html",
                width: 150,
                height: 150,
                correctLevel : QRCode.CorrectLevel.H
            });
        });
        function share(dest) {
            const qqBase        = "https://connect.qq.com/widget/shareqq/index.html?";
            const weiboBase     = "https://service.weibo.com/share/share.php?";
            const qzoneBase     = "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?";
            const facebookBase  = "https://www.facebook.com/sharer/sharer.php?";
            const twitterBase   = "https://twitter.com/intent/tweet?";
            const hostUrl       = "https://2295237514.github.io/post/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Spring.html";
            const title         = "「深入学习Spring」";
            const excerpt       = `Spring是什么？Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。
Spring的优点通过控制反转和依赖注入实现松耦合。
支持面向切面的编程，并且把应用业务逻辑和系统服务分开。
通过切面和模板减少样板式代...`;
            let _URL;
            switch (dest) {
                case "qq"       : _URL = qqBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";     break;
                case "weibo"    : _URL = weiboBase+"url="+hostUrl+"&title="+title+excerpt;                                 break;
                case "qzone"    : _URL = qzoneBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";  break;
                case "facebook" : _URL = facebookBase+"u="+hostUrl;                                                        break;
                case "twitter"  : _URL = twitterBase+"text="+title+excerpt+"&url="+hostUrl;                                break;
            }
            window.open(_URL);
        };
    </script>
</div>
                
                </div>
            
            <div class="footer-tag clearfix">
                <div class="pull-left">
                <i class="fa fa-tags"></i>
                    
                </div>
                <div class="pull-date">
                    <time datetime="2023-03-28T09:07:43.676Z" itemprop="dateModified">最后编辑：2023-03-28</time>
                </div>
            </div>
        </footer>
    </div>
    
        <nav class="navigation post-navigation clearfix" role="navigation">
            
            <div class="nav-previous clearfix">
                <a title=" Mysql进阶篇" target="_blank" rel="noopener" href="//post/Mysql进阶篇.html">&lt; 上一篇</a>
            </div>
            
            
        </nav>
    
    
</article>

        

            </section>

        

                
            

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="/images/avatar.webp" loading="lazy" decoding="auto" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center"></p>
    </div>
    <div class="site-meta">
        <a class="meta-item" href="/archives/">
            <span class="title">
                文章
            </span>
            <span class="count">
                17
            </span>
        </a>
        <a class="meta-item" href="/categories/">
            <span class="title">
                分类
            </span>
            <span class="count">
                0
            </span>
        </a>
        <a class="meta-item" href="/tags/">
            <span class="title">
                标签
            </span>
            <span class="count">
                4
            </span>
        </a>
    </div>
</aside>
            
                    <div class="sticky-area">
                
                

            
                
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4>
      <div class="tag-clouds">
        <a href="/tags/JavaWeb/" style="font-size: 0.6em;">JavaWeb</a> <a href="/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 0.6em;">java基础知识</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 0.6em;">前端</a> <a href="/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 0.8em;">算法与数据结构</a>
      </div>
  </aside>

            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/post/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Spring.html"><i class="fa  fa-book"></i> 深入学习Spring</a>
            
          
        
          
          
            <a class="list-group-item" href="/post/Mysql%E8%BF%9B%E9%98%B6%E7%AF%87.html"><i class="fa  fa-book"></i> Mysql进阶篇</a>
            
          
        
          
          
            <a class="list-group-item" href="/post/Redis%E5%85%A5%E9%97%A8.html"><i class="fa  fa-book"></i> Redis入门</a>
            
          
        
          
          
            <a class="list-group-item" href="/post/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6.html"><i class="fa  fa-book"></i> Java集合框架</a>
            
          
        
          
          
            <a class="list-group-item" href="/post/%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89%E9%97%AE%E9%A2%98.html"><i class="fa  fa-book"></i> 面试精选问题</a>
            
          
        
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
      </ul>
  </div>
  </aside>

            
    </div>
</section>
        
        </div>
    </div>
</div>
<footer>
    <div id="footer"  class="ap-lrc"  >
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        <!-- Keep for compatibility -->
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <!-- New links -->
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2023 Hexo 版权所有.</li>
                            <li>本站已运行<span id="span_dt">Loading...</span></li>
                        </div>
                        <div>
                            <li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li>
                            <li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by GLK.</li>
                        </div>
                        <div>
                            <li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li>
                            <li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li>
                        </div>
                        <div>
                            
                            
                        </div>
                    </ul>
                </div>
            </div>
        </div>
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search/">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                
                    <div class="box theme-box" id="darkmode-switch">
                        <span class="fa fa-adjust"></span>
                    </div>
                
                
                
            </div>
            <div class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
    </div>
</footer>
</div>
</div>

        <script defer src="/vendors/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>
<script defer src="/vendors/nprogress@0.2.0/nprogress.js"></script>
<script>
    if (!window.kr) {
        window.kr = {};
    }
    window.kr.notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));
    window.kr.siteRoot = "/";
</script>


    <script async src="/js/candy.min.js"></script>



    <script defer src="/vendors/aplayer@1.10.1/dist/APlayer.min.js"></script>
    
    <script defer src="/vendors/meting@2.0.1/dist/Meting.min.js"></script>
    <meting-js
        server="netease"
        type="playlist"
        id="3204190542"
        order="random"
        fixed="true"
    >
    </meting-js>



    <script defer src="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script defer src="/js/kratosr.min.js"></script>
<script defer src="/js/pjax.min.js"></script>



<!-- Extra support for third-party plguins  -->


    </body>
</html>