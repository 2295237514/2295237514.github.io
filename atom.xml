<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://2295237514.github.io/atom.xml" rel="self"/>
  
  <link href="https://2295237514.github.io/"/>
  <updated>2022-09-26T13:08:39.001Z</updated>
  <id>https://2295237514.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试精选问题</title>
    <link href="https://2295237514.github.io/post/%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89%E9%97%AE%E9%A2%98.html"/>
    <id>https://2295237514.github.io/post/%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89%E9%97%AE%E9%A2%98.html</id>
    <published>2022-09-26T08:13:25.000Z</published>
    <updated>2022-09-26T13:08:39.001Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h2><h2 id="1-一道关于Integer的面试题"><a href="#1-一道关于Integer的面试题" class="headerlink" title="1.一道关于Integer的面试题"></a>1.一道关于Integer的面试题</h2><p>1，来，先来一道考题，你看做对了吗？</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Integer i1 &#x3D; new Integer(66);Integer i2 &#x3D; new Integer(66);System.out.println(i1 &#x3D;&#x3D; i2);Integer i3 &#x3D; 66;Integer i4 &#x3D; 66;int i5 &#x3D; 66;System.out.println(i3 &#x3D;&#x3D; i4);System.out.println(i3 &#x3D;&#x3D; i5);Integer i6 &#x3D; 128;Integer i7 &#x3D; 128;int i8 &#x3D; 128;System.out.println(i6 &#x3D;&#x3D; i7);System.out.println(i6 &#x3D;&#x3D; i8);</code></pre><p>大家可以猜测下结果，然后将程序运行起来，验证自己的答案是否正确</p><p>这道题主要考查大家对Integer实现原理的掌握程度</p><p>下面，我给大家对这里的关键原理做解读，相信理解之后，你心中自然有答案了</p><p>答案揭晓</p><p>分情况来比较</p><ul><li>都定义为Integer的比较：</li></ul><p>new：一旦new，就是开辟一块新内存，结果肯定是false<br>不new：<br>看范围<br>Integer做了缓存，-128至127，当你取值在这个范围的时候，会采用缓存的对象，所以会相等<br>当不在这个范围，内部创建新的对象，此时不相等</p><ul><li>Integer和int的比较：</li></ul><p>实际比较的是数值，Integer会做拆箱的动作，来跟基本数据类型做比较<br>此时跟是否在缓存范围内或是否new都没关系</p><hr><p>源码分析：</p><p>当我们写Integer i &#x3D; 126,实际上做了自动装箱：Integer i &#x3D; Integer.valueOf(126);<br>分析这段源码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static Integer valueOf(int i) &#123;    if (i &gt;&#x3D; IntegerCache.low &amp;&amp; i &lt;&#x3D; IntegerCache.high)        return IntegerCache.cache[i + (-IntegerCache.low)];    return new Integer(i);&#125;&#x2F;&#x2F;IntegerCache是Integer的内部类private static class IntegerCache &#123;    static final int low &#x3D; -128;    static final int high;    static final Integer cache[];    static &#123;        &#x2F;&#x2F; high value may be configured by property        int h &#x3D; 127;    &#x2F;&#x2F;...&#125;</code></pre><h2 id="2-StringBuffer，StringBuilder开发中如何做选择？"><a href="#2-StringBuffer，StringBuilder开发中如何做选择？" class="headerlink" title="2.StringBuffer，StringBuilder开发中如何做选择？"></a>2.StringBuffer，StringBuilder开发中如何做选择？</h2><ul><li>String是final类型，每次声明的都是不可变的对象，</li><li>所以每次操作都会产生新的String对象，然后将指针指向新的String对象。</li><li>StringBuffer，StringBuilder都是在原有对象上进行操作</li></ul><p>所以，如果需要经常改变字符串内容，则建议采用StringBuffer 和 StringBuilder</p><p><strong>StringBuffer是线程安全的，StringBuilder是线程不安全的。</strong><br>线程不安全的StringBuilder性能更高，所以在开发中，优先采用StringBuilder.<br><em>StringBuilder &gt; StringBuffer &gt; String</em><br>注意：</p><p>我们在开发中为什么会选择StringBuilder？</p><p>这个要看场景，有同学说可以为了性能放弃安全，这是不对的。</p><p>大家想想，什么情况下需要考虑线程安全的问题？</p><ul><li><em>有一个前提条件就是：多线程访问同一个资源，且有更新操作</em></li></ul><p>所以，只要不是这样的场景，我们就可以放心使用StringBuilder</p><p><em>而我们在开发中，通常使用StringBuilder在方法内来创建对象和拼接信息，而这种情况是一个线程对应一个StringBuilder对象</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JAVA&quot;&gt;&lt;a href=&quot;#JAVA&quot; class=&quot;headerlink&quot; title=&quot;JAVA&quot;&gt;&lt;/a&gt;JAVA&lt;/h2&gt;&lt;h2 id=&quot;1-一道关于Integer的面试题&quot;&gt;&lt;a href=&quot;#1-一道关于Integer的面试题&quot; class=&quot;he</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="https://2295237514.github.io/post/JVM.html"/>
    <id>https://2295237514.github.io/post/JVM.html</id>
    <published>2022-07-28T00:37:05.000Z</published>
    <updated>2022-07-28T06:11:20.945Z</updated>
    
    <content type="html"><![CDATA[<p>定义： Java Virtual Machine - java程序的运行环境 (java二进制字节码的运行环境)</p><p>好处：</p><ul><li>一次编写，到处运行</li><li>自动内存管理，垃圾回收功能</li><li>数据下标越界检查</li><li>多态</li></ul><p>比较：</p><p>​JRE: Java Runtime Enviroment（）</p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220728084611.png"></p><p>常见的JVM:</p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220728085107.png"></p><p>学习路线：</p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220728085230.png"></p><h1 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h1><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><ul><li>Program Counter Register 程序计数器（寄存器）</li></ul><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><p>​用于保存下一条JVM指令的执行地址地址</p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p>​1.是线程私有的:</p><ul><li><p>CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码</p></li><li><p>程序计数器是<strong>每个线程</strong>所<strong>私有</strong>的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令</p></li></ul><p>​2.不会存在内存溢出</p><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><ul><li>每个线程运行时所需要的内存，称为虚拟机栈</li><li>每个栈由多个栈帧组成，对应着每次方法调用时所占用的内存</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ul><p> 问题辨析：</p><p>1.垃圾回收是否涉及栈内存？</p><ul><li>不涉及，因为虚拟机栈是有一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。</li></ul><p>2.栈内存的分配越大越好吗？</p><ul><li>不是，因为<em>物理内存是一定的</em>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越来越少</li></ul><p>3.方法内的局部变量是否是线程安全的？</p><ul><li>如果方法内<em>局部变量没有逃离方法的作用范围</em>，则是<em>线程安全</em>的</li><li>如果局部变量引用了对象，并逃离了方法的作用范围，则需要考虑线程安全问题</li></ul><h3 id="栈内存溢出"><a href="#栈内存溢出" class="headerlink" title="栈内存溢出"></a>栈内存溢出</h3><p><strong>Java.lang.stackOverflowError</strong> 栈内存溢出</p><ul><li>栈帧过多导致栈内存溢出（无限递归）</li><li>栈帧过大导致内存溢出</li></ul><h3 id="线程运行诊断"><a href="#线程运行诊断" class="headerlink" title="线程运行诊断"></a>线程运行诊断</h3><p>CPU占用过高</p><ul><li>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这是需要定位占用CPU过高的线程<ul><li>ps H -en pid, tid, %cpu | grep 刚才通过top查到的进程号 通过ps命令进一步查看是哪个线程占用CPU过高</li><li><em>jstack 进程id</em> 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来对比定位，注意jstack查找出的线程id是16禁止的，需要转换</li></ul></li></ul><p>迟迟得不到结果</p><ul><li>可能发生了死锁</li></ul><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>一些带有<strong>native关键字</strong>的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>通过new关键字，创建的对象都会使用堆内存</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>他是线程共享的，堆中对象都需要考虑线程安全的问题</li><li>有垃圾回收机制</li></ul><h3 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h3><p><strong>java.lang.OutofMemoryError</strong> ：java heap space</p><h3 id="堆内存诊断"><a href="#堆内存诊断" class="headerlink" title="堆内存诊断"></a>堆内存诊断</h3><p>1.jps工具</p><ul><li>查看当前系统中有哪些java进程</li></ul><p>2.jmap工具</p><ul><li>查看堆内存占用情况</li></ul><p>3.jconsole工具</p><ul><li>图形界面的，多功能的监测工具，可以连续监测</li></ul><p>4.jvirsalvm</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>方法区（Method Area）与Java堆一样，是各个线程共享的<a class="link"   href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020" >内存<i class="fas fa-external-link-alt"></i></a>区域。</p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220728132737.png"></p><h3 id="方法区内存溢出"><a href="#方法区内存溢出" class="headerlink" title="方法区内存溢出"></a>方法区内存溢出</h3><ul><li>1.8以前会导致永久代内存溢出</li><li>1.8之后会导致元空间内存溢出</li></ul><h3 id="通过反编译来查看类的信息"><a href="#通过反编译来查看类的信息" class="headerlink" title="通过反编译来查看类的信息"></a><strong>通过反编译来查看类的信息</strong></h3><ul><li><p>获得对应类的.class文件</p><ul><li><p>在JDK对应的bin目录下运行cmd，<strong>也可以在IDEA控制台输入</strong></p></li><li><p>输入 <strong>javac 对应类的绝对路径</strong></p><pre class="line-numbers language-none"><code class="language-none">F:\JAVA\JDK8.0\bin&gt;javac F:\Thread_study\src\com\nyima\JVM\day01\Main.javaCopy</code></pre><p>输入完成后，对应的目录下就会出现类的.class文件</p></li></ul></li><li><p>在控制台输入 javap -v 类的绝对路径</p><pre class="line-numbers language-none"><code class="language-none">javap -v F:\Thread_study\src\com\nyima\JVM\day01\Main.classCopy</code></pre></li><li><p>然后能在控制台看到反编译以后类的信息了</p></li></ul><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><ul><li>常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息</li><li>运行时常量池，常量池是*.class文件中的，当该类被加载，他的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;定义： Java Virtual Machine - java程序的运行环境 (java二进制字节码的运行环境)&lt;/p&gt;
&lt;p&gt;好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一次编写，到处运行&lt;/li&gt;
&lt;li&gt;自动内存管理，垃圾回收功能&lt;/li&gt;
&lt;li&gt;数据下标越界检查&lt;/li&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>SSM</title>
    <link href="https://2295237514.github.io/post/SSM.html"/>
    <id>https://2295237514.github.io/post/SSM.html</id>
    <published>2022-07-26T08:33:15.000Z</published>
    <updated>2022-09-22T04:56:32.109Z</updated>
    
    <content type="html"><![CDATA[<p><a class="link"   href="https://spring.io/" >spring官网<i class="fas fa-external-link-alt"></i></a></p><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><ul><li>Spring Framework是Spring生态圈中最基础的项目，是其他项目的根基</li></ul><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220726165418.png"></p><h2 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h2><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220726165701.png"></p><h2 id="核心容器的核心概念"><a href="#核心容器的核心概念" class="headerlink" title="核心容器的核心概念"></a>核心容器的核心概念</h2><ul><li><p>代码书写现状</p><ul><li>代码耦合度高</li></ul></li><li><p>解决方案</p><ul><li>使用对象时，在程序中不要主动使用new产生对象，转换为由<em>外部</em>提供对象</li></ul></li><li><p><strong>IoC(Inversion of Control) 控制反转</strong></p><ul><li>对象的创建控制权由程序转移到<em>外部</em>，这种思想称为控制反转</li><li>目标：解耦</li></ul></li><li><p>Spring技术对IoC思想进行了实现</p><ul><li>Spring提供了一个容器，称为IoC容器，用来充当IoC思想的<em>外部</em></li><li>IoC容器负责对象的创建、初始化等一系列工作，被创建或被管理的对象在IoC容器中统称为Bean</li></ul></li><li><p><strong>DI(Dependency Injection)依赖注入</strong></p><ul><li>在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入</li></ul></li></ul><hr><p><strong>本节总结：</strong></p><ul><li><strong>目标：充分解耦</strong><ul><li><strong>在IoC容器中管理bean（IoC）</strong></li><li><strong>在IoC容器内将有依赖关系的bean进行关系绑定（DI）</strong></li></ul></li><li><strong>最终效果</strong><ul><li><strong>使用对象时不仅可以直接从IoC容器中获取，并且获取的bean已经绑定了所有的依赖关系</strong></li></ul></li></ul><h2 id="IoC入门案例思路分析"><a href="#IoC入门案例思路分析" class="headerlink" title="IoC入门案例思路分析"></a>IoC入门案例思路分析</h2><p> 1.管理什么？(Service与Dao)</p><p>2.如何将被管理的对象告知IoC容器？(配置)</p><p>3.被管理的对象交给IoC容器，如何获取到IoC容器？(接口)</p><p>4.IoC容器得到后，如何从容器中获取bean？(接口方法)</p><p>5.使用Spring时怎么导入坐标(pom.xml)</p><p>使用步骤：</p><p>1.导jar包</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt;    &lt;version&gt;5.2.10.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre><p>2.定义spring管理的类（接口）</p><p>3.创建Spirng配置文件，配置对应类作为Spring管理的bean</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;    &lt;bean id&#x3D;&quot;bookDaoBean&quot; class&#x3D;&quot;com.itheima.dao.impl.BookDaoImpl&quot;&#x2F;&gt;    &lt;bean id&#x3D;&quot;bookServiceBean&quot; class&#x3D;&quot;com.itheima.service.impl.BookServiceImpl&quot;&#x2F;&gt;&lt;&#x2F;beans&gt;</code></pre><p>注意事项：bean定义式id属性在同一个上下文中不能重复</p><p>4.初始化IoC容器，通过容器获取bean</p><pre class="line-numbers language-none"><code class="language-none">ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);需要获取的对象的类型 bookDao &#x3D; (需要获取的对象类型)applicationContext.getBean(&quot;bookDaoBean&quot;);</code></pre><p>applicationContext.getBean(“”)获取的是一个Object类型的对象，应对其进行强制类型转换</p><h2 id="DI入门案例"><a href="#DI入门案例" class="headerlink" title="DI入门案例"></a>DI入门案例</h2><p>1.基于IoC管理bean</p><p>2.Service中使用new形式创建的Dao对象是否保留？(否)</p><p>3.Service中需要的Dao对象如何进入到Service中？(提供方法)</p><p>4.Service与Dao间的关系如何描述？(配置)</p><p>使用步骤：</p><p>1.删除使用new的形式创建对象的代码</p><p>private BookDao bookDao <del>&#x3D; new BookDaoImpl()</del>;</p><p>public void save(){<br>    System.out.println(“book service 。。。”);<br>    bookDao.save();<br>}</p><p>2.提供依赖对象对应的setter方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class BookServiceImpl implements BookService &#123;    private BookDao bookDao;    public void save()&#123;        System.out.println(&quot;book service 。。。。。。&quot;);        bookDao.save();    &#125;    public void setBookDao(BookDao bookDao) &#123;        this.bookDao &#x3D; bookDao;    &#125;&#125;</code></pre><p>3.配置service与dao之间的关系</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;bean id&#x3D;&quot;bookServiceBean&quot; class&#x3D;&quot;com.itheima.service.impl.BookServiceImpl&quot;&gt;        &lt;property name&#x3D;&quot;bookDao&quot; ref&#x3D;&quot;bookDaoBean&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;&#x2F;&#x2F; property 标签中 name是 id&#x3D;&quot;bookServiceBean&quot;对象里属性的名称   ref则是bean对象的名称</code></pre><h2 id="bean基础配置"><a href="#bean基础配置" class="headerlink" title="bean基础配置"></a>bean基础配置</h2><h3 id="别名配置"><a href="#别名配置" class="headerlink" title="别名配置"></a>别名配置</h3><p>姓名：name</p><p>类型：属性</p><p>所属：bean标签</p><p>范例</p><pre class="line-numbers language-none"><code class="language-none">&lt;bean id&#x3D;&quot;bookServiceBean&quot; name&#x3D;&quot;FirstBean,SecondBean&quot; class&#x3D;&quot;com.itheima.service.impl.BookServiceImpl&quot;&gt;        &lt;property name&#x3D;&quot;bookDao&quot; ref&#x3D;&quot;bookDaoBean&quot;&#x2F;&gt;    &lt;&#x2F;bean&gt;</code></pre><p><strong>注意事项</strong></p><p>获取bean无论是通过id还是name获取，如果无法获取到，将抛出异常NoSuchBeanDefinitionException</p><p>NoSuchBeanDefinitionException: No bean named ‘bookServiceImpl’ available</p><h3 id="bean作用范围说明"><a href="#bean作用范围说明" class="headerlink" title="bean作用范围说明"></a>bean作用范围说明</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220730095635.png"></p><p>可见，Spring默认给我们创建的bean是一个单例模式，</p><p>我们可以通过在 bean标签中设置属性 scope&#x3D;”prototype”来讲bean设置成非单例</p><ul><li>适合交给容器进行管理的bean<ul><li>表现层对象</li><li>业务层对象</li><li>数据层对象</li><li>工具对象</li></ul></li><li>不适合交给容器进行管理的bean<ul><li>封装实体的域对象</li></ul></li></ul><h3 id="单例bean与原型bean的区别"><a href="#单例bean与原型bean的区别" class="headerlink" title="单例bean与原型bean的区别"></a>单例bean与原型bean的区别</h3><p><em>单例bean：如果一个bean被声明为单例的时候，在处理多次请求的时候在Spring容器里只实例化出一个bean，后续的请求都公用这个对象，这个对象会保存在一个map里面。<br>当有请求来的时候会先从缓存(map)里查看有没有，有的话直接使用这个对象，没有的话才实例化一个新的对象，所以这是个单例的。（ThreadLocal ）创建完后，后面都会复用这个bean</em></p><p><em>原型(prototype)bean来说当每次请求来的时候直接实例化新的bean，没有缓存以及从缓存查的过程。</em></p><p>结论：</p><p><em>单例的bean只有第一次创建新的bean 后面都会复用该bean，所以不会频繁创建对象。</em></p><p><em>原型的bean每次都会新创建</em></p><p>单例bean的优势<br>由于不会每次都新创建新对象所以有一下几个性能上的优势：</p><p><strong>1.减少了新生成实例的消耗</strong><br>新生成实例消耗包括两方面，第一，Spring会通过反射或者cglib来生成bean实例这都是耗性能的操作，其次给对象分配内存也会涉及复杂算法。</p><p><strong>2.减少jvm垃圾回收</strong><br>由于不会给每个请求都新生成bean实例，所以自然回收的对象少了。</p><p><strong>3.可以快速获取到bean</strong><br>因为单例的获取bean操作除了第一次生成之外其余的都是从缓存里获取的所以很快。</p><p><em><strong>单例bean的劣势</strong></em><br>单例的bean一个很大的劣势就是他不能做到线程安全！！！尤其是高并发情况下。</p><p>由于所有请求都共享一个bean实例，所以这个bean要是有状态的一个bean的话可能在并发场景下出现问题，而原型的bean则不会有这样问题（但也有例外，比如他被单例bean依赖），因为给每个请求都新创建实例。</p><h2 id="bean实例化的三种方式"><a href="#bean实例化的三种方式" class="headerlink" title="bean实例化的三种方式"></a>bean实例化的三种方式</h2><h3 id="构造方法（常用）"><a href="#构造方法（常用）" class="headerlink" title="构造方法（常用）"></a>构造方法（常用）</h3><ul><li>bean本质上就是对象，创建bean使用构造方法完成</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class BookDaoImpl implements BookDao &#123;&#x2F;&#x2F;    private BookDaoImpl()&#123;&#x2F;&#x2F;        System.out.println(&quot;book dao struct is running......&quot;);&#x2F;&#x2F;    &#125;    public void save() &#123;        System.out.println(&quot;BookDao 我他吗来啦&quot;);    &#125;&#125;</code></pre><ul><li>提供可访问的构造方法</li></ul><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;bean id&#x3D;&quot;bookDaoBean&quot; class&#x3D;&quot;com.itheima.dao.impl.BookDaoImpl&quot;&#x2F;&gt;</code></pre><h3 id="静态工厂（了解）"><a href="#静态工厂（了解）" class="headerlink" title="静态工厂（了解）"></a>静态工厂（了解）</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220730114100.png"></p><h3 id="实例工厂"><a href="#实例工厂" class="headerlink" title="实例工厂"></a>实例工厂</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220730114017.png"></p><h3 id="FactoryBean（实用）"><a href="#FactoryBean（实用）" class="headerlink" title="FactoryBean（实用）"></a>FactoryBean（实用）</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220730130510.png"></p><h2 id="bean生命周期"><a href="#bean生命周期" class="headerlink" title="bean生命周期"></a>bean生命周期</h2><ul><li>生命周期：从创建到销毁的完整过程</li><li>bean生命周期控制：在bean创建后到销毁前做一些事情</li></ul><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220730133209.png"></p><p>接口控制（了解）</p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220730133605.png"></p><h3 id="bean生命周期-1"><a href="#bean生命周期-1" class="headerlink" title="bean生命周期"></a>bean生命周期</h3><ul><li><p>初始化容器</p><p>1.创建对象（内存分配）</p><p>2.执行构造方法</p><p>3.执行属性注入（set操作）</p><p>4.执行bean初始化方法</p></li><li><p>使用bean</p><p>1.执行业务操作</p></li><li><p>关闭&#x2F;销毁容器</p><p>1.执行bean销毁方法</p></li></ul><h3 id="bean销毁时机"><a href="#bean销毁时机" class="headerlink" title="bean销毁时机"></a>bean销毁时机</h3><ul><li><p>容器关闭前触发bean的销毁</p></li><li><p>关闭容器方式：</p><ul><li><p>手工关闭容器</p><p>ConfigurableApplicationContext接口close（）方法</p></li><li><p>注册关闭钩子，在虚拟机退出前先关闭容器再退出虚拟机</p><p>ConfigurableApplicationContext接口registerShutdownHook（）操作</p></li></ul></li></ul><h2 id="依赖注入方式"><a href="#依赖注入方式" class="headerlink" title="依赖注入方式"></a>依赖注入方式</h2><ul><li><p>思考：向一个类中传递数据的方式有几种？</p><ul><li>普通方法（set方法）</li><li>构造方法</li></ul></li><li><p>思考：依赖注入描述了在容器中简历bean与bean之间依赖关系的过程，如果bean运行需要的是数据或字符串呢？</p></li><li><p>setter注入</p><ul><li><p>简单类型</p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220730140922.png"></p></li><li><p>引用类型</p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220730140856.png"></p></li></ul></li><li><p>构造器注入</p><ul><li><p>简单类型</p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220730163208.png"></p></li><li><p>引用类型</p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220730163117.png"></p></li></ul></li></ul><h3 id="依赖注入方式选择"><a href="#依赖注入方式选择" class="headerlink" title="依赖注入方式选择"></a>依赖注入方式选择</h3><p>1.强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现</p><p>2.可选依赖使用setter注入进行，灵活性强</p><p>3.Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨</p><p>4.如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入</p><p>5.实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入</p><p><strong>6.自己开发的模块推荐使用setter注入</strong></p><h3 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h3><ul><li><p>IoC容器根据bean所以来的资源在容器中自动查找并注入到bean中的过程称为自动装配</p></li><li><p>自动装配方式</p><ul><li>按类型（常用）</li><li>按名称</li><li>按构造方法</li><li>不启用自动装配</li></ul></li><li><p>配种中使用bean标签autowire</p></li></ul><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220731085314.png"></p><ul><li>自动装配用于引用类型依赖注入，不能对简单类型进行操作</li><li>使用按类型装配时(byType)必须保障容器中想同类型的bean唯一，推荐使用</li><li>使用按名称装配时(byName)必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用</li><li>自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效</li></ul><h3 id="集合注入"><a href="#集合注入" class="headerlink" title="集合注入"></a>集合注入</h3><p><em>数组，List，Set，Map,Properties</em></p><p><strong>bean所依赖的实现类</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class BookDaoImpl implements BookDao &#123;    private int[] array;    private List&lt;String&gt; list;    private Set&lt;String&gt; set;    private Map&lt;String,String&gt; map;    private Properties properties;    public void setArray(int[] array) &#123;        this.array &#x3D; array;    &#125;    public void setList(List&lt;String&gt; list) &#123;        this.list &#x3D; list;    &#125;    public void setSet(Set&lt;String&gt; set) &#123;        this.set &#x3D; set;    &#125;    public void setMap(Map&lt;String, String&gt; map) &#123;        this.map &#x3D; map;    &#125;    public void setProperties(Properties properties) &#123;        this.properties &#x3D; properties;    &#125;    public void save() &#123;        System.out.println(&quot;book dao save ...&quot;);        System.out.println(&quot;遍历数组:&quot; + Arrays.toString(array));        System.out.println(&quot;遍历List&quot; + list);        System.out.println(&quot;遍历Set&quot; + set);        System.out.println(&quot;遍历Map&quot; + map);        System.out.println(&quot;遍历Properties&quot; + properties);    &#125;&#125;</code></pre><p>applicationContext.xml</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;    &lt;bean id&#x3D;&quot;bookDao&quot; class&#x3D;&quot;com.itheima.dao.impl.BookDaoImpl&quot;&gt;        &lt;!--数组注入--&gt;        &lt;property name&#x3D;&quot;array&quot;&gt;            &lt;array&gt;                &lt;value&gt;100&lt;&#x2F;value&gt;                &lt;value&gt;200&lt;&#x2F;value&gt;                &lt;value&gt;300&lt;&#x2F;value&gt;            &lt;&#x2F;array&gt;        &lt;&#x2F;property&gt;        &lt;!--list集合注入--&gt;        &lt;property name&#x3D;&quot;list&quot;&gt;            &lt;list&gt;                &lt;value&gt;itcast&lt;&#x2F;value&gt;                &lt;value&gt;itheima&lt;&#x2F;value&gt;                &lt;value&gt;boxuegu&lt;&#x2F;value&gt;                &lt;value&gt;chuanzhihui&lt;&#x2F;value&gt;            &lt;&#x2F;list&gt;        &lt;&#x2F;property&gt;        &lt;!--set集合注入--&gt;        &lt;property name&#x3D;&quot;set&quot;&gt;            &lt;set&gt;                &lt;value&gt;itcast&lt;&#x2F;value&gt;                &lt;value&gt;itheima&lt;&#x2F;value&gt;                &lt;value&gt;boxuegu&lt;&#x2F;value&gt;                &lt;value&gt;boxuegu&lt;&#x2F;value&gt;            &lt;&#x2F;set&gt;        &lt;&#x2F;property&gt;        &lt;!--map集合注入--&gt;        &lt;property name&#x3D;&quot;map&quot;&gt;            &lt;map&gt;                &lt;entry key&#x3D;&quot;country&quot; value&#x3D;&quot;china&quot;&#x2F;&gt;                &lt;entry key&#x3D;&quot;province&quot; value&#x3D;&quot;henan&quot;&#x2F;&gt;                &lt;entry key&#x3D;&quot;city&quot; value&#x3D;&quot;kaifeng&quot;&#x2F;&gt;            &lt;&#x2F;map&gt;        &lt;&#x2F;property&gt;        &lt;!--Properties注入--&gt;        &lt;property name&#x3D;&quot;properties&quot;&gt;            &lt;props&gt;                &lt;prop key&#x3D;&quot;country&quot;&gt;china&lt;&#x2F;prop&gt;                &lt;prop key&#x3D;&quot;province&quot;&gt;henan&lt;&#x2F;prop&gt;                &lt;prop key&#x3D;&quot;city&quot;&gt;kaifeng&lt;&#x2F;prop&gt;            &lt;&#x2F;props&gt;        &lt;&#x2F;property&gt;    &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt;</code></pre><h2 id="第三方资源配置管理"><a href="#第三方资源配置管理" class="headerlink" title="第三方资源配置管理"></a>第三方资源配置管理</h2><ul><li><p>导入druid坐标</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;            &lt;version&gt;1.1.16&lt;&#x2F;version&gt;        &lt;&#x2F;dependency&gt;</code></pre></li><li><p>配置数据源对象作为spring管理的bean</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;bean class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;        &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;spring_db&quot;&#x2F;&gt;        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;&quot;&#x2F;&gt;        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;</code></pre></li></ul><h2 id="加载properties文件"><a href="#加载properties文件" class="headerlink" title="加载properties文件"></a>加载properties文件</h2><p>由于上次学习将数据库的用户名，密码，全配置在applicationContext.xml之中，非常的危险，故应该使用properties文件记录数据库信息</p><p>1.开启context命名空间</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;       xsi:schemaLocation&#x3D;&quot;            http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans            http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd            http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context            http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd            &quot;&gt;    &lt;!--  将含有beans的代码复制一份并用context替换beans--&gt;</code></pre><p>2.使用context空间加载properties文件</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;context:property-placeholder location&#x3D;&quot;classpath*:*.properties&quot; system-properties-mode&#x3D;&quot;NEVER&quot;&#x2F;&gt;</code></pre><ol start="3"><li>使用属性占位符${}读取properties文件中的属性</li></ol><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;bean class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;        &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;$&#123;jdbc.Driver&#125;&quot;&#x2F;&gt;        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot;&#x2F;&gt;        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot;&#x2F;&gt;        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;</code></pre><p>4.自己配置的 jdbc.properties文件内容</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">jdbc.driver&#x3D;com.mysql.jdbc.Driverjdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;spring_dbjdbc.username&#x3D;rootjdbc.password&#x3D;root</code></pre><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220731110143.png"></p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220731114926.png"></p><h3 id="获取bean"><a href="#获取bean" class="headerlink" title="获取bean"></a>获取bean</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220731115010.png"></p><h3 id="容器类结构层次"><a href="#容器类结构层次" class="headerlink" title="容器类结构层次"></a>容器类结构层次</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220731131448.png"></p><h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><ul><li>类路径加载配置文件</li></ul><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220731131508.png"></p><h2 id="核心容器总结"><a href="#核心容器总结" class="headerlink" title="核心容器总结"></a>核心容器总结</h2><ul><li>BeanFactory是IoC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载</li><li>ApplicationContext接口是Spring容器的核心接口，初始化时bean立即加载</li><li>ApplicationContext接口提供基础的bean操作相关方法，通过其他接口扩展其功能</li><li>ApplicationContext接口常用初始化类<ul><li>ClassPathXmlApplicationContext</li><li>FileSystemXmlApplicationContext</li></ul></li></ul><h3 id="bean相关"><a href="#bean相关" class="headerlink" title="bean相关"></a>bean相关</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220731132707.png"></p><h3 id="依赖注入相关"><a href="#依赖注入相关" class="headerlink" title="依赖注入相关"></a>依赖注入相关</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220731132729.png"></p><h2 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h2><h3 id="注解开发定义bean"><a href="#注解开发定义bean" class="headerlink" title="注解开发定义bean"></a>注解开发定义bean</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220731140547.png"></p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220731140608.png"></p><p><strong>同时这几个注解后面也可以添加一些参数，比如比较常用的一个是注解的括号中加value属性，来表示这个组件在容器中的ID，如果不设置value值时，默认的ID是类名的全称（第一个字母小写）。</strong></p><p><strong>在这里有一点需要注意：事实上Spring并没有能力识别一个组件到底是不是它所标记的类型，</strong>即使将@Respository注解用在一个表述层控制器组件上面也不会产生任何错误，所以@Respository、@Service、@Controller这几个注解仅仅是为了让开发人员自己明确当前的组件扮演的角色。方便将组件加入到容器中去。</p><h3 id="纯注解开发"><a href="#纯注解开发" class="headerlink" title="纯注解开发"></a>纯注解开发</h3><ul><li><p>Spring3.0升级了纯注解开发模式，使用java类替代配置文件，开启了Spring快速开发赛道</p></li><li><p>读取Spring核心配置文件初始化容器对象切换为读取Java配置类初始化容器对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;加载配置文件初始化容器ApplicationContext ctx &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);&#x2F;&#x2F;加载配置类初始化容器    ApplicationContext ctx &#x3D; new AnnotationConfigApplicationContext(SpringConfig.class);</code></pre></li><li><p>Java类替代Spring核心配置文件</p></li></ul><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xsi:schemaLocation&#x3D;&quot;        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;    &lt;context:component-scan base-package&#x3D;&quot;com.itheima&quot;&#x2F;&gt;&lt;&#x2F;beans&gt;&#x2F;&#x2F;配置文件被替换为&#x2F;&#x2F;声明当前类为Spring配置类@Configuration&#x2F;&#x2F;设置bean扫描路径，多个路径书写为字符串数组格式@ComponentScan(&#123;&quot;com.itheima.service&quot;,&quot;com.itheima.dao&quot;&#125;)public class SpringConfig &#123;&#125;</code></pre><ul><li><p>@Configuration注解用于设定当前类为配置类</p></li><li><p>@ComponentScan注解用于设定扫描路径，次注解只能添加一次，多个数据请用数组格式</p><pre class="line-numbers language-none"><code class="language-none">@ComponentScan(&#123;&quot;com.itheima.service&quot;,&quot;com.itheima.dao&quot;&#125;)</code></pre></li></ul><h3 id="注解开发小结"><a href="#注解开发小结" class="headerlink" title="注解开发小结"></a>注解开发小结</h3><p>1.定义bean</p><ul><li>@Component<ul><li>@Controller</li><li>@Service</li><li>@Repository</li></ul></li><li>&lt;context:component-scan&#x2F;&gt;</li></ul><p>2.纯注解开发</p><ul><li>@Configuration</li><li>@ComponentScan</li><li>AnnotationConfigApplicationContext</li></ul><h3 id="bean作用范围与生命周期管理"><a href="#bean作用范围与生命周期管理" class="headerlink" title="bean作用范围与生命周期管理"></a>bean作用范围与生命周期管理</h3><ul><li>使用@Scope定义bean作用范围</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Repository@Scope(&quot;singleton&quot;)public class BookDaoImpl implements BookDao&#123;&#125;</code></pre><p>使用@PostConstruct、@PreDestroy定义bean生命周期</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Repository@Scope(&quot;singleton&quot;)public class BookDaoImpl implements BookDao&#123;public BookDaoImpl()&#123;System.out.println(&quot;book dao constructor ...&quot;);&#125;    @PostConstruct    public void init()&#123;        System.out.println(&quot;book init ...&quot;);    &#125;    @PreDestroy    public void destroy()&#123;        System.out.println(&quot;book destroy ...&quot;)    &#125;&#125;</code></pre><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><ul><li>使用@Autowired注解开发自动装配模式(按类型)</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class bookServiceImpl implements BookService&#123;@Autowiredprivate BookDao bookDao;public void save()&#123;System.out.println(&quot;book service save ...&quot;);bookDao.save();&#125;&#125;</code></pre><ul><li>注意：自动装配基于反射设计创建对象并暴力反射对应属性为私有属性初始化数据，隐藏无需提供setter方法</li><li>注意：自动装配建议使用无参构造方法创建对象(默认)，如果不提供对应构造对象，请提供唯一的构造方法</li></ul><hr><ul><li>使用@Qualifier注解开启指定名称装配bean</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class BookServiceImpl implements BookService &#123;    &#x2F;&#x2F;@Autowired：注入引用类型，自动装配模式，默认按类型装配    @Autowired    &#x2F;&#x2F;@Qualifier：自动装配bean时按bean名称装配    @Qualifier(&quot;bookDao&quot;)    private BookDao bookDao;    public void save() &#123;        System.out.println(&quot;book service save ...&quot;);        bookDao.save();    &#125;&#125;</code></pre><ul><li>注意：@Qualifier注解无法单独使用，必须配合@Autowired注解使用</li></ul><hr><ul><li>使用@Value实现简单类型注入</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Repository(&quot;bookDao&quot;)public class BookDaoImpl implements BookDao &#123;    &#x2F;&#x2F;@Value：注入简单类型（无需提供set方法）    @Value(&quot;Hello World&quot;)    private String name;    public void save() &#123;        System.out.println(&quot;book dao save ...&quot; + name);    &#125;&#125;</code></pre><hr><h4 id="加载properties文件-1"><a href="#加载properties文件-1" class="headerlink" title="加载properties文件"></a>加载properties文件</h4><ul><li>使用@PropertySource注解加载properties文件</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration@ComponentScan(&quot;com.itheima&quot;)@PropertySource(&quot;classpath:jdbc.properties&quot;)public class SpringConfig&#123;&#125;</code></pre><ul><li>注意：路径仅支持单一文件配置，多文件请使用数组格式配置，不允许使用通配符*</li></ul><h3 id="第三方bean"><a href="#第三方bean" class="headerlink" title="第三方bean"></a>第三方bean</h3><h4 id="第三方bean管理"><a href="#第三方bean管理" class="headerlink" title="第三方bean管理"></a>第三方bean管理</h4><ul><li>使用@bean配置第三方bean</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class SpringConfig &#123;    @Bean    public DataSource dataSource()&#123;        DruidDataSource ds &#x3D; new DruidDataSource();        ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);      ds.setUrl(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;spring_db&quot;);        ds.setUsername(&quot;root&quot;);        ds.setPassword(&quot;1234&quot;);        return ds;    &#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220731161957.png"></p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220731162026.png"></p><p><strong>建议使用方式一，因为方式二看不出你用过哪些配置类</strong></p><h4 id="第三方bean依赖注入"><a href="#第三方bean依赖注入" class="headerlink" title="第三方bean依赖注入"></a>第三方bean依赖注入</h4><ul><li>简单类型依赖注入</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class JdbcConfig &#123;    &#x2F;&#x2F;1.定义一个方法获得要管理的对象    @Value(&quot;com.mysql.jdbc.Driver&quot;)    private String driver;    @Value(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;spring_db&quot;)    private String url;    @Value(&quot;root&quot;)    private String userName;    @Value(&quot;root&quot;)    private String password;    &#x2F;&#x2F;2.添加@Bean，表示当前方法的返回值是一个bean    &#x2F;&#x2F;@Bean修饰的方法，形参根据类型自动装配    @Bean    public DataSource dataSource(BookDao bookDao)&#123;        System.out.println(bookDao);        DruidDataSource ds &#x3D; new DruidDataSource();        ds.setDriverClassName(driver);        ds.setUrl(url);        ds.setUsername(userName);        ds.setPassword(password);        return ds;    &#125;&#125;</code></pre><ul><li>引用类型依赖注入</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Bean   public DataSource dataSource(BookDao bookDao)&#123;       System.out.println(bookDao);       DruidDataSource ds &#x3D; new DruidDataSource();       ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);       ds.setUrl(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;spring_db&quot;);       ds.setUsername(&quot;root&quot;);       ds.setPassword(&quot;1234&quot;);       return ds;   &#125;</code></pre><p><strong>引用类型注入只需要为bean定义方法设置形参即可，容器会根据类型自动装配对象</strong></p><h2 id="注解开发总结"><a href="#注解开发总结" class="headerlink" title="注解开发总结"></a>注解开发总结</h2><h3 id="XML配置对比注解配置"><a href="#XML配置对比注解配置" class="headerlink" title="XML配置对比注解配置"></a>XML配置对比注解配置</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220731163956.png"></p><h2 id="Spring整合mybatis"><a href="#Spring整合mybatis" class="headerlink" title="Spring整合mybatis"></a>Spring整合mybatis</h2><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220802102910.png"></p><p>![](<a class="link"   href="https://raw.githubusercontent.com/2295237514/image/main/20220802102956.png" >https://raw.githubusercontent.com/2295237514/image/main/20220802102956.png<i class="fas fa-external-link-alt"></i></a></p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220802103421.png"></p><p><strong>Spring应该管理的bean是SqlsessionFactory</strong></p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220802153323.png"></p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220802153412.png"></p><h2 id="Spring整合junit"><a href="#Spring整合junit" class="headerlink" title="Spring整合junit"></a>Spring整合junit</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;设置类运行器@RunWith(SpringJUnit4ClassRunner.class)&#x2F;&#x2F;设置Spring环境对应的配置类@ContextConfiguration(classes &#x3D; SpringConfig.class)public class AccountServiceTest &#123;    &#x2F;&#x2F;支持自动装配注入bean    @Autowired    private AccountService accountService;    @Test    public void testFindById()&#123;        System.out.println(accountService.findById(1));    &#125;&#125;</code></pre><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><ul><li><p>AOP(Aspect Oriented Programming)面向切面编程，一种编程范式，指导开发者如何组织程序结构</p><ul><li>OOP（Object Oriented Programming）面向对象编程</li></ul></li><li><p>作用：在<em>不惊动原始设计的基础上</em>为其进行<em>功能增强</em></p></li><li><p>Spring理念：无入侵式&#x2F;无侵入式</p></li></ul><h3 id="AOP核心概念"><a href="#AOP核心概念" class="headerlink" title="AOP核心概念"></a>AOP核心概念</h3><ul><li>连接点(JoinPoint):程序执行过程中的任意位置，粒度为执行方法、抛出异常、设置变量等<ul><li>在SpringAop中，理解为方法的执行</li></ul></li><li>切入点（Pointcut）：匹配连接点的式子<ul><li>在SpringAOP中，一个切入点可以只描述一个具体方法，也可以匹配多个方法<ul><li>一个具体方法</li><li>匹配多个方法：所有的save方法，所有的get开头的方法，所有以D奥结尾的接口中的任意方法，所有带有一个参数的方法</li></ul></li></ul></li><li>通知（Advice）：在切入点处执行的操作，也就是共性功能<ul><li>在SpringAOP中，功能最终以方法的形式呈现</li></ul></li><li>通知类：定义通知的类</li><li>切面(Aspect)：描述通知与切入点的对应关系</li><li>目标对象（Target）：原始功能去掉共性功能对应的类产生的对象，这种对象是无法完成最终工作的</li><li>代理（Proxy）：目标对象无法直接完成工作，需要对其进行功能回填，通过原始对象的代理对象实现</li></ul><h3 id="AOP入门案例思路分析"><a href="#AOP入门案例思路分析" class="headerlink" title="AOP入门案例思路分析"></a>AOP入门案例思路分析</h3><p>开发模式：XML 或 <strong>注解</strong></p><p>思路分析：</p><p>1.导入坐标（pom.xml）</p><p>2.制作连接点方法（原始操作，Dao接口与实现类）</p><p>3.制作共性功能（通知类与通知）</p><p>4.定义切入点</p><p>5.绑定切入点与通知关系（切面）</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>1.导入aop相关坐标</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependency&gt;      &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt;      &lt;artifactId&gt;aspectjweaver&lt;&#x2F;artifactId&gt;      &lt;version&gt;1.9.4&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;</code></pre><p>2.定义dao接口与实现类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface BookDao &#123;    public void save();    public void update();&#125;</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Repositorypublic class BookDaoImpl implements BookDao &#123;    public void save() &#123;        System.out.println(System.currentTimeMillis());        System.out.println(&quot;book dao save ...&quot;);    &#125;    public void update()&#123;        System.out.println(&quot;book dao update ...&quot;);    &#125;&#125;</code></pre><p>3.定义通知类和切入点</p><p><strong>说明：切入点定义依托一个不具有实际意义的方法进行，即无参数，无返回值，方法体无实际逻辑</strong>,</p><p>4.最后绑定切入点与通知关系，并指定通知添加到原始连接点的具体执行位置</p><p>5.定义通知类受Spring容器管理，并定义当前类为切面类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Component&#x2F;&#x2F;设置当前类为切面类类@Aspectpublic class MyAdvice &#123;    &#x2F;&#x2F;设置切入点，要求配置在方法上方    @Pointcut(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)    private void pt()&#123;&#125;    &#x2F;&#x2F;设置在切入点pt()的前面运行当前操作（前置通知）    &#x2F;&#x2F; @Before(&quot;pt()&quot;)    public void method()&#123;        System.out.println(System.currentTimeMillis());    &#125;&#125;</code></pre><p>6.开启Spring对AOP注解驱动支持</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration@ComponentScan(&quot;com.itheima&quot;)&#x2F;&#x2F;开启注解开发AOP功能@EnableAspectJAutoProxypublic class SpringConfig &#123;&#125;</code></pre><h3 id="AOP工作流程"><a href="#AOP工作流程" class="headerlink" title="AOP工作流程"></a>AOP工作流程</h3><p>1.Spring容器启动</p><p>2.读取所有切面配置中的切入点</p><p>3.初始化bean，判定bean对应的类中的方法是否匹配到任意切入点</p><ul><li>匹配失败，创建对象</li><li>匹配成功，创建原始对象(目标对象)的代理对象</li></ul><p>4.获取bean执行方法</p><ul><li>获取bean，调用方法并执行，完成操作</li><li>获取的bean是代理对象时，根据代理对象的运行模式运行原始方法与增强的内容，完成操作</li></ul><h3 id="AOP切入点表达式"><a href="#AOP切入点表达式" class="headerlink" title="AOP切入点表达式"></a>AOP切入点表达式</h3><ul><li>切入点：要进行增强的方法</li><li>切入点表达式：要进行增强的方法的描述方法</li></ul><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220803103702.png"></p><ul><li>切入点表达式标准格式：动作关键字(访问修饰符 返回值 包名.类&#x2F;接口名.方法名(参数)异常名)</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">execution(public User com.itheima.service.UserService.findById(int))</code></pre><ul><li>动作关键字：描述切入点的行为动作，例如execution表示执行到指定切入点</li><li>访问修饰符：public，private等，可以省略</li><li>返回值</li><li>包名</li><li>类&#x2F;接口名</li><li>方法名</li><li>参数</li><li>异常名：方法定义中抛出指定异常，可以省略</li></ul><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220803150303.png"></p><p>*****：必有最少一个</p><p><strong>..</strong>:可以没有，也可以有任意个</p><h4 id="书写技巧"><a href="#书写技巧" class="headerlink" title="书写技巧"></a>书写技巧</h4><ul><li><p>所有代码按照规范标准开发，否则以下技巧全部失效</p></li><li><p>描述切入点<strong>通常描述接口</strong>，而不描述实现类</p></li><li><p>访问控制修饰符针对接口开发均采用public描述(<strong>可省略访问控制修饰符描述</strong>)</p></li><li><p>返回值类型对于增删改类使用精准类型加速匹配，对于查询类使用*通配快速描述</p></li><li><p><strong>包名</strong>书写尽量不使用**..*<em>匹配，效率过低，常用</em>做单个包描述匹配，或精准匹配</p></li><li><p><strong>接口名</strong>&#x2F;类型书写名称与模块相关的<strong>采用*匹配</strong>，例如UserService书写成*Service，绑定业务层接口</p></li><li><p><strong>方法名</strong>书写以<strong>动词</strong>进行<strong>精准匹配</strong>，名次采用*匹配，例如getById书写成getBy*</p></li><li><p>参数规则较为复杂，根据业务方法灵活调整</p></li><li><p>通常不适用异常作为匹配规则</p></li></ul><h3 id="AOP通知类型"><a href="#AOP通知类型" class="headerlink" title="AOP通知类型"></a>AOP通知类型</h3><ul><li><p>AOP通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置</p></li><li><p>AOP通知共分为5种类型</p><ul><li>前置通知 @Before</li><li>后置通知 @After</li><li>环绕通知（重点） @Around</li></ul><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220803174820.png"></p><ul><li>返回后通知（了解）@AfterReturning</li><li>抛出异常后通知（了解）@AfterThrowing</li></ul></li></ul><h3 id="案例：测量业务层接口执行效率"><a href="#案例：测量业务层接口执行效率" class="headerlink" title="案例：测量业务层接口执行效率"></a>案例：测量业务层接口执行效率</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Component@Aspectpublic class ProjectAdvice &#123;    &#x2F;&#x2F;匹配业务层的所有方法    @Pointcut(&quot;execution(* com.itheima.service.*Service.*(..))&quot;)    private void servicePt()&#123;&#125;    &#x2F;&#x2F;设置环绕通知，在原始操作的运行前后记录执行时间    @Around(&quot;ProjectAdvice.servicePt()&quot;)    public void runSpeed(ProceedingJoinPoint pjp) throws Throwable &#123;        &#x2F;&#x2F;获取执行的签名对象        Signature signature &#x3D; pjp.getSignature();        String className &#x3D; signature.getDeclaringTypeName();        String methodName &#x3D; signature.getName();        long start &#x3D; System.currentTimeMillis();        for (int i &#x3D; 0; i &lt; 10000; i++) &#123;           pjp.proceed();        &#125;        long end &#x3D; System.currentTimeMillis();        System.out.println(&quot;万次执行：&quot;+ className+&quot;.&quot;+methodName+&quot;----&gt;&quot; +(end-start) + &quot;ms&quot;);    &#125;&#125;</code></pre><h3 id="AOP通知获取数据"><a href="#AOP通知获取数据" class="headerlink" title="AOP通知获取数据"></a>AOP通知获取数据</h3><ul><li>获取切入点方法的参数、<ul><li>JoinPoint：适用于前置、后置、返回后、抛出异常后通知</li><li>ProceedJoinPoint：适用于环绕通知</li><li><img src="https://raw.githubusercontent.com/2295237514/image/main/20220809095445.png"></li></ul></li><li>获取切入点方法返回值<ul><li>返回后通知</li><li>环绕通知</li><li><img src="https://raw.githubusercontent.com/2295237514/image/main/20220809095515.png"></li></ul></li><li>获取切入点方法运行异常信息<ul><li>抛出异常后通知</li><li>环绕通知</li><li><img src="https://raw.githubusercontent.com/2295237514/image/main/20220809095551.png"></li></ul></li></ul><h3 id="AOP总结"><a href="#AOP总结" class="headerlink" title="AOP总结"></a>AOP总结</h3><ul><li><p>概念：AOP面向切面编程，一种编程范式</p></li><li><p>作用：在不惊动原始设计的基础上为方法进行功能增强</p></li><li><p>核心概念：</p><ul><li><p>代理：SpringAOP的核心本质是采用代理模式实现的</p></li><li><p>连接点：在SpringAOP中，理解为任意方法的执行</p></li><li><p>切入点：匹配连接点的式子，也是具有共性功能的方法描述</p><ul><li><p>切入点表达式标准格式：动作关键字（访问修饰符  返回值  包名.类&#x2F;接口名.方法名（参数）异常名）</p><ul><li>execution(* com.itheima.service.*Service.*(..))</li></ul></li><li><p>切入点表达式描述通配符：</p><ul><li>作用：用于快速描述，范围描述</li><li>*：匹配任意符号（常用）</li><li>..：匹配多个连续的任意符号(常用)</li><li>+：匹配子类类型</li></ul></li><li><p>切入点表达式书写技巧</p><p>1.按标准规范开发</p><p>2.查询操作的返回值建议使用*匹配</p><p>3.减少使用..的形式描述包</p><p>4.对接口进行描述，使用*表示模块名，例如UserService的匹配描述为*Service</p><p>5.方法名书写保留动词，例如get,使用*表示名词，例如getById匹配描述为*getBy*</p><p>6.参数根据实际情况灵活调整</p></li></ul></li><li><p>通知：若干个方法的共性功能，在切入点处执行，具体体现为一个方法</p><ul><li>环绕通知：<ul><li>环绕通知依赖形参ProceedingJoinPoint才能实现对原始方法的调用</li><li>环绕通知可以隔离原始方法的调用执行</li><li>环绕通知返回值设置为Object类型</li><li>环绕通知中可以对原始方法调用过程中出现的异常进行处理</li></ul></li></ul></li><li><p>切面：描述通知与切入点的对应关系</p></li><li><p>目标对象：被代理的原始对象称为目标对象</p></li></ul></li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ul><li>Spirng事务作用：在数据层或业务层保障一系列的数据库操作同成功同失败</li></ul><h3 id="案例：银行账户转账"><a href="#案例：银行账户转账" class="headerlink" title="案例：银行账户转账"></a>案例：银行账户转账</h3><p>1.在业务层接口上添加Spring事务管理</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface AccountService&#123;@Transactionalpublic void transfer(String out,String in,Double money);&#125;</code></pre><p><strong>注意事项</strong></p><ul><li><p><em>Spring注解式事务通常添加在业务层接口中而不会添加到业务层实现类中，降低耦合</em></p></li><li><p><em>注解式事务可以添加到业务方法上表示当前方法开启事务，也可以添加到接口上表示当前接口所有方法开启事务</em></p></li></ul><p>2.设置事务管理器</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Beanpublic PlatformTransactionManager transactionManager(DataSource dataSource)&#123;DataSourceTransactionManager ptm &#x3D; new DataSourceTransactionManager();ptm.setDataSource(dataSource);    return ptm;&#125;</code></pre><p><strong>注意事项</strong></p><ul><li><p><em>事务管理器要根据实现技术进行选择</em></p></li><li><p><em>MyBatis框架使用的是JDBC事务</em></p></li></ul><p>3.开启注解式事务驱动</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration@ComponentScan(&quot;com.itheima&quot;)@PropertySource(&quot;classpath:jdbc.properties&quot;)@Import(&#123;JdbcConfig.class,MybatisConfig.class&#125;)&#x2F;&#x2F;开启注解式事务驱动@EnableTransactionManagementpublic class SpringConfig &#123;&#125;</code></pre><h3 id="Spring事务角色"><a href="#Spring事务角色" class="headerlink" title="Spring事务角色"></a>Spring事务角色</h3><ul><li>事务管理员：发起事务方，在Spring中通常指代业务层开启事务的方法</li><li>事务协调员：加入事务方，在Spring中通常代指数据层方法，也可以是业务层方法</li></ul><h3 id="事务相关配置"><a href="#事务相关配置" class="headerlink" title="事务相关配置"></a>事务相关配置</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220810100955.png"></p><p>有些异常默认事务不回滚，如<em>IOEXCEPTION</em>需手动设置<strong>roolbackFor</strong>属性</p><h3 id="案例：转账业务追加日志"><a href="#案例：转账业务追加日志" class="headerlink" title="案例：转账业务追加日志"></a>案例：转账业务追加日志</h3><p>1.在业务层接口上添加Spring事务，设置事务传播行为REQUIRES_NEW(需要新事物)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class LogServiceImpl implements LogService &#123;    @Autowired    private LogDao logDao;    @Transactional(propagation &#x3D; Propagation.REQUIRES_NEW)    public void log(String out,String in,Double money ) &#123;        logDao.log(&quot;转账操作由&quot;+out+&quot;到&quot;+in+&quot;,金额：&quot;+money);    &#125;&#125;</code></pre><h3 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220810103946.png"></p><h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><ul><li>SpringMVC技术与Servlet技术功能等同，均属于web层开发技术</li><li>SpringMVC是一种基于java实现MVC模型的轻量级Web框架</li><li>优点<ul><li>使用简单，开发便捷（相比于Servlet）</li><li>灵活性强</li></ul></li></ul><p><em>学习目标：</em></p><p><strong>1.掌握基于SpringMVC获取请求参数与响应json数据操作</strong></p><p><strong>2.熟练应用基于REST风格的请求路径设置与参数传递</strong></p><p>3.能够根据实际业务简历前后端开发通讯协议并进行实现</p><p><strong>4.基于SSM整合技术开发任意业务模块功能</strong></p><h2 id="SpringMVC入门案例"><a href="#SpringMVC入门案例" class="headerlink" title="SpringMVC入门案例"></a>SpringMVC入门案例</h2><p>1.使用SpringMVC技术需要先导入SpringMVC坐标与Servlet坐标</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependency&gt;      &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;      &lt;artifactId&gt;javax.servlet-api&lt;&#x2F;artifactId&gt;      &lt;version&gt;3.1.0&lt;&#x2F;version&gt;      &lt;scope&gt;provided&lt;&#x2F;scope&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;      &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;      &lt;version&gt;5.2.10.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre><p>2.创建SpringMVC控制器类（等同于Servlet功能）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controllerpublic class UserController &#123;    @RequestMapping(&quot;&#x2F;save&quot;)    @ResponseBody    public String save()&#123;        System.out.println(&quot;user save ...&quot;);        return &quot;&#123;&#39;info&#39;:&#39;springmvc&#39;&#125;&quot;;    &#125;&#125;</code></pre><p>3.初始化SpringMVC环境（同Spring环境），设定SpringMVC加载对应的bean</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration@ComponentScan(&quot;com.itheima.controller&quot;)public class SpringMvcConfig&#123;&#125;</code></pre><ul><li>知识点1：@Controller</li></ul><table><thead><tr><th>名称</th><th>@Controller</th></tr></thead><tbody><tr><td>类型</td><td>类注解</td></tr><tr><td>位置</td><td>SpringMVC控制器类定义上方</td></tr><tr><td>作用</td><td>设定SpringMVC的核心控制器bean</td></tr></tbody></table><ul><li>知识点2：@RequestMapping</li></ul><table><thead><tr><th>名称</th><th>@RequestMapping</th></tr></thead><tbody><tr><td>类型</td><td>类注解或方法注解</td></tr><tr><td>位置</td><td>SpringMVC控制器类或方法定义上方</td></tr><tr><td>作用</td><td>设置当前控制器方法请求访问路径</td></tr><tr><td>相关属性</td><td>value(默认)，请求访问路径</td></tr></tbody></table><ul><li>知识点3：@ResponseBody</li></ul><table><thead><tr><th>名称</th><th>@ResponseBody</th></tr></thead><tbody><tr><td>类型</td><td>类注解或方法注解</td></tr><tr><td>位置</td><td>SpringMVC控制器类或方法定义上方</td></tr><tr><td>作用</td><td>设置当前控制器方法响应内容为当前返回值，无需解析</td></tr></tbody></table><p><strong>注意事项</strong></p><ul><li>SpringMVC是基于Spring的，在pom.xml只导入了<code>spring-webmvc</code>jar包的原因是它会自动依赖spring相关坐标</li><li>AbstractDispatcherServletInitializer类是SpringMVC提供的快速初始化Web3.0容器的抽象类</li><li>AbstractDispatcherServletInitializer提供了三个接口方法供用户实现<ul><li>createServletApplicationContext方法，创建Servlet容器时，加载SpringMVC对应的bean并放入WebApplicationContext对象范围中，而WebApplicationContext的作用范围为ServletContext范围，即整个web容器范围</li><li>getServletMappings方法，设定SpringMVC对应的请求映射路径，即SpringMVC拦截哪些请求</li><li>createRootApplicationContext方法，如果创建Servlet容器时需要加载非SpringMVC对应的bean,使用当前方法进行，使用方式和createServletApplicationContext相同。</li><li>createServletApplicationContext用来加载SpringMVC环境</li><li>createRootApplicationContext用来加载Spring环境</li></ul></li></ul><h2 id="入门案例工作流程分析"><a href="#入门案例工作流程分析" class="headerlink" title="入门案例工作流程分析"></a>入门案例工作流程分析</h2><ul><li><p>启动服务器初始化过程</p><p>1.服务器启动，执行ServletContainerInitConfig类，初始化web容器</p><p>2.执行createServletApplicationContext方法，创建了WebApplicationContext对象</p><p>3.加载SpringMvcConfig</p><p>4.执行@ComponentScan加载对应的bean</p><p>5.加载UserController，每个@RequestMapping的名称对应一个具体的方法</p><p>6.执行getServletMappings方法，定义所有的请求都通过SpringMVC</p></li><li><p>单次请求过程</p><p>1.发送请求localhost&#x2F;save</p><p>2.web容器发现所有请求都经过SpringMVC，将请求交给SpringMVC处理</p><p>3.解析请求路径&#x2F;save</p><p>4.由&#x2F;save匹配执行对应的方法save()</p><p>5.执行save()</p><p>6.检测到有@ResponseBody直接将save()方法的返回值作为响应体返回给请求方</p></li></ul><h3 id="bean加载控制"><a href="#bean加载控制" class="headerlink" title="bean加载控制"></a>bean加载控制</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220811093412.png"></p><p>方式一:修改Spring配置类，设定扫描范围为精准范围。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration@ComponentScan(&#123;&quot;com.itheima.service&quot;,&quot;comitheima.dao&quot;&#125;)public class SpringConfig &#123;&#125;</code></pre><p>方式二:修改Spring配置类，设定扫描范围为com.itheima,排除掉controller包中的bean</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration@ComponentScan(value&#x3D;&quot;com.itheima&quot;,    excludeFilters&#x3D;@ComponentScan.Filter(    type &#x3D; FilterType.ANNOTATION,        classes &#x3D; Controller.class    ))public class SpringConfig &#123;&#125;</code></pre><ul><li>excludeFilters属性：设置扫描加载bean时，排除的过滤规则</li></ul><hr><p>bean的加载格式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ServletContainersInitConfig extends AbstractDispatcherServletInitializer &#123;    protected WebApplicationContext createServletApplicationContext() &#123;        AnnotationConfigWebApplicationContext ctx &#x3D; new AnnotationConfigWebApplicationContext();        ctx.register(SpringMvcConfig.class);        return ctx;    &#125;    protected String[] getServletMappings() &#123;        return new String[]&#123;&quot;&#x2F;&quot;&#125;;    &#125;    protected WebApplicationContext createRootApplicationContext() &#123;      AnnotationConfigWebApplicationContext ctx &#x3D; new AnnotationConfigWebApplicationContext();        ctx.register(SpringConfig.class);        return ctx;    &#125;&#125;</code></pre><p>对于上述的配置方式，Spring还提供了一种更简单的配置方式，可以不用再去创建<code>AnnotationConfigWebApplicationContext</code>对象，不用手动<code>register</code>对应的配置类，如何实现?</p><p><strong>简化开发的格式</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123;    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;        return new Class[]&#123;SpringConfig.class&#125;;    &#125;    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;        return new Class[]&#123;SpringMvcConfig.class&#125;;    &#125;    protected String[] getServletMappings() &#123;        return new String[]&#123;&quot;&#x2F;&quot;&#125;;    &#125;&#125;</code></pre><h2 id="请求与响应"><a href="#请求与响应" class="headerlink" title="请求与响应"></a>请求与响应</h2><h3 id="请求映射路径"><a href="#请求映射路径" class="headerlink" title="请求映射路径"></a>请求映射路径</h3><p><strong>优化映射路径</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controller@RequestMapping(&quot;&#x2F;user&quot;)public class UserController &#123;    @RequestMapping(&quot;&#x2F;save&quot;)    @ResponseBody    public String save()&#123;        System.out.println(&quot;user save ...&quot;);        return &quot;&#123;&#39;module&#39;:&#39;user save&#39;&#125;&quot;;    &#125;        @RequestMapping(&quot;&#x2F;delete&quot;)    @ResponseBody    public String save()&#123;        System.out.println(&quot;user delete ...&quot;);        return &quot;&#123;&#39;module&#39;:&#39;user delete&#39;&#125;&quot;;    &#125;&#125;@Controller@RequestMapping(&quot;&#x2F;book&quot;)public class BookController &#123;    @RequestMapping(&quot;&#x2F;save&quot;)    @ResponseBody    public String save()&#123;        System.out.println(&quot;book save ...&quot;);        return &quot;&#123;&#39;module&#39;:&#39;book save&#39;&#125;&quot;;    &#125;&#125;</code></pre><p><strong>注意:</strong></p><ul><li>当类上和方法上都添加了<code>@RequestMapping</code>注解，前端发送请求的时候，要和两个注解的value值相加匹配才能访问到。</li><li>@RequestMapping注解value属性前面加不加<code>/</code>都可以</li></ul><h3 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h3><ul><li>Get请求</li><li>Post请求</li></ul><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220812162630.png"></p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220812162724.png"></p><p><em>Post请求中文乱码处理</em></p><ul><li>为web容器添加过滤器并指定字符集，Spring-web包中提供了专用的字符过滤器</li></ul><p>解决方法：配置过滤器</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123;    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;        return new Class[0];    &#125;    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;        return new Class[]&#123;SpringMvcConfig.class&#125;;    &#125;    protected String[] getServletMappings() &#123;        return new String[]&#123;&quot;&#x2F;&quot;&#125;;    &#125;    &#x2F;&#x2F;乱码处理    @Override    protected Filter[] getServletFilters() &#123;        CharacterEncodingFilter filter &#x3D; new CharacterEncodingFilter();        filter.setEncoding(&quot;UTF-8&quot;);        return new Filter[]&#123;filter&#125;;    &#125;&#125;</code></pre><hr><p>发送请求与参数:</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;localhost&#x2F;commonParamDifferentName?name&#x3D;张三&amp;age&#x3D;18</code></pre><p>后台接收参数:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(&quot;&#x2F;commonParamDifferentName&quot;)@ResponseBodypublic String commonParamDifferentName(String userName , int age)&#123;    System.out.println(&quot;普通参数传递 userName &#x3D;&#x3D;&gt; &quot;+userName);    System.out.println(&quot;普通参数传递 age &#x3D;&#x3D;&gt; &quot;+age);    return &quot;&#123;&#39;module&#39;:&#39;common param different name&#39;&#125;&quot;;&#125;</code></pre><p>因为前端给的是<code>name</code>,后台接收使用的是<code>userName</code>,两个名称对不上，导致接收数据失败:</p><p>解决方案:使用@RequestParam注解</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(&quot;&#x2F;commonParamDifferentName&quot;)    @ResponseBody    public String commonParamDifferentName(@RequestPaam(&quot;name&quot;) String userName , int age)&#123;        System.out.println(&quot;普通参数传递 userName &#x3D;&#x3D;&gt; &quot;+userName);        System.out.println(&quot;普通参数传递 age &#x3D;&#x3D;&gt; &quot;+age);        return &quot;&#123;&#39;module&#39;:&#39;common param different name&#39;&#125;&quot;;    &#125;</code></pre><p><strong>用集合接收前台参数也需要@RequestParam注解</strong></p><hr><h3 id="日期类型参数传递"><a href="#日期类型参数传递" class="headerlink" title="日期类型参数传递"></a>日期类型参数传递</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220813105417.png"></p><h3 id="类型转换器"><a href="#类型转换器" class="headerlink" title="类型转换器"></a>类型转换器</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220813105817.png"></p><h3 id="json数据"><a href="#json数据" class="headerlink" title="json数据"></a>json数据</h3><h4 id="接受请求中json数据"><a href="#接受请求中json数据" class="headerlink" title="接受请求中json数据"></a>接受请求中json数据</h4><p>1.添加json数据转换相关坐标</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;jackson-databind&lt;&#x2F;artifactId&gt;    &lt;version&gt;2.9.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre><p>2.设置发送json数据(请求body中添加json数据)</p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220813101224.png"></p><p>3.开启自动转换json数据的支持</p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220813101309.png"></p><p>4.设置接收json数据</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;使用@RequestBody注解将外部传递的json数组数据映射到形参的集合对象中作为数据    @RequestMapping(&quot;&#x2F;listParamForJson&quot;)    @ResponseBody    public String listParamForJson(@RequestBody List&lt;String&gt; likes)&#123;        System.out.println(&quot;list common(json)参数传递 list &#x3D;&#x3D;&gt; &quot;+likes);        return &quot;&#123;&#39;module&#39;:&#39;list common for json param&#39;&#125;&quot;;    &#125;</code></pre><p><strong>@RequestBody一个处理器方法只能使用一次</strong></p><hr><p>@RequestBody与@RequestParam区别</p><ul><li>区别<ul><li>@RequestParam用于接收url地址传参，表单传参</li><li>@RequestBody用于接收json数据</li></ul></li><li>应用<ul><li>后期开发中，发送json格式数据为主，@RequestBody应用较广</li><li>如果发送非json格式数据，选用@RequestParam接收请求参数</li></ul></li></ul><table><thead><tr><th>名称</th><th>@ResponseBody</th></tr></thead><tbody><tr><td>类型</td><td>&#x3D;&#x3D;方法\类注解&#x3D;&#x3D;</td></tr><tr><td>位置</td><td>SpringMVC控制器方法定义上方和控制类上</td></tr><tr><td>作用</td><td>设置当前控制器返回值作为响应体,<br/>写在类上，该类的所有方法都有该注解功能</td></tr><tr><td>相关属性</td><td>pattern：指定日期时间格式字符串</td></tr></tbody></table><p><strong>说明:</strong></p><ul><li>该注解可以写在类上或者方法上</li><li>写在类上就是该类下的所有方法都有@ReponseBody功能</li><li>当方法上有@ReponseBody注解后<ul><li>方法的返回值为字符串，会将其作为文本内容直接响应给前端</li><li>方法的返回值为对象，会将对象转换成JSON响应给前端</li></ul></li></ul><p>此处又使用到了类型转换，内部还是通过Converter接口的实现类完成的，所以Converter除了前面所说的功能外，它还可以实现:</p><ul><li>对象转Json数据(POJO -&gt; json)</li><li>集合转Json数据(Collection -&gt; json)</li></ul><h2 id="Rest"><a href="#Rest" class="headerlink" title="Rest"></a>Rest</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>REST（Representational State Transfer），表现形式状态转换</li></ul><p>当我们想表示一个网络资源的时候，可以使用两种方式:</p><ul><li>传统风格资源描述形式<ul><li><code>http://localhost/user/getById?id=1</code> 查询id为1的用户信息</li><li><code>http://localhost/user/saveUser</code> 保存用户信息</li></ul></li><li>REST风格描述形式<ul><li><code>http://localhost/user/1</code> </li><li><code>http://localhost/user</code></li></ul></li></ul><ul><li>优点：<ul><li>隐藏资源的访问行为，无法通过地址得知对资源是何种操作</li><li>书写简化</li></ul></li></ul><hr><ul><li>按照REST风格访问资源时使用&#x3D;&#x3D;行为动作&#x3D;&#x3D;区分对资源进行了何种操作<ul><li><code>http://localhost/users</code>查询全部用户信息 GET（查询）</li><li><code>http://localhost/users/1</code>  查询指定用户信息 GET（查询）</li><li><code>http://localhost/users</code>    添加用户信息    POST（新增&#x2F;保存）</li><li><code>http://localhost/users</code>    修改用户信息    PUT（修改&#x2F;更新）</li><li><code>http://localhost/users/1</code>  删除用户信息    DELETE（删除）</li></ul></li><li>根据REST风格对资源进行访问称为RESTful</li></ul><p>请求的方式比较多，但是比较常用的就4种，分别是<code>GET</code>,<code>POST</code>,<code>PUT</code>,<code>DELETE</code>。</p><p>按照不同的请求方式代表不同的操作类型。</p><ul><li>发送GET请求是用来做查询</li><li>发送POST请求是用来做新增</li><li>发送PUT请求是用来做修改</li><li>发送DELETE请求是用来做删除</li></ul><pre class="line-numbers language-none"><code class="language-none">注意事项：上述行为是约定方式，约定不是规范，可以打破，所以称REST风格，而不是REST规范描述模块的名字通常使用负数，也就是可以加s的格式描述，表示此类资源，而非单个资源，例如：users、books、account......</code></pre><h3 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220814093052.png"></p><p>(2)如果有多个参数需要传递该如何编写?</p><p>前端发送请求的时候使用:<code>http://localhost/users/1/tom</code>,路径中的<code>1</code>和<code>tom</code>就是我们想要传递的两个参数。</p><p>后端获取参数，需要做如下修改:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controllerpublic class UserController &#123;    &#x2F;&#x2F;设置当前请求方法为DELETE，表示REST风格中的删除操作@RequestMapping(value &#x3D; &quot;&#x2F;users&#x2F;&#123;id&#125;&#x2F;&#123;name&#125;&quot;,method &#x3D; RequestMethod.DELETE)    @ResponseBody    public String delete(@PathVariable Integer id,@PathVariable String name) &#123;        System.out.println(&quot;user delete...&quot; + id+&quot;,&quot;+name);        return &quot;&#123;&#39;module&#39;:&#39;user delete&#39;&#125;&quot;;    &#125;&#125;</code></pre><hr><p>关于接收参数，我们学过三个注解<code>@RequestBody</code>、<code>@RequestParam</code>、<code>@PathVariable</code>,这三个注解之间的区别和应用分别是什么?</p><ul><li>区别<ul><li>@RequestParam用于接收url地址传参或表单传参</li><li>@RequestBody用于接收json数据</li><li>@PathVariable用于接收路径参数，使用{参数名称}描述路径参数</li></ul></li><li>应用<ul><li>后期开发中，发送请求参数超过1个时，以json格式为主，@RequestBody应用较广</li><li>如果发送非json格式数据，选用@RequestParam接收请求参数</li><li>采用RESTful进行开发，当参数数量较少时，例如1个，可以采用@PathVariable接收请求路径变量，通常用于传递id值</li></ul></li></ul><h3 id="RESTful快速开发"><a href="#RESTful快速开发" class="headerlink" title="RESTful快速开发"></a>RESTful快速开发</h3><p>问题1：每个方法的@RequestMapping注解中都定义了访问路径&#x2F;books，重复性太高。</p><p>问题2：每个方法的@RequestMapping注解中都要使用method属性定义请求方式，重复性太高。</p><p>问题3：每个方法响应json都需要加上@ResponseBody注解，重复性太高。</p><p><em>对于刚才的问题，我们都有对应的解决方案：</em></p><p>问题1：每个方法的@RequestMapping注解中都定义了访问路径&#x2F;books，重复性太高。</p><pre class="line-numbers language-none"><code class="language-none">将@RequestMapping提到类上面，用来定义所有方法共同的访问路径。</code></pre><p>问题2：每个方法的@RequestMapping注解中都要使用method属性定义请求方式，重复性太高。</p><pre class="line-numbers language-none"><code class="language-none">使用@GetMapping  @PostMapping  @PutMapping  @DeleteMapping代替</code></pre><p>问题3：每个方法响应json都需要加上@ResponseBody注解，重复性太高。</p><pre class="line-numbers language-none"><code class="language-none">1.将ResponseBody提到类上面，让所有的方法都有@ResponseBody的功能2.使用@RestController注解替换@Controller与@ResponseBody注解，简化书写</code></pre><h4 id="知识点1：-RestController"><a href="#知识点1：-RestController" class="headerlink" title="知识点1：@RestController"></a>知识点1：@RestController</h4><table><thead><tr><th>名称</th><th>@RestController</th></tr></thead><tbody><tr><td>类型</td><td>&#x3D;&#x3D;类注解&#x3D;&#x3D;</td></tr><tr><td>位置</td><td>基于SpringMVC的RESTful开发控制器类定义上方</td></tr><tr><td>作用</td><td>设置当前控制器类为RESTful风格，<br/>等同于@Controller与@ResponseBody两个注解组合功能</td></tr></tbody></table><h4 id="知识点2：-GetMapping-PostMapping-PutMapping-DeleteMapping"><a href="#知识点2：-GetMapping-PostMapping-PutMapping-DeleteMapping" class="headerlink" title="知识点2：@GetMapping @PostMapping @PutMapping @DeleteMapping"></a>知识点2：@GetMapping @PostMapping @PutMapping @DeleteMapping</h4><table><thead><tr><th>名称</th><th>@GetMapping @PostMapping @PutMapping @DeleteMapping</th></tr></thead><tbody><tr><td>类型</td><td>&#x3D;&#x3D;方法注解&#x3D;&#x3D;</td></tr><tr><td>位置</td><td>基于SpringMVC的RESTful开发控制器方法定义上方</td></tr><tr><td>作用</td><td>设置当前控制器方法请求访问路径与请求动作，每种对应一个请求动作，<br/>例如@GetMapping对应GET请求</td></tr><tr><td>相关属性</td><td>value（默认）：请求访问路径</td></tr></tbody></table><h3 id="案例：基于RESTful页面数据交互"><a href="#案例：基于RESTful页面数据交互" class="headerlink" title="案例：基于RESTful页面数据交互"></a>案例：基于RESTful页面数据交互</h3><h5 id="编写Controller类并使用RESTful进行配置"><a href="#编写Controller类并使用RESTful进行配置" class="headerlink" title="编写Controller类并使用RESTful进行配置"></a>编写Controller类并使用RESTful进行配置</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController@RequestMapping(&quot;&#x2F;books&quot;)public class BookController &#123;    @PostMapping    public String save(@RequestBody Book book)&#123;        System.out.println(&quot;book save &#x3D;&#x3D;&gt; &quot;+ book);        return &quot;&#123;&#39;module&#39;:&#39;book save success&#39;&#125;&quot;;    &#125; @GetMapping    public List&lt;Book&gt; getAll()&#123;        System.out.println(&quot;book getAll is running ...&quot;);        List&lt;Book&gt; bookList &#x3D; new ArrayList&lt;Book&gt;();        Book book1 &#x3D; new Book();        book1.setType(&quot;计算机&quot;);        book1.setName(&quot;SpringMVC入门教程&quot;);        book1.setDescription(&quot;小试牛刀&quot;);        bookList.add(book1);        Book book2 &#x3D; new Book();        book2.setType(&quot;计算机&quot;);        book2.setName(&quot;SpringMVC实战教程&quot;);        book2.setDescription(&quot;一代宗师&quot;);        bookList.add(book2);        return bookList;    &#125;&#125;</code></pre><ul><li>SpringMVC需要将静态资源进行放行。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class SpringMvcSupport extends WebMvcConfigurationSupport &#123;    &#x2F;&#x2F;设置静态资源访问过滤，当前类需要设置为配置类，并被扫描加载    @Override    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;        &#x2F;&#x2F;当访问&#x2F;pages&#x2F;????时候，从&#x2F;pages目录下查找内容        registry.addResourceHandler(&quot;&#x2F;pages&#x2F;**&quot;).addResourceLocations(&quot;&#x2F;pages&#x2F;&quot;);        registry.addResourceHandler(&quot;&#x2F;js&#x2F;**&quot;).addResourceLocations(&quot;&#x2F;js&#x2F;&quot;);        registry.addResourceHandler(&quot;&#x2F;css&#x2F;**&quot;).addResourceLocations(&quot;&#x2F;css&#x2F;&quot;);        registry.addResourceHandler(&quot;&#x2F;plugins&#x2F;**&quot;).addResourceLocations(&quot;&#x2F;plugins&#x2F;&quot;);    &#125;&#125;</code></pre><ul><li>该配置类是在config目录下，SpringMVC扫描的是controller包，所以该配置类还未生效，要想生效需要将SpringMvcConfig配置类进行修改</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration@ComponentScan(&#123;&quot;com.itheima.controller&quot;,&quot;com.itheima.config&quot;&#125;)@EnableWebMvcpublic class SpringMvcConfig &#123;&#125;或者@Configuration@ComponentScan(&quot;com.itheima&quot;)@EnableWebMvcpublic class SpringMvcConfig &#123;&#125;</code></pre><h3 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合</h3><p>1.创建工程</p><p>2.SSM整合</p><ul><li><p>Spring</p><ul><li>SpringConfig</li></ul></li><li><p>MyBatis</p><ul><li><p>MybatisConfig</p></li><li><p>JdbcConfig</p></li><li><p>jdbc.properties</p></li></ul></li><li><p>SpringMVC</p><ul><li>ServletConfig</li><li>SpirngMvcConfig</li></ul></li></ul><p>3.功能模块</p><ul><li>表与实现类</li><li>dao(接口+自动代理)</li><li>service(接口+实现类)<ul><li>业务层接口测试(整合JUnit)</li></ul></li><li>controller<ul><li>表现层接口测试(PostMan)</li></ul></li></ul><hr><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220814173947.png"></p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220814174014.png"></p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220814174046.png"></p><h4 id="异常处理器"><a href="#异常处理器" class="headerlink" title="异常处理器"></a>异常处理器</h4><ul><li><p>出现异常现象的常见位置与常见诱因如下：</p><ul><li>框架内部抛出的异常：因使用不合规导致</li><li>数据层抛出的异常：因外部服务器故障导致（例如：服务器访问超时）</li><li>业务层抛出的异常：因业务逻辑书写失败导致（例如：遍历业务书写操作，导致索引异常等）</li><li>表现层抛出的异常：因数据收集、校验等规则导致（例如：不匹配的数据类型间导致异常）</li><li>工具类抛出的异常：因工具类书写不严谨不够健壮导致（例如：必要释放的连接长期未释放导致等）</li></ul></li><li><p><strong>所有异常均抛出到表现层处理</strong></p></li><li><p>对于上面这些问题及解决方案，SpringMVC已经为我们提供了一套解决方案:</p><ul><li><p>对于上面这些问题及解决方案，SpringMVC已经为我们提供了一套解决方案:</p><ul><li><strong>异常处理器:</strong><ul><li>集中的、统一的处理项目中出现的异常。</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestControllerAdvicepublic class ProjectExceptionAdvice &#123;    @ExceptionHandler(Exception.class)    public void doException(Exception ex)&#123;        System.out.println(&quot;出现异常了&quot;);    &#125;&#125;</code></pre></li></ul></li></ul><p>知识点1：@RestControllerAdvice</p><table><thead><tr><th>名称</th><th>@RestControllerAdvice</th></tr></thead><tbody><tr><td>类型</td><td>&#x3D;&#x3D;类注解&#x3D;&#x3D;</td></tr><tr><td>位置</td><td>Rest风格开发的控制器增强类定义上方</td></tr><tr><td>作用</td><td>为Rest风格开发的控制器类做增强</td></tr></tbody></table><p>**说明:**此注解自带@ResponseBody注解与@Component注解，具备对应的功能</p><hr><p>知识点2：@ExceptionHandler</p><table><thead><tr><th>名称</th><th>@ExceptionHandler</th></tr></thead><tbody><tr><td>类型</td><td>&#x3D;&#x3D;方法注解&#x3D;&#x3D;</td></tr><tr><td>位置</td><td>专用于异常处理的控制器方法上方</td></tr><tr><td>作用</td><td>设置指定异常的处理方案，功能等同于控制器方法，<br/>出现异常后终止原始控制器执行,并转入当前方法执行</td></tr></tbody></table><p><strong>说明：</strong>此类方法可以根据处理的异常不同，制作多个方法分别处理对应的异常</p><h4 id="项目异常分类及处理"><a href="#项目异常分类及处理" class="headerlink" title="项目异常分类及处理"></a>项目异常分类及处理</h4><p><strong>项目异常分类</strong></p><ul><li><p>业务异常（BusinessException）</p><ul><li><p>规范的用户行为产生的异常</p><ul><li>用户在页面输入内容的时候未按照指定格式进行数据填写，如在年龄框输入的是字符串</li></ul></li><li><p>不规范的用户行为操作产生的异常</p><ul><li>如用户故意传递错误数据</li></ul></li></ul></li><li><p>系统异常（SystemException）</p><ul><li>项目运行过程中可预计但无法避免的异常<ul><li>比如数据库或服务器宕机</li></ul></li></ul></li><li><p>其他异常（Exception）</p><ul><li>编程人员未预期到的异常，如:用到的文件不存在</li></ul></li></ul><p><strong>处理方案</strong></p><ul><li>业务异常（BusinessException）<ul><li>发送对应消息传递给用户，提醒规范操作<ul><li>大家常见的就是提示用户名已存在或密码格式不正确等</li></ul></li></ul></li><li>系统异常（SystemException）<ul><li>发送固定消息传递给用户，安抚用户<ul><li>系统繁忙，请稍后再试</li><li>系统正在维护升级，请稍后再试</li><li>系统出问题，请联系系统管理员等</li></ul></li><li>发送特定消息给运维人员，提醒维护<ul><li>可以发送短信、邮箱或者是公司内部通信软件</li></ul></li><li>记录日志<ul><li>发消息和记录日志对用户来说是不可见的，属于后台程序</li></ul></li></ul></li><li>其他异常（Exception）<ul><li>发送固定消息传递给用户，安抚用户</li><li>发送特定消息给编程人员，提醒维护（纳入预期范围内）<ul><li>一般是程序没有考虑全，比如未做非空校验等</li></ul></li><li>记录日志</li></ul></li></ul><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><ul><li>拦截器是一种动态拦截方法调用的机制，在SpirngMVC中动态拦截控制器方法的执行</li><li>作用：<ul><li>在指定的方法调用前后执行预先设定的代码</li><li>阻止原始方法的执行</li></ul></li></ul><h4 id="拦截器和过滤器区别"><a href="#拦截器和过滤器区别" class="headerlink" title="拦截器和过滤器区别"></a>拦截器和过滤器区别</h4><ul><li>归属不同：Filter输入Servlet技术，Interceptor呼入SpringMVC技术</li><li>拦截内容不同：Filter对所有访问进行增强，Interceptor仅针对SpringMVC的访问进行增强</li></ul><h4 id="拦截器入门案例"><a href="#拦截器入门案例" class="headerlink" title="拦截器入门案例"></a>拦截器入门案例</h4><ol><li><p>创建拦截器类</p><p>让类实现HandlerInterceptor接口，重写接口中的三个方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Component&#x2F;&#x2F;定义拦截器类，实现HandlerInterceptor接口&#x2F;&#x2F;注意当前类必须受Spring容器控制public class ProjectInterceptor implements HandlerInterceptor &#123;    @Override    &#x2F;&#x2F;原始方法调用前执行的内容    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        System.out.println(&quot;preHandle...&quot;);        return true;    &#125;    @Override    &#x2F;&#x2F;原始方法调用后执行的内容    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;        System.out.println(&quot;postHandle...&quot;);    &#125;    @Override    &#x2F;&#x2F;原始方法调用完成后执行的内容    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;        System.out.println(&quot;afterCompletion...&quot;);    &#125;&#125;</code></pre></li><li><p>配置拦截器类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class SpringMvcSupport extends WebMvcConfigurationSupport &#123;    @Autowired    private ProjectInterceptor projectInterceptor;    @Override    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;        registry.addResourceHandler(&quot;&#x2F;pages&#x2F;**&quot;).addResourceLocations(&quot;&#x2F;pages&#x2F;&quot;);    &#125;    @Override    protected void addInterceptors(InterceptorRegistry registry) &#123;        &#x2F;&#x2F;配置拦截器        registry.addInterceptor(projectInterceptor).addPathPatterns(&quot;&#x2F;books&quot; );    &#125;&#125;</code></pre></li><li><p>SpringMVC添加SpringMvcSupport包扫描</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration@ComponentScan(&#123;&quot;com.itheima.controller&quot;,&quot;com.itheima.config&quot;&#125;)@EnableWebMvcpublic class SpringMvcConfig&#123;   &#125;</code></pre></li></ol><p><strong>简化SpringMvcSupport的编写</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration@ComponentScan(&#123;&quot;com.itheima.controller&quot;&#125;)@EnableWebMvc&#x2F;&#x2F;实现WebMvcConfigurer接口可以简化开发，但具有一定的侵入性public class SpringMvcConfig implements WebMvcConfigurer &#123;    @Autowired    private ProjectInterceptor projectInterceptor;    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        &#x2F;&#x2F;配置多拦截器        registry.addInterceptor(projectInterceptor).addPathPatterns(&quot;&#x2F;books&quot;,&quot;&#x2F;books&#x2F;*&quot;);    &#125;&#125;</code></pre><p><strong>拦截器中的<code>preHandler</code>方法，如果返回true,则代表放行，会执行原始Controller类中要请求的方法，如果返回false，则代表拦截，后面的就不会再执行了。</strong></p><p>当有拦截器后，请求会先进入preHandle方法，</p><p>​如果方法返回true，则放行继续执行后面的handle[controller的方法]和后面的方法</p><p>​如果返回false，则直接跳过后面方法的执行。</p><h4 id="多拦截器执行顺序"><a href="#多拦截器执行顺序" class="headerlink" title="多拦截器执行顺序"></a>多拦截器执行顺序</h4><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220922125322.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a class=&quot;link&quot;   href=&quot;https://spring.io/&quot; &gt;spring官网&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Spring&quot;&gt;&lt;a href=&quot;#Spring&quot; c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机组成原理</title>
    <link href="https://2295237514.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.html"/>
    <id>https://2295237514.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.html</id>
    <published>2022-07-13T13:29:14.000Z</published>
    <updated>2022-07-13T13:50:13.422Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h2><h3 id="1-2-1-冯诺依曼计算机的特点："><a href="#1-2-1-冯诺依曼计算机的特点：" class="headerlink" title="1.2.1 冯诺依曼计算机的特点："></a>1.2.1 冯诺依曼计算机的特点：</h3><ul><li>计算机有哦运算器，存储器，控制器，输入设备和输出设备五大部件组成</li><li>指令和数据以同等地位存放于存储器中，并可按地址寻访</li><li>指令和数据均用二进制数表示</li><li>指令由操作码和地址码组成，操作码用来表示操作的性质，地址码用来表示操作数在存储器中的位置</li><li>指令在存储器内按顺序存放。通常，指令是顺序执行的，在特定条件下，可根据运算结果或根据设定的条件改变执行顺序</li><li>机器以运算器为中心，输入输出设备与存储期间的数据传送通过运算器完成。</li></ul><p><em>相比于经典的冯诺依曼计算机的最后一个特点，现代的计算机已转化为以存储器为中心</em></p><h3 id="1-2-2-计算机的硬件框图"><a href="#1-2-2-计算机的硬件框图" class="headerlink" title="1.2.2 计算机的硬件框图"></a>1.2.2 计算机的硬件框图</h3><p>计算机硬件各部件的功能：</p><ul><li>运算器用来完成算术运算和逻辑运算，并将运算的中间结果暂存在运算器内</li><li>存储器用来存放数据和程序</li><li>控制器用来控制，指挥程序和数据的输入，运行以及处理运算结果</li><li>输入设备用来将人们熟悉的信息形式转化为机器能识别的信息形式，常见的有键盘，鼠标等</li><li>输出设备可将机器运算结果转换为人们熟悉的信息形式，如打印机输出，显示器输出等</li></ul><p><em>计算机的五大部件（又称五大子系统）在控制器的统一指挥下，有条不紊的自动工作</em></p><p>运算器和控制器合起来统称为中央处理器（CPU）</p><p>输入设备与输出设备简称为I&#x2F;O设备</p><p>现代计算机可认为由三大部分组成：CPU，I&#x2F;O设备，主存储器</p><p>CPU和主存储器合起来可称为主机        I&#x2F;O设备又可称为外部设备</p><p>算术逻辑单元（ALU）完成算术逻辑运算</p><p>控制单元（CU）用来结束存储器中的指令，并发出各种操作命令来执行指令</p><h3 id="1-2-3-计算机的工作步骤"><a href="#1-2-3-计算机的工作步骤" class="headerlink" title="1.2.3 计算机的工作步骤"></a>1.2.3 计算机的工作步骤</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h1&gt;&lt;h2 id=&quot;1-2&quot;&gt;&lt;a href=&quot;#1-2&quot; class=&quot;headerlink&quot; title=&quot;1.2&quot;&gt;&lt;/a&gt;1.2&lt;/h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Web核心</title>
    <link href="https://2295237514.github.io/post/Web%E6%A0%B8%E5%BF%83.html"/>
    <id>https://2295237514.github.io/post/Web%E6%A0%B8%E5%BF%83.html</id>
    <published>2022-07-06T06:27:05.000Z</published>
    <updated>2022-07-25T02:35:28.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Web概述"><a href="#Web概述" class="headerlink" title="Web概述"></a>Web概述</h1><h2 id="JavaWeb技术栈"><a href="#JavaWeb技术栈" class="headerlink" title="JavaWeb技术栈"></a>JavaWeb技术栈</h2><ul><li><p>B&#x2F;S架构：Browser&#x2F;Server，浏览器&#x2F;服务器 架构模式，它的特点是，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web资源，服务器把Web资源发送给浏览器即可</p><ul><li>好处：易于维护升级：服务器升级苟，客户端无需任何不输就可以使用到新的版本</li></ul></li><li><p>静态资源：HTML  CSS  JavaScript  图片等。 负责页面展现</p></li><li><p>动态资源：Servlet  Jsp等。 负责逻辑处理</p></li><li><p>数据库：负责存储数据</p></li></ul><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220706143521.png"></p><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><ul><li><p>概念：HyperText  Transfer  Protocol， 超文本传输协议，规定了浏览器和服务器之间数据传输的规则</p></li><li><p>HTTP协议特点：</p><p>1.基于TCP协议：面向连接，安全</p><p>2.基于请求-响应模型：一次请求对应一次响应</p><p>3.HTTP协议是无状态的协议：对于事务处理没有记忆能力。每次请求-响应都是独立的</p><ul><li>缺点：多次请求间不能共享数据       <em>Java中使用会话技术（Cookie、Session）来解决</em></li><li>有点：速度快</li></ul></li></ul><h2 id="请求数据格式"><a href="#请求数据格式" class="headerlink" title="请求数据格式"></a>请求数据格式</h2><ul><li>请求数据分为三部分：</li></ul><p>1.请求行：请求数据的第一行。其中GET表示请求方式，&#x2F;表示请求资源路径，HTTP&#x2F;1.1表示协议版本</p><p>2.请求头：第二行开始，格式为key：value形式，常见的HTTP请求头有:</p><pre class="line-numbers language-none"><code class="language-none">Host: 表示请求的主机名User-Agent: 浏览器版本,例如Chrome浏览器的标识类似Mozilla&#x2F;5.0 ...Chrome&#x2F;79，IE浏览器的标识类似Mozilla&#x2F;5.0 (Windows NT ...)like Gecko；Accept：表示浏览器能接收的资源类型，如text&#x2F;*，image&#x2F;*或者*&#x2F;*表示所有；Accept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页；Accept-Encoding：表示浏览器可以支持的压缩类型，例如gzip, deflate等。</code></pre><p>3.请求体：POST请求的最后一部分，存放请求参数</p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220706151130.png"></p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220706151439.png"></p><h2 id="响应数据格式"><a href="#响应数据格式" class="headerlink" title="响应数据格式"></a>响应数据格式</h2><ul><li><p>1.响应行：响应数据的第一行。其中HTTP&#x2F;1.1表示协议版本，200表示响应状态码，OK表示状态码描述</p></li><li><p>2.响应头：第二行开始，格式为key：value形式，常见的HTTP响应头有:</p><pre class="line-numbers language-none"><code class="language-none">Content-Type：表示该响应内容的类型，例如text&#x2F;html，image&#x2F;jpeg；Content-Length：表示该响应内容的长度（字节数）；Content-Encoding：表示该响应压缩算法，例如gzip；Cache-Control：指示客户端应如何缓存，例如max-age&#x3D;300表示可以最多缓存300秒</code></pre></li><li><p>3.响应体：最后一部分。存放相应数据</p></li></ul><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220706152548.png"></p><h3 id="一、状态码大类"><a href="#一、状态码大类" class="headerlink" title="一、状态码大类"></a>一、状态码大类</h3><table><thead><tr><th>状态码分类</th><th>说明</th></tr></thead><tbody><tr><td>1xx</td><td><strong>响应中</strong>——临时状态码，表示请求已经接受，告诉客户端应该继续请求或者如果它已经完成则忽略它</td></tr><tr><td>2xx</td><td><strong>成功</strong>——表示请求已经被成功接收，处理已完成</td></tr><tr><td>3xx</td><td><strong>重定向</strong>——重定向到其它地方：它让客户端再发起一个请求以完成整个处理。</td></tr><tr><td>4xx</td><td><strong>客户端错误</strong>——处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等</td></tr><tr><td>5xx</td><td><strong>服务器端错误</strong>——处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等</td></tr></tbody></table><p>状态码大全：<a class="link"   href="https://cloud.tencent.com/developer/chapter/13553" >https://cloud.tencent.com/developer/chapter/13553<i class="fas fa-external-link-alt"></i></a> </p><h3 id="二、常见的响应状态码"><a href="#二、常见的响应状态码" class="headerlink" title="二、常见的响应状态码"></a>二、常见的响应状态码</h3><table><thead><tr><th>状态码</th><th>英文描述</th><th>解释</th></tr></thead><tbody><tr><td>200</td><td><strong><code>OK</code></strong></td><td>客户端请求成功，即<strong>处理成功</strong>，这是我们最想看到的状态码</td></tr><tr><td>302</td><td><strong><code>Found</code></strong></td><td>指示所请求的资源已移动到由<code>Location</code>响应头给定的 URL，浏览器会自动重新访问到这个页面</td></tr><tr><td>304</td><td><strong><code>Not Modified</code></strong></td><td>告诉客户端，你请求的资源至上次取得后，服务端并未更改，你直接用你本地缓存吧。隐式重定向</td></tr><tr><td>400</td><td><strong><code>Bad Request</code></strong></td><td>客户端请求有<strong>语法错误</strong>，不能被服务器所理解</td></tr><tr><td>403</td><td><strong><code>Forbidden</code></strong></td><td>服务器收到请求，但是<strong>拒绝提供服务</strong>，比如：没有权限访问相关资源</td></tr><tr><td>404</td><td><strong><code>Not Found</code></strong></td><td><strong>请求资源不存在</strong>，一般是URL输入有误，或者网站资源被删除了</td></tr><tr><td>428</td><td><strong><code>Precondition Required</code></strong></td><td><strong>服务器要求有条件的请求</strong>，告诉客户端要想访问该资源，必须携带特定的请求头</td></tr><tr><td>429</td><td><strong><code>Too Many Requests</code></strong></td><td><strong>太多请求</strong>，可以限制客户端请求某个资源的数量，配合 Retry-After(多长时间后可以请求)响应头一起使用</td></tr><tr><td>431</td><td><strong><code> Request Header Fields Too Large</code></strong></td><td><strong>请求头太大</strong>，服务器不愿意处理请求，因为它的头部字段太大。请求可以在减少请求头域的大小后重新提交。</td></tr><tr><td>405</td><td><strong><code>Method Not Allowed</code></strong></td><td>请求方式有误，比如应该用GET请求方式的资源，用了POST</td></tr><tr><td>500</td><td><strong><code>Internal Server Error</code></strong></td><td><strong>服务器发生不可预期的错误</strong>。服务器出异常了，赶紧看日志去吧</td></tr><tr><td>503</td><td><strong><code>Service Unavailable</code></strong></td><td><strong>服务器尚未准备好处理请求</strong>，服务器刚刚启动，还未初始化好</td></tr><tr><td>511</td><td><strong><code>Network Authentication Required</code></strong></td><td><strong>客户端需要进行身份验证才能获得网络访问权限</strong></td></tr></tbody></table><h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><p>Web服务器是一个应用程序（软件），对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作，让开发更加便捷，主要功能是提供网上信息浏览服务 </p><p>作用：</p><ul><li>封装HTTP协议操作，简化开发</li><li>可以将web项目部署到服务器中，对外提供网上浏览服务</li></ul><p>Tomcat是一个轻量级的Web服务器，支持Servlet&#x2F;JSP少量JavaEE规范，也称为Web服务器，Servlet容器</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220707170900.png"></p><h2 id="部署项目"><a href="#部署项目" class="headerlink" title="部署项目"></a>部署项目</h2><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220707171555.png"></p><h2 id="IDEA中创建Maven-Web项目"><a href="#IDEA中创建Maven-Web项目" class="headerlink" title="IDEA中创建Maven Web项目"></a>IDEA中创建Maven Web项目</h2><h3 id="项目结构："><a href="#项目结构：" class="headerlink" title="项目结构："></a>项目结构：</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220707172439.png"></p><h3 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h3><h4 id="1、"><a href="#1、" class="headerlink" title="1、"></a>1、</h4><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220707172656.png"></p><h4 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h4><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220707172714.png"></p><h3 id="IDEA集成本地Tomcat"><a href="#IDEA集成本地Tomcat" class="headerlink" title="IDEA集成本地Tomcat"></a>IDEA集成本地Tomcat</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220711125029.png"></p><h3 id="IDEA中使用Tomcat-Tomcat-Maven插件"><a href="#IDEA中使用Tomcat-Tomcat-Maven插件" class="headerlink" title="IDEA中使用Tomcat - Tomcat Maven插件"></a>IDEA中使用Tomcat - Tomcat Maven插件</h3><p>1.pom.xml添加Tomcat插件</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;build&gt;    &lt;plugins&gt;    &lt;!--Tomcat插件 --&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.apache.tomcat.maven&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;tomcat7-maven-plugin&lt;&#x2F;artifactId&gt;            &lt;version&gt;2.2&lt;&#x2F;version&gt;        &lt;&#x2F;plugin&gt;    &lt;&#x2F;plugins&gt;&lt;&#x2F;build&gt;</code></pre><p>2.使用Maven Helper 插件快速启动项目，选中项目，右键 Run Maven –&gt; tomcat7:run</p><h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><ul><li>Servlet是java提供的一门动态Web资源开发技术</li><li>Servlet是javaEE规范之一，其实就是一个接口，将来我们要定义Servlet类来访问Servlet接口，并由web服务器运行Servlet</li></ul><h2 id="Servlet快速入门"><a href="#Servlet快速入门" class="headerlink" title="Servlet快速入门"></a>Servlet快速入门</h2><p>1.创建一个项目，导入Servlet依赖坐标</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;javax.servlet-api&lt;&#x2F;artifactId&gt;    &lt;version&gt;3.1.0&lt;&#x2F;version&gt;    &lt;!--      此处为什么需要添加该标签?      provided指的是在编译和测试过程中有效,最后生成的war包时不会加入       因为Tomcat的lib目录中已经有servlet-api这个jar包，如果在生成war包的时候生效就会和Tomcat中的jar包冲突，导致报错    --&gt;    &lt;scope&gt;provided&lt;&#x2F;scope&gt;&lt;&#x2F;dependency&gt;</code></pre><p>2.创建：定义一个类，实现Servlet接口，并重写接口中的所有方法，并在service方法中输入一句话</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.itheima.web;import javax.servlet.*;import java.io.IOException;public class ServletDemo1 implements Servlet &#123;    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;        System.out.println(&quot;servlet hello world~&quot;);    &#125;    public void init(ServletConfig servletConfig) throws ServletException &#123;    &#125;    public ServletConfig getServletConfig() &#123;        return null;    &#125;    public String getServletInfo() &#123;        return null;    &#125;    public void destroy() &#123;    &#125;&#125;</code></pre><p>3.配置: 在类上使用@WebServlet注解，配置该Servlet的访问路径</p><pre class="line-numbers language-none"><code class="language-none">@WebServlet(&quot;&#x2F;demo1&quot;)</code></pre><p>4.访问:启动Tomcat，浏览器输入URL访问该Servlet</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;localhost:8080&#x2F;web-demo&#x2F;demo1</code></pre><h2 id="Servlet执行流程"><a href="#Servlet执行流程" class="headerlink" title="Servlet执行流程"></a>Servlet执行流程<img src="https://raw.githubusercontent.com/2295237514/image/main/20220711141836.png"></h2><h2 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h2><ul><li><p>对象的生命周期指一个对象从被创建到被销毁的整个过程</p></li><li><p>Servlet运行在Servlet容器（Web服务器）中，其生命周期由容器来管理，分为4个阶段</p><p>1.加载和实例化：默认情况下，当Servlet第一次被访问时，其容器创建Servlet对象</p></li></ul><p></p><pre class="line-numbers language-none"><code class="language-none">默认情况，Servlet会在第一次访问被容器创建，但是如果创建Servlet比较耗时的话，那么第一个访问的人等待的时间就比较长，用户的体验就比较差，那么我们能不能把Servlet的创建放到服务器启动的时候来创建，具体如何来配置?@WebServlet(urlPatterns &#x3D; &quot;&#x2F;demo1&quot;,loadOnStartup &#x3D; 1)loadOnstartup的取值有两类情况（1）负整数:第一次访问时创建Servlet对象（2）0或正整数:服务器启动时创建Servlet对象，数字越小优先级越高</code></pre><p>2.初始化：在Servlet实例化之后，容器将调用Servlet的init()方法来初始化这个对象，完成一些如加载配置文件、创建连接等初始化的工作。该方法只调用一次</p><p>3.请求处理：每次请求Servlet时，Servlet容器都会调用Servlet的service()方法对请求进行处理</p><p>4.服务终止：当需要释放内存或容器关闭时，容器就会调用Servlet实例的destory()方法完成资源的释放。在destory()方法调用之后，容器会释放这个Servlet实例，该实例随后会被java的垃圾收集器所回收</p><h2 id="Servlet方法介绍"><a href="#Servlet方法介绍" class="headerlink" title="Servlet方法介绍"></a>Servlet方法介绍</h2><ul><li>初始化方法，在Servlet被创建时执行，只执行一次</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">void init(ServletConfig config) </code></pre><ul><li>提供服务方法， 每次Servlet被访问，都会调用该方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">void service(ServletRequest req, ServletResponse res)</code></pre><ul><li>销毁方法，当Servlet被销毁时，调用该方法。在内存释放或服务器关闭时销毁Servlet</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">void destroy() </code></pre><p>剩下的两个方法是:</p><ul><li>获取Servlet信息</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">String getServletInfo() &#x2F;&#x2F;该方法用来返回Servlet的相关信息，没有什么太大的用处，一般我们返回一个空字符串即可public String getServletInfo() &#123;    return &quot;&quot;;&#125;</code></pre><ul><li>获取ServletConfig对象</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">ServletConfig getServletConfig()</code></pre><h2 id="Servlet体系结构"><a href="#Servlet体系结构" class="headerlink" title="Servlet体系结构"></a>Servlet体系结构</h2><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220711164606.png"></p><p>我们将来开发B&#x2F;S架构的web项目，都是针对HTTP协议，所以我们自定义Servlet，会继承HttpServlet</p><ol><li><p>HttpServlet使用步骤</p><ol><li>继承HttpServlet</li><li>重写doGet和doPost方法</li></ol></li><li><p>HttpServlet原理</p><p>获取请求方式，并根据不同的请求方式，调用不同的doXxx方法。</p></li></ol><h2 id="Servlet-urlPattern配置"><a href="#Servlet-urlPattern配置" class="headerlink" title="Servlet urlPattern配置"></a>Servlet urlPattern配置</h2><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220711175218.png"></p><p>优先级：1&gt;2&gt;3&gt;&#x2F;*&gt;&#x2F;</p><h2 id="XML配置Servlet"><a href="#XML配置Servlet" class="headerlink" title="XML配置Servlet"></a>XML配置Servlet</h2><p>前面对应Servlet的配置，我们都使用的是@WebServlet,这个是Servlet从3.0版本后开始支持注解配置，3.0版本前只支持XML配置文件的配置方法。</p><p>对于XML的配置步骤有两步:</p><ul><li><p>编写Servlet类</p></li><li><p>在web.xml中配置该Servlet 代码如下：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;servlet&gt;       &lt;!-- servlet的名称，名字任意--&gt;       &lt;servlet-name&gt;demo13&lt;&#x2F;servlet-name&gt;       &lt;!--servlet的类全名--&gt;       &lt;servlet-class&gt;com.itheima.web.ServletDemo13&lt;&#x2F;servlet-class&gt;   &lt;&#x2F;servlet&gt;     &lt;!--        Servlet 访问路径   --&gt;   &lt;servlet-mapping&gt;       &lt;!-- servlet的名称，要和上面的名称一致--&gt;       &lt;servlet-name&gt;demo13&lt;&#x2F;servlet-name&gt;       &lt;!-- servlet的访问路径--&gt;       &lt;url-pattern&gt;&#x2F;demo13&lt;&#x2F;url-pattern&gt;   &lt;&#x2F;servlet-mapping&gt;</code></pre></li></ul><h1 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h1><h2 id="Request继承体系"><a href="#Request继承体系" class="headerlink" title="Request继承体系"></a>Request继承体系</h2><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220712103848.png"></p><h2 id="Request获取数据请求参数"><a href="#Request获取数据请求参数" class="headerlink" title="Request获取数据请求参数"></a>Request获取数据请求参数</h2><p>HTTP请求数据总共分为三部分内容，分别是  请求行、请求头、请求体</p><h3 id="Request获取请求行数据"><a href="#Request获取请求行数据" class="headerlink" title="Request获取请求行数据"></a>Request获取请求行数据</h3><p>请求行包含三块内容，分别是<code>请求方式</code>、<code>请求资源路径</code>、<code>HTTP协议及版本</code></p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220712122125.png"></p><p>对于这三部分内容，request对象都提供了对应的API方法来获取，具体如下:</p><ul><li>获取请求方式<code>GET</code></li></ul><pre class="line-numbers language-none"><code class="language-none">String getMethod()</code></pre><ul><li>获取虚拟目录（项目访问路径）<code>/request-demo</code></li></ul><pre class="line-numbers language-none"><code class="language-none">Sting getContextPath()</code></pre><ul><li>获取URL（统一资源定位符）<code>https://localhost:8080/request-demo/req1</code></li></ul><pre class="line-numbers language-none"><code class="language-none">StringBuffer getRequestURL()</code></pre><ul><li>获取URI(统一资源标识符)<code>request-demo/req1</code></li></ul><pre class="line-numbers language-none"><code class="language-none">String getRequestURI()</code></pre><ul><li>获取请求参数(GET方式)<code>username=zhangsan&amp;password=123</code></li></ul><pre class="line-numbers language-none"><code class="language-none">Sting getQueryString()</code></pre><p>例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * request 获取请求数据 *&#x2F;@WebServlet(&quot;&#x2F;req1&quot;)public class RequestDemo1 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        &#x2F;&#x2F; String getMethod()：获取请求方式： GET        String method &#x3D; req.getMethod();        System.out.println(method);&#x2F;&#x2F;GET        &#x2F;&#x2F; String getContextPath()：获取虚拟目录(项目访问路径)：&#x2F;request-demo        String contextPath &#x3D; req.getContextPath();        System.out.println(contextPath);        &#x2F;&#x2F; StringBuffer getRequestURL(): 获取URL(统一资源定位符)：http:&#x2F;&#x2F;localhost:8080&#x2F;request-demo&#x2F;req1        StringBuffer url &#x3D; req.getRequestURL();        System.out.println(url.toString());        &#x2F;&#x2F; String getRequestURI()：获取URI(统一资源标识符)： &#x2F;request-demo&#x2F;req1        String uri &#x3D; req.getRequestURI();        System.out.println(uri);        &#x2F;&#x2F; String getQueryString()：获取请求参数（GET方式）： username&#x3D;zhangsan        String queryString &#x3D; req.getQueryString();        System.out.println(queryString);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;    &#125;&#125;</code></pre><h3 id="获取请求头数据"><a href="#获取请求头数据" class="headerlink" title="获取请求头数据"></a>获取请求头数据</h3><p>对于请求头的数据，格式为<code>key: value</code>如下：</p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220712123628.png"></p><p>所以根据请求头名称获取对应值的方法为:</p><pre class="line-numbers language-none"><code class="language-none">String getHeader(String name)</code></pre><h3 id="获取请求体数据"><a href="#获取请求体数据" class="headerlink" title="获取请求体数据"></a>获取请求体数据</h3><p>浏览器在发送GET请求的时候是没有请求体的，所以需要把请求方式变更为POST，请求体中的数据格式如下:</p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220712125253.png"></p><ul><li>获取字节输入流，如果前端发送的是字节数据，比如传递的是文件数据，则使用该方法</li></ul><pre class="line-numbers language-none"><code class="language-none">ServletInputStream getInputStream()该方法可以获取字节</code></pre><ul><li>获取字符输入流，如果前端发送的是纯文本数据，则使用该方法</li></ul><pre class="line-numbers language-none"><code class="language-none">BufferedReader getReader()</code></pre><p>具体实现的步骤如下:</p><p>1.准备一个页面，在页面中添加form表单,用来发送post请求</p><p>2.在Servlet的doPost方法中获取请求体数据</p><p>3.在doPost方法中使用request的getReader()或者getInputStream()来获取</p><p>4.访问测试</p><h3 id="获取请求参数的通用方式"><a href="#获取请求参数的通用方式" class="headerlink" title="获取请求参数的通用方式"></a>获取请求参数的通用方式</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220712135714.png"></p><ul><li>获取所有参数Map集合</li></ul><pre class="line-numbers language-none"><code class="language-none">Map&lt;String,String[]&gt; getParameterMap()</code></pre><ul><li>根据名称获取参数值（数组）</li></ul><pre class="line-numbers language-none"><code class="language-none">String[] getParameterValues(String name)</code></pre><ul><li>根据名称获取参数值(单个值)</li></ul><pre class="line-numbers language-none"><code class="language-none">String getParameter(String name)</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class RequestDemo1 extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;       &#x2F;&#x2F;采用request提供的获取请求参数的通用方式来获取请求参数       &#x2F;&#x2F;编写其他的业务代码...    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        this.doGet(req,resp);    &#125;&#125;</code></pre><h3 id="请求参数中文乱码处理"><a href="#请求参数中文乱码处理" class="headerlink" title="请求参数中文乱码处理"></a>请求参数中文乱码处理</h3><ul><li><p>请求参数如果存在中文数据，则会乱码</p></li><li><p>解决方案：</p><ul><li><p>POST:设置输入流的编码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">req.setCharacterEncoding(&quot;UTF-8&quot;);</code></pre></li><li><p>通用方式（GET&#x2F;POST）：先编码，再解码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">new String(username.getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;);</code></pre></li></ul></li></ul><h2 id="Request请求转发"><a href="#Request请求转发" class="headerlink" title="Request请求转发"></a>Request请求转发</h2><ul><li>请求转发：一种在服务器的内部资源跳转方式</li></ul><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220712152115.png"></p><ul><li><p>实现方式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">req.getRequestDispatcher(&quot;资源B路径&quot;).forward(req,resp);</code></pre></li><li><p>请求转发资源间共享数据:使用Request对象</p><ul><li>void setAttribute(String name, Object o)：存储数据到request域中</li><li>Object getAttribute(String name)：根据key，获取值</li><li>void removAttribute(String name)：根据key，删除该键值对</li></ul></li><li><p>请求转发特点：</p><ul><li>浏览器地址栏领不发生变化</li><li>只能转发到当前服务器的内部资源</li><li>一次请求，可以在转发的资源间使用requset共享数据</li></ul></li></ul><h1 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h1><h2 id="Response设置响应数据功能介绍"><a href="#Response设置响应数据功能介绍" class="headerlink" title="Response设置响应数据功能介绍"></a>Response设置响应数据功能介绍</h2><ul><li><p>响应数据分为3部分：</p><ul><li><p>响应行：</p><pre class="line-numbers language-none"><code class="language-none">HTTP&#x2F;1.1 200 OK</code></pre><p>void setStatus(int sc): 设置响应状态码</p></li><li><p>响应头：</p><pre class="line-numbers language-none"><code class="language-none">Content-Type:text&#x2F;html</code></pre><p>void setHeader(String name, String value):设置响应头键值对</p></li><li><p>响应体：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;html&gt;&lt;head&gt;&lt;head&gt;&lt;body&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><p>printWriter getWriter(): 获取字符输出流</p><p>ServletOutputStream getOutputStream():获取字节输出流</p></li></ul></li></ul><h2 id="Response完成重定向"><a href="#Response完成重定向" class="headerlink" title="Response完成重定向"></a>Response完成重定向</h2><ul><li>重定向：一种资源跳转方式</li></ul><p>​<img src="https://raw.githubusercontent.com/2295237514/image/main/20220712172339.png"></p><h2 id="资源路径问题"><a href="#资源路径问题" class="headerlink" title="资源路径问题"></a>资源路径问题</h2><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220712173717.png"></p><p><em>建议动态获取虚拟目录：String contextPath &#x3D; request.getContextPath();</em></p><p><em>重定向：response.sendRedirect(contextPath + “&#x2F;resp2”);</em></p><h2 id="Response响应字符数据"><a href="#Response响应字符数据" class="headerlink" title="Response响应字符数据"></a>Response响应字符数据</h2><ul><li><p>使用：</p><p>1.通过Response对象获取字符输入流</p><pre class="line-numbers language-none"><code class="language-none">PrintWriter writer &#x3D; response.getWriter();</code></pre><p>2.写数据</p><pre class="line-numbers language-none"><code class="language-none">writer.write(&quot;aaa&quot;);</code></pre></li><li><p>注意：</p><ul><li><p>该流不需要关闭，随着响应结束，Response对象销毁，由服务器关闭</p></li><li><p>中文数据乱码：原因通过获取的字符输出流默认编码：ISO-8859-1</p><pre class="line-numbers language-none"><code class="language-none">resp.setContentType(&quot;text&#x2F;html;charset&#x3D;utf-8&quot;);</code></pre></li></ul></li></ul><h2 id="Response响应字节数据"><a href="#Response响应字节数据" class="headerlink" title="Response响应字节数据"></a>Response响应字节数据</h2><ul><li><p>使用：</p><p>1.通过Response对象获取字符输入流</p><pre class="line-numbers language-none"><code class="language-none">ServletOutputStream outputStream &#x3D; resp.getOutputStream();</code></pre><p>2.写数据</p><pre class="line-numbers language-none"><code class="language-none">outputStream.write(字节数据);</code></pre></li><li><p>IOUtils工具类使用</p><p>1.导入坐标</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependency&gt;&lt;groupid&gt;commons-io&lt;&#x2F;groupid&gt;    &lt;artifactld&gt;commons-io&lt;&#x2F;artifactld&gt;    &lt;version&gt;2.6&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre><p>2.使用</p><pre class="line-numbers language-none"><code class="language-none">IOUtils.copy(输入流，输出流);</code></pre></li></ul><h2 id="SqlSessionFactory代码优化"><a href="#SqlSessionFactory代码优化" class="headerlink" title="SqlSessionFactory代码优化"></a>SqlSessionFactory代码优化</h2><pre class="line-numbers language-none"><code class="language-none">String resource &#x3D; &quot;org&#x2F;mybatis&#x2F;example&#x2F;mybatis-config.xml&quot;;InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);</code></pre><p>问题： </p><p>​1.代码重复：       解决<em>（工具类)</em></p><p>​2.SqlSessionFactory工厂只创建一次，不要重复创建：  解决<em>（静态代码块）</em></p><p>我创建的工具类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.itheima.util;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;public class SqlSessionFactoryUtils &#123;    private static  SqlSessionFactory sqlSessionFactory;    static &#123;        &#x2F;&#x2F;静态代码块会随着类的加载自动执行，且只执行一次        try &#123;            String resource &#x3D; &quot;mybatis-config.xml&quot;;            InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);            SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);        &#125; catch (IOException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    public static SqlSessionFactory getSqlSessionFactory()&#123;        return sqlSessionFactory;    &#125;&#125;</code></pre><h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><ul><li>Java Server Pages ，Java服务端页面</li><li>一种动态的网页技术，其中既可以定义HTML,JS,CSS等静态内容，还可以定义Java代码的动态内容</li><li>JSP &#x3D; HTML + Java</li><li>作用：简化开发，避免了在Servlet中直接输出HTML标签</li></ul><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220713154017.png"></p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220713162526.png"></p><h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><ul><li><p>用于简化JSP页面内的Java代码</p></li><li><p>主要功能：获取数据</p></li><li><p>语法：${expression}</p><pre class="line-numbers language-none"><code class="language-none">$&#123;brands&#125;</code></pre><p>获取域中存储key为brands的数据</p></li><li><p>JavaWeb中的四大域对象：</p><ul><li>page:当前页面有效</li><li>request:当前请求有效</li><li>session:当前会话有效</li><li>application:当前应用有效</li></ul></li></ul><p>*el表达式获取数据，会依次从这4个域中寻找，直到找到为止</p><h2 id="JSTL标签"><a href="#JSTL标签" class="headerlink" title="JSTL标签"></a>JSTL标签</h2><ul><li>JSP标签库（Jsp Standarded Tag Library），使用标签取代JSP页面上的Java代码</li></ul><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220714094650.png"></p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220714095238.png"></p><h2 id="MVC模式和三层架构"><a href="#MVC模式和三层架构" class="headerlink" title="MVC模式和三层架构"></a>MVC模式和三层架构</h2><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><ul><li><p>MVC是一种分层开发模式，其中：</p><ul><li>M:Model，业务模型，处理业务</li><li>V:View，视图，页面展示</li><li>C：Controller，控制器，处理请求，调用模型和视图</li></ul></li><li><p>MVC好处</p><ul><li>职责单一，互不影响</li><li>有利于分工协作</li><li>有利于组件重用</li></ul></li></ul><h3 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220714100144.png"></p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220714101417.png"></p><h1 id="会话跟踪技术"><a href="#会话跟踪技术" class="headerlink" title="会话跟踪技术"></a>会话跟踪技术</h1><ul><li>会话：用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应</li><li>会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自同一浏览器，以便在同义词绘画的多次请求间共享数据</li><li>HTTP协议是无状态的，每次浏览器向服务器请求时，服务器都会将该请求视为新的请求，因此我们需要会话跟踪技术来实现会话内数据共享</li><li>实现方式：<ul><li>客户端会话跟踪技术：Cookie</li><li>服务端会话跟踪技术：Session</li></ul></li></ul><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p><em>Cookie:客户端会话技术，将数据保存到客户端，以后每次请求都携带Cookie数据进行访问</em></p><h3 id="Cookie基本使用"><a href="#Cookie基本使用" class="headerlink" title="Cookie基本使用"></a>Cookie基本使用</h3><h4 id="发送Cookie"><a href="#发送Cookie" class="headerlink" title="发送Cookie"></a>发送Cookie</h4><p>1.创建Cookie对象，设置数据</p><pre class="line-numbers language-none"><code class="language-none">Cookie cookie &#x3D; new Cookie(&quot;key&quot;,&quot;value&quot;);</code></pre><p>2.发送Cookie到客户端：使用response对象</p><pre class="line-numbers language-none"><code class="language-none">response.addCookie(cookie);</code></pre><h4 id="获取Cookie"><a href="#获取Cookie" class="headerlink" title="获取Cookie"></a>获取Cookie</h4><p>3.获取客户端携带的所有Cookie，使用request对象</p><pre class="line-numbers language-none"><code class="language-none">Cookie[] cookies &#x3D; request.getCookies();</code></pre><p>4.遍历数组，获取每一个Cookie对象：for</p><p>5.使用Cookie对象方法获取数据</p><pre class="line-numbers language-none"><code class="language-none">cookie.getName();</code></pre><pre class="line-numbers language-none"><code class="language-none">cookie.getValue();</code></pre><h3 id="Cookie原理"><a href="#Cookie原理" class="headerlink" title="Cookie原理"></a>Cookie原理</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220714132848.png"></p><h3 id="Cookie使用细节"><a href="#Cookie使用细节" class="headerlink" title="Cookie使用细节"></a>Cookie使用细节</h3><ul><li>Cookie存活时间：</li></ul><p>​-默认情况下，Cookie存储爱浏览器内存中，当浏览器关闭，内存释放，则Cookie被销毁</p><p>​setMaxAge（int seconds）：设置Cookie存活时间</p><p>​1.正数：将Cookie写入浏览器所爱电脑的硬盘，持久化存储，到时见自动删除</p><p>​2.负数：默认值，Cookie在当前浏览器内存中，当浏览器关闭，则Cookie被销毁</p><p>​2.零：删除对应Cookie</p><ul><li><p>Cookie存储中文</p><p>Cookie不能直接存储中文</p><p>如需要存储，则需要进行转码：URL编码，使用时再解码</p></li></ul><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p><em>Session：服务端会话跟踪技术，将数据保存到服务端</em></p><p><em>JavaEE提供HttpSession接口，来实现一次会话的多次请求间数据共享功能</em></p><h3 id="Session基本使用"><a href="#Session基本使用" class="headerlink" title="Session基本使用"></a>Session基本使用</h3><p>1.获取Session对象：</p><pre class="line-numbers language-none"><code class="language-none">HttpSession session &#x3D; request.getSession();</code></pre><p>2.Session对象功能：</p><p>(1) void setAttribute(String name, Object o): 存储数据到session域中</p><p>(2)Object getAttribute(String name):根据key，获取值</p><p>(3)void removeAttribute(String name):根据key，删除该键值对</p><h3 id="Session原理"><a href="#Session原理" class="headerlink" title="Session原理"></a>Session原理</h3><ul><li><p>Session是基于Cookie实现的</p></li><li><p>在一次会话的多次请求之间获取的session对象是同一个</p></li></ul><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220714151529.png"></p><h3 id="Session使用细节"><a href="#Session使用细节" class="headerlink" title="Session使用细节"></a>Session使用细节</h3><ul><li><p>Session钝化，活化：</p><ul><li>钝化：在服务器正常关闭后，Tomcat会自动将Session数据写入硬盘的文件</li><li>活化：再次启动服务器后，从文件中加载到Session中</li></ul></li><li><p>Session销毁： </p><ul><li><p>默认情况下，无操作，30分钟自动销毁</p><pre class="line-numbers language-none"><code class="language-none">&lt;session-config&gt;&lt;session-timeout&gt;30&lt;&#x2F;session-timeout&gt;&lt;session-config&gt;</code></pre></li><li><p>调用Session对象的invalidate()方法</p></li></ul></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>Cookie和Session都是来完成一次会话内多次请求建数据共享的</li><li>区别：<ul><li>存储位置：Cookie是将数据存储在客户端，Session将数据存储在服务端</li><li>安全性：Cookie不安全，Session安全</li><li>数据大小：Cookie最大3KB，Session无大小限制</li><li>存储时间：Cookie可以长期存储，Session默认30分钟</li><li>服务器性能：Cookie不占服务器资源，Session占用服务器资源</li></ul></li></ul><h1 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h1><ul><li>概念：Filter表示过滤器，是Javaweb三大组件（Servlet，Filter，Listener）之一</li><li>过滤器可以把对资源的请求拦截下来，从未实现一些特殊的功能</li><li>过滤器一般完成一些通用的操作，比如：权限控制，统一编码处理，敏感字符处理等等……</li></ul><h2 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h2><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220719123942.png"></p><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220719125716.png"></p><h2 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h2><h3 id="拦截路径配置"><a href="#拦截路径配置" class="headerlink" title="拦截路径配置"></a>拦截路径配置</h3><ul><li><p>Filter可以根据需求，配置不同的拦截资源路径</p><p>@WebFilter(“&#x2F;*”)</p><p>public class FilterDemo</p><ul><li>拦截具体的资源：&#x2F;index.jsp: 只有访问index.jsp时才会被拦截</li><li>目录拦截：&#x2F;user&#x2F;*:访问&#x2F;user下的所有资源，都会被拦截</li><li>后缀名拦截：*.jsp：访问后缀名为jsp的资源，都会被拦截</li><li>拦截所有：&#x2F;*：访问所有的资源，都会被拦截</li></ul></li></ul><h3 id="过滤器链"><a href="#过滤器链" class="headerlink" title="过滤器链"></a>过滤器链</h3><ul><li>一个Web应用，可以配置多个过滤器，这多个过滤器称为过滤器链</li></ul><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220719135729.png"></p><ul><li>注解配置的Filter，优先级按照过滤器类名（字符串）的自然排序</li></ul><h1 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h1><ul><li><p>概念：Listener是监听器，是JavaWeb三大组件(Servlet,Filter,Listener)之一</p></li><li><p>监听器可以监听就是在application，session，request三个对象创建，销毁或者往其中添加修改删除属性时自动执行代码的功能组件</p></li><li><p>Listener分类：JavaWeb提供了8个监听器</p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220719143535.png"></p></li></ul><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220719143954.png"></p><h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><ul><li><p>概念：异步的Javascript和XML</p></li><li><p>AJAX作用：</p><p>1.与服务器进行数据交换：通过AJAX可以给服务器发送请求，并获取服务器响应的数据</p><ul><li>使用了AJAX和服务器进行通信，就可以使用HTML+AJAX来替换JSP页面了</li></ul><p>2.异步交互：可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术，如：搜索联想，用户名是否可用校验，等等……</p><h2 id="异步和同步"><a href="#异步和同步" class="headerlink" title="异步和同步"></a>异步和同步</h2><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220724084331.png"></p></li></ul><h2 id="AJAX快速入门"><a href="#AJAX快速入门" class="headerlink" title="AJAX快速入门"></a>AJAX快速入门</h2><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220724141104.png"></p><h2 id="Axios异步框架"><a href="#Axios异步框架" class="headerlink" title="Axios异步框架"></a>Axios异步框架</h2><ul><li>Axios对原生的AJAX进行封装，简化书写</li><li>官网：<a class="link"   href="http://www.axios-http.cn/" >http://www.axios-http.cn<i class="fas fa-external-link-alt"></i></a></li></ul><p>将<a target = "_blank" href = "\doc\axios-0.18.0.js"><em><strong>js文件</strong></em> &#x2F;放到项目的webapp目录下</p><ul><li><p>引入 axios 的 js 文件</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;script src&#x3D;&quot;js&#x2F;axios-0.18.0.js&quot;&gt;&lt;&#x2F;script&gt;</code></pre></li><li><p>使用axios 发送请求，并获取响应结果</p><ul><li><p>发送 get 请求</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">axios(&#123;    method:&quot;get&quot;,    url:&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;ajax-demo1&#x2F;aJAXDemo1?username&#x3D;zhangsan&quot;&#125;).then(function (resp)&#123;    alert(resp.data);&#125;)</code></pre></li><li><p>发送 post 请求</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">axios(&#123;    method:&quot;post&quot;,    url:&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;ajax-demo1&#x2F;aJAXDemo1&quot;,    data:&quot;username&#x3D;zhangsan&quot;&#125;).then(function (resp)&#123;    alert(resp.data);&#125;);</code></pre><p><strong>整体页面代码如下：</strong></p><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;script src&#x3D;&quot;js&#x2F;axios-0.18.0.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    &#x2F;&#x2F;1. get   &#x2F;* axios(&#123;        method:&quot;get&quot;,        url:&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;ajax-demo&#x2F;axiosServlet?username&#x3D;zhangsan&quot;    &#125;).then(function (resp) &#123;        alert(resp.data);    &#125;)*&#x2F;    &#x2F;&#x2F;2. post  在js中&#123;&#125; 表示一个js对象，而这个js对象中有三个属性    axios(&#123;        method:&quot;post&quot;,        url:&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;ajax-demo&#x2F;axiosServlet&quot;,        data:&quot;username&#x3D;zhangsan&quot;    &#125;).then(function (resp) &#123;        alert(resp.data);    &#125;)&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></li></ul></li></ul><h2 id="请求别名方式"><a href="#请求别名方式" class="headerlink" title="请求别名方式"></a>请求别名方式</h2><p>入门案例中的 <code>get</code> 请求代码可以改为如下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">axios.get(&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;ajax-demo&#x2F;axiosServlet?username&#x3D;zhangsan&quot;).then(function (resp) &#123;    alert(resp.data);&#125;);</code></pre><p>入门案例中的 <code>post</code> 请求代码可以改为如下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">axios.post(&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;ajax-demo&#x2F;axiosServlet&quot;,&quot;username&#x3D;zhangsan&quot;).then(function (resp) &#123;    alert(resp.data);&#125;)</code></pre><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><ul><li><p>JavaScript Object Notation。 JavaScript对象表示法</p></li><li><p>由于其语法简单，层次结构鲜明，现多用于作为数据载体，在网络中进行数据传输</p></li></ul><h2 id="JSON基础语法"><a href="#JSON基础语法" class="headerlink" title="JSON基础语法"></a>JSON基础语法</h2><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220724160836.png"></p><h2 id="JSON数据和JAVA对象的转换"><a href="#JSON数据和JAVA对象的转换" class="headerlink" title="JSON数据和JAVA对象的转换"></a>JSON数据和JAVA对象的转换</h2><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220724161003.png"></p><p><code>Fastjson</code> 是阿里巴巴提供的一个Java语言编写的高性能功能完善的 <code>JSON</code> 库，是目前Java语言中最快的 <code>JSON</code> 库，可以实现 <code>Java</code> 对象和 <code>JSON</code> 字符串的相互转换。</p><ol><li><p><strong>导入坐标</strong></p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.2.62&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre></li><li><p><strong>Java对象转JSON</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">String jsonStr &#x3D; JSON.toJSONString(obj);</code></pre><p>将 Java 对象转换为 JSON 串，只需要使用 <code>Fastjson</code> 提供的 <code>JSON</code> 类中的 <code>toJSONString()</code> 静态方法即可。</p></li><li><p><strong>JSON字符串转Java对象</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">User user &#x3D; JSON.parseObject(jsonStr, User.class);</code></pre><p>将 json 转换为 Java 对象，只需要使用 <code>Fastjson</code> 提供的 <code>JSON</code> 类中的 <code>parseObject()</code> 静态方法即可。</p></li></ol><h1 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h1><ul><li>免除原生JavaScript中的DOM操作，简化书写</li><li>基于MVVM(Model-View-ViewModel)思想，实现数据的双向绑定，将编程的关注点放在数据上</li><li>官网：https：&#x2F;&#x2F;cn.vuejs.org</li></ul><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220724195752.png"></p><h2 id="Vue快速入门"><a href="#Vue快速入门" class="headerlink" title="Vue快速入门"></a>Vue快速入门</h2><p>1.新建HTML页面，引入Vue.js文件</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;script src&#x3D;&quot;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</code></pre><p>2.在JS代码区域，创建Vue和新对象，进行数据绑定</p><pre class="line-numbers language-none"><code class="language-none">new Vue(&#123;el:&quot;#app&quot;,data()&#123;return &#123;username:&quot;&quot;&#125;&#125;&#125;)</code></pre><p>3.编写视图</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;div&gt;    &lt;input name&#x3D;&quot;username&quot; v-model&#x3D;&quot;username&quot;&gt;    &#123;&#123;username&#125;&#125;&lt;&#x2F;div&gt;</code></pre><h2 id="Vue常用指令"><a href="#Vue常用指令" class="headerlink" title="Vue常用指令"></a>Vue常用指令</h2><table><thead><tr><th><strong>指令</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>v-bind</td><td>为HTML标签绑定属性值，如设置  href , css样式等</td></tr><tr><td>v-model</td><td>在表单元素上创建双向数据绑定</td></tr><tr><td>v-on</td><td>为HTML标签绑定事件</td></tr><tr><td>v-if</td><td>条件性的渲染某元素，判定为true时渲染,否则不渲染</td></tr><tr><td>v-else</td><td></td></tr><tr><td>v-else-if</td><td></td></tr><tr><td>v-show</td><td>根据条件展示某元素，区别在于切换的是display属性的值</td></tr><tr><td>v-for</td><td>列表渲染，遍历容器的元素或者对象的属性</td></tr></tbody></table><p> <code>v-show</code> 不展示的原理是给对应的标签添加 <code>display</code> css属性，并将该属性值设置为 <code>none</code> ，这样就达到了隐藏的效果。而 <code>v-if</code> 指令是条件不满足时根本就不会渲染。</p><h2 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h2><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220724202928.png"></p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220724202904.png"></p><h1 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h1><ul><li>Element：是饿了么公司前端开发团队提供的一套基于Vue的网站组件库，用于快速构建网页</li><li>组件：组成网页的部件，例如超链接，按钮，图片，表格等等</li></ul><h2 id="Element快速入门"><a href="#Element快速入门" class="headerlink" title="Element快速入门"></a>Element快速入门</h2><p> 引入Element的css，js文件和vue.js</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;script src&#x3D;&quot;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;element-ui&#x2F;lib&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;element-ui&#x2F;lib&#x2F;theme-chalk&#x2F;index.css&quot;&gt;</code></pre><p>创建Vue核心对象</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;script&gt;    new Vue(&#123;        el:&quot;#app&quot;    &#125;)&lt;&#x2F;script&gt;</code></pre><p>官网复制Element组件代码</p><h2 id="Element布局"><a href="#Element布局" class="headerlink" title="Element布局"></a>Element布局</h2><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220725085905.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Web概述&quot;&gt;&lt;a href=&quot;#Web概述&quot; class=&quot;headerlink&quot; title=&quot;Web概述&quot;&gt;&lt;/a&gt;Web概述&lt;/h1&gt;&lt;h2 id=&quot;JavaWeb技术栈&quot;&gt;&lt;a href=&quot;#JavaWeb技术栈&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="JavaWeb" scheme="https://2295237514.github.io/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>java的值传递和引用传递</title>
    <link href="https://2295237514.github.io/post/java%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92.html"/>
    <id>https://2295237514.github.io/post/java%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92.html</id>
    <published>2022-07-05T08:53:49.000Z</published>
    <updated>2022-07-05T09:04:19.413Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、基本类型和引用类型的理解"><a href="#一、基本类型和引用类型的理解" class="headerlink" title="一、基本类型和引用类型的理解"></a>一、基本类型和引用类型的理解</h2><p><strong>Java中的数据类型分为两种为基本类型和引用类型。</strong></p><p>1、基本类型的变量保存原始值，所以变量就是数据本身。</p><p>  常见的基本类型：byte,short,int,long,char,float,double,<a class="link"   href="https://so.csdn.net/so/search?q=Boolean&spm=1001.2101.3001.7020" >Boolean<i class="fas fa-external-link-alt"></i></a>,returnAddress。</p><p>2、引用类型的变量保存引用值，所谓的引用值就是对象所在内存空间的“首地址值”，通过对这个引用值来操作对象。</p><p>  常见的引用类型：类类型，接口类型和<a class="link"   href="https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020" >数组<i class="fas fa-external-link-alt"></i></a>。</p><h2 id="二、值传递和引用传递的理解"><a href="#二、值传递和引用传递的理解" class="headerlink" title="二、值传递和引用传递的理解"></a>二、<a class="link"   href="https://so.csdn.net/so/search?q=%E5%80%BC%E4%BC%A0%E9%80%92&spm=1001.2101.3001.7020" >值传递<i class="fas fa-external-link-alt"></i></a>和引用传递的理解</h2><h3 id="1、值传递"><a href="#1、值传递" class="headerlink" title="1、值传递"></a>1、值传递</h3><p>  在方法的调用过程中，实参把它的实际值传递给形参，此传递过程就是将实参的值复制一份传递到函数中，这样如果在函数中对该值（形参的值）进行了操作将不会影响实参的值。因为是直接复制，所以这种方式在传递大量数据时，运行效率会特别低下。</p><h3 id="2、引用传递"><a href="#2、引用传递" class="headerlink" title="2、引用传递"></a>2、<a class="link"   href="https://so.csdn.net/so/search?q=%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92&spm=1001.2101.3001.7020" >引用传递<i class="fas fa-external-link-alt"></i></a></h3><p>  引用传递弥补了值传递的不足，如果传递的数据量很大，直接复过去的话，会占用大量的内存空间，而引用传递就是将对象的地址值传递过去，函数接收的是原始值的首地址值。在方法的执行过程中，形参和实参的内容相同，指向同一块内存地址，也就是说操作的其实都是源数据，所以方法的执行将会影响到实际对象。</p><p>举例说明：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">public class Example &#123;    String str &#x3D; new String(&quot;hello&quot;);    char[] ch &#x3D; &#123;&#39;a&#39;, &#39;b&#39;&#125;;    public static void main(String[] args) &#123;        Example ex &#x3D; new Example();        ex.change(ex.str, ex.ch);        System.out.println(ex.str + &quot; and&quot;);        System.out.println(ex.ch);    &#125;    public void change(String str, char[] ch) &#123;        str &#x3D; &quot;ok&quot;;        ch[0] &#x3D; &#39;c&#39;;    &#125;&#125;输出是：hello andcb</code></pre><p>过程分析：</p><p>1、为对象分配空间</p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220705165644.png"></p><p>2、执行change()方法</p><p>执行前实参（黑色）和形参（红色）的指向如下：</p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220705165845.png"></p><p>因为String是不可变类且为值传递，而ch[]是引用传递，所以方法中的str &#x3D; “ok”,相当于重新创建一个对象并没有改变实参str的值，数组是引用传递，直接改变，所以执行完方法后，指向关系如下：</p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220705165923.png"></p><h3 id="3-结论"><a href="#3-结论" class="headerlink" title="3.结论"></a>3.结论</h3><p>通过上面的分析我们可以得出以下结论：</p><p>基本数据类型传值，对形参的修改不会影响实参；<br>引用类型传引用，形参和实参指向同一个内存地址（同一个对象），所以对参数的修改会影响到实际的对象。<br>String, Integer, Double等immutable的类型特殊处理，可以理解为传值，最后的操作不会修改实参对象。</p><h2 id="哈希表中的特殊情况"><a href="#哈希表中的特殊情况" class="headerlink" title="哈希表中的特殊情况"></a>哈希表中的特殊情况</h2><p><strong>只要是哈希表中的原生类型，如Integer，String，尽管他们平时是引用传递，但在哈希表中是按值传递！！！</strong></p><p>非原生类型，按值传递，如自己定义的类型。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、基本类型和引用类型的理解&quot;&gt;&lt;a href=&quot;#一、基本类型和引用类型的理解&quot; class=&quot;headerlink&quot; title=&quot;一、基本类型和引用类型的理解&quot;&gt;&lt;/a&gt;一、基本类型和引用类型的理解&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Java中的数据类型分为两种</summary>
      
    
    
    
    
    <category term="java基础知识" scheme="https://2295237514.github.io/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode高频题总结</title>
    <link href="https://2295237514.github.io/post/Leetcode%E9%AB%98%E9%A2%91%E9%A2%98%E6%80%BB%E7%BB%93.html"/>
    <id>https://2295237514.github.io/post/Leetcode%E9%AB%98%E9%A2%91%E9%A2%98%E6%80%BB%E7%BB%93.html</id>
    <published>2022-07-05T03:05:06.000Z</published>
    <updated>2022-07-06T04:15:40.213Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指Offer"><a href="#剑指Offer" class="headerlink" title="剑指Offer"></a>剑指Offer</h1><h2 id="18-删除链表的节点"><a href="#18-删除链表的节点" class="headerlink" title="18 删除链表的节点"></a>18 <a class="link"   href="https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/" >删除链表的节点<i class="fas fa-external-link-alt"></i></a></h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public ListNode deleteNode(ListNode head, int val) &#123;        while(head !&#x3D; null)&#123;            if(head.val !&#x3D; val)&#123;                break;            &#125;            head &#x3D; head.next;        &#125; &#x2F;&#x2F;找到第一个非空的头结点，用于返回和执行下步操作        ListNode pre &#x3D; head;        ListNode cur &#x3D; head;        while(cur !&#x3D; null)&#123;            if(cur.val &#x3D;&#x3D; val)&#123;                pre.next &#x3D; cur.next;            &#125;else&#123;                pre &#x3D; cur;            &#125;            cur &#x3D; cur.next;        &#125;        return head;    &#125;&#125;</code></pre><h2 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="24 反转链表"></a>24 <a class="link"   href="https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/" >反转链表<i class="fas fa-external-link-alt"></i></a></h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public ListNode reverseList(ListNode head) &#123;        ListNode pre &#x3D; null;        ListNode next &#x3D; head;        while(next!&#x3D;null)&#123;            next &#x3D; head.next;            head.next &#x3D; pre;            pre &#x3D; head;            head &#x3D; next;        &#125;        return pre;    &#125;&#125;</code></pre><h2 id="65-不用加减乘除做加法"><a href="#65-不用加减乘除做加法" class="headerlink" title="65 不用加减乘除做加法"></a>65 <a class="link"   href="https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/" >不用加减乘除做加法<i class="fas fa-external-link-alt"></i></a></h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;*思路：      首先看十进制是如何做的： 5+7&#x3D;12，三步走 第一步：相加各位的值，不算进位，得到2。      第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。      第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。 同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111       第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。       第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。       第三步重复上述两步， 各位相加 010^1010&#x3D;1000，进位值为100&#x3D;(010&amp;1010)&lt;&lt;1。 继续重复上述两步：1000^100 &#x3D; 1100，进位值为0，跳出循环，1100为最终结果。————————————————版权声明：本文为CSDN博主「夏至&amp;未至」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_35571554&#x2F;article&#x2F;details&#x2F;82780288*&#x2F;public class Solution &#123;    public int Add(int num1,int num2) &#123;        while (num2!&#x3D;0) &#123;            int temp &#x3D; num1^num2;            num2 &#x3D; (num1&amp;num2)&lt;&lt;1;            num1 &#x3D; temp;        &#125;        return num1;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;剑指Offer&quot;&gt;&lt;a href=&quot;#剑指Offer&quot; class=&quot;headerlink&quot; title=&quot;剑指Offer&quot;&gt;&lt;/a&gt;剑指Offer&lt;/h1&gt;&lt;h2 id=&quot;18-删除链表的节点&quot;&gt;&lt;a href=&quot;#18-删除链表的节点&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="算法与数据结构" scheme="https://2295237514.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法学习</title>
    <link href="https://2295237514.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0.html"/>
    <id>https://2295237514.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0.html</id>
    <published>2022-07-02T01:51:23.000Z</published>
    <updated>2022-07-17T10:18:45.969Z</updated>
    
    <content type="html"><![CDATA[<p>由于之前并未完整成体系的学习算法，在力扣刷100道题后</p><p>感觉到算法知识不成体系，决定看左程云的体系学习班学习算法</p><h1 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h1><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220702104928.png"></p><p>搞定1,2,3差不多达到面试水平</p><h1 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h1><p>子问题规模一样的递归可以用Master公式求时间复杂度</p><p>T(N) &#x3D; a * T(N&#x2F;b) + O(N ^ d);</p><p>a:会有几次调用代码</p><p>b:每次调用规模的大小</p><ul><li>如果 log（b , a) &lt; d 时间复杂度为： O(N^d)</li><li>如果log (b , a) &gt; d 时间复杂度为 ： O(N^(log(b,a)))</li><li>如果log（b , a）&#x3D;&#x3D; d 时间复杂度为：O(N^d * log(2,n)))<br>注：log(b,a) 指以b为地a为指数</li></ul><h1 id="基础的数据结构"><a href="#基础的数据结构" class="headerlink" title="基础的数据结构"></a>基础的数据结构</h1><h2 id="实现栈和队列"><a href="#实现栈和队列" class="headerlink" title="实现栈和队列"></a>实现栈和队列</h2><h3 id="用数组实现队列"><a href="#用数组实现队列" class="headerlink" title="用数组实现队列"></a>用数组实现队列</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 给定一个长度被限制数组空间，如何实现队列？public class RingArray&#123;    public static class MyQueue&#123;        private int[]arr;        private int pushi;        private int rolli;        private int size;        private final int limit;                public MyQueue(int limit)&#123;            arr &#x3D; new int[limit];            pushi &#x3D; 0;            polli &#x3D; 0;            size &#x3D; 0;            this.limit &#x3D; limit;        &#125;                public void push(int value)&#123;            if(size &#x3D;&#x3D; limit)&#123;                throw new RuntimeException(&quot;队列满了，不能再加了&quot;);            &#125;            size++;            arr[pushi] &#x3D; value;            pushi &#x3D; nextIndex(pushi);        &#125;                public int pop()&#123;            if(size &#x3D;&#x3D; 0)&#123;                throw new RuntimeException(&quot;队列空了，不能再拿了&quot;);            &#125;            int ans &#x3D; arr[rolli];            rolli &#x3D; nextIndex(rolli);            return ans;        &#125;                public boolean isEmpty()&#123;            return size &#x3D;&#x3D; 0;        &#125;                private int nextIndex(int i)&#123;            return i &lt; limit - 1 ? i + 1: 0;        &#125;    &#125;&#125;</code></pre><h3 id="数组实现一个特殊的栈，可实时返回栈中最小值"><a href="#数组实现一个特殊的栈，可实时返回栈中最小值" class="headerlink" title="数组实现一个特殊的栈，可实时返回栈中最小值"></a>数组实现一个特殊的栈，可实时返回栈中最小值</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;在基本功能上，再实现返回栈中最小元素的功能，且pop、push、getMin操作的时间复杂度是O(1).&#x2F;&#x2F;思路：维护一个栈和一个最小值栈，最小栈中存此时栈中的最小值。public class GetMinStack &#123;public static class MyStack &#123;private Stack&lt;Integer&gt; stackData;private Stack&lt;Integer&gt; stackMin;public MyStack2() &#123;this.stackData &#x3D; new Stack&lt;Integer&gt;();this.stackMin &#x3D; new Stack&lt;Integer&gt;();&#125;public void push(int newNum) &#123;if (this.stackMin.isEmpty()) &#123;this.stackMin.push(newNum);&#125; else if (newNum &lt; this.getmin()) &#123;this.stackMin.push(newNum);&#125; else &#123;int newMin &#x3D; this.stackMin.peek();this.stackMin.push(newMin);&#125;this.stackData.push(newNum);&#125;public int pop() &#123;if (this.stackData.isEmpty()) &#123;throw new RuntimeException(&quot;Your stack is empty.&quot;);&#125;this.stackMin.pop();return this.stackData.pop();&#125;public int getmin() &#123;if (this.stackMin.isEmpty()) &#123;throw new RuntimeException(&quot;Your stack is empty.&quot;);&#125;return this.stackMin.peek();&#125;&#125;&#125;</code></pre><h3 id="如何用栈实现队列"><a href="#如何用栈实现队列" class="headerlink" title="如何用栈实现队列"></a>如何用栈实现队列</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 思路：一个push栈，一个pop栈，把push栈的元素放进pop栈再取出来&#x2F;&#x2F; 为保证顺序，1、pop栈不为空时,push栈不能往pop栈里倒元素。2、push栈倒元素需要一次性倒完public class TwoStacksImplementQueue &#123;public static class TwoStacksQueue &#123;public Stack&lt;Integer&gt; stackPush;public Stack&lt;Integer&gt; stackPop;public TwoStacksQueue() &#123;stackPush &#x3D; new Stack&lt;Integer&gt;();stackPop &#x3D; new Stack&lt;Integer&gt;();&#125;&#x2F;&#x2F; push栈向pop栈倒入数据private void pushToPop() &#123;if (stackPop.empty()) &#123;while (!stackPush.empty()) &#123;stackPop.push(stackPush.pop());&#125;&#125;&#125;public void add(int pushInt) &#123;stackPush.push(pushInt);pushToPop();&#125;public int poll() &#123;if (stackPop.empty() &amp;&amp; stackPush.empty()) &#123;throw new RuntimeException(&quot;Queue is empty!&quot;);&#125;pushToPop();return stackPop.pop();&#125;public int peek() &#123;if (stackPop.empty() &amp;&amp; stackPush.empty()) &#123;throw new RuntimeException(&quot;Queue is empty!&quot;);&#125;pushToPop();return stackPop.peek();&#125;&#125;&#125;</code></pre><h3 id="如何用队列实现栈"><a href="#如何用队列实现栈" class="headerlink" title="如何用队列实现栈"></a>如何用队列实现栈</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;实现poll或peek功能是第一个队列中除最后一个元素依次取出加进另一个队列，剩下的那个就是所需要的元素public class Code07_TwoQueueImplementStack &#123;public static class TwoQueueStack&lt;T&gt; &#123;public Queue&lt;T&gt; queue;public Queue&lt;T&gt; help;public TwoQueueStack() &#123;queue &#x3D; new LinkedList&lt;&gt;();help &#x3D; new LinkedList&lt;&gt;();&#125;public void push(T value) &#123;queue.offer(value);&#125;public T poll() &#123;while (queue.size() &gt; 1) &#123;help.offer(queue.poll());&#125;T ans &#x3D; queue.poll();Queue&lt;T&gt; tmp &#x3D; queue;queue &#x3D; help;help &#x3D; tmp;return ans;&#125;public T peek() &#123;while (queue.size() &gt; 1) &#123;help.offer(queue.poll());&#125;T ans &#x3D; queue.poll();help.offer(ans);Queue&lt;T&gt; tmp &#x3D; queue;queue &#x3D; help;help &#x3D; tmp;return ans;&#125;public boolean isEmpty() &#123;return queue.isEmpty();&#125;&#125;&#125;</code></pre><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Heap &#123;public static class MyMaxHeap &#123;private int[] heap;private final int limit;private int heapSize;public MyMaxHeap(int limit) &#123;heap &#x3D; new int[limit];this.limit &#x3D; limit;heapSize &#x3D; 0;&#125;public boolean isEmpty() &#123;return heapSize &#x3D;&#x3D; 0;&#125;public boolean isFull() &#123;return heapSize &#x3D;&#x3D; limit;&#125;public void push(int value) &#123;if (heapSize &#x3D;&#x3D; limit) &#123;throw new RuntimeException(&quot;heap is full&quot;);&#125;heap[heapSize] &#x3D; value;&#x2F;&#x2F; value heapSizeheapInsert(heap, heapSize++);&#125;&#x2F;&#x2F; 返回最大值，并且在大根堆中，把最大值删掉&#x2F;&#x2F; 剩下的数，依然保持大根堆组织public int pop() &#123;int ans &#x3D; heap[0];swap(heap, 0, --heapSize);heapify(heap, 0, heapSize);return ans;&#125;private void heapInsert(int[] arr, int index) &#123;&#x2F;&#x2F; [index] [index-1]&#x2F;2&#x2F;&#x2F; index &#x3D;&#x3D; 0while (arr[index] &gt; arr[(index - 1) &#x2F; 2]) &#123;swap(arr, index, (index - 1) &#x2F; 2);index &#x3D; (index - 1) &#x2F; 2;&#125;&#125;private void heapify(int[] arr, int index, int heapSize) &#123;int left &#x3D; index * 2 + 1;while (left &lt; heapSize) &#123; &#x2F;&#x2F; 如果有左孩子，有没有右孩子，可能有可能没有！&#x2F;&#x2F; 把较大孩子的下标，给largestint largest &#x3D; left + 1 &lt; heapSize &amp;&amp; arr[left + 1] &gt; arr[left] ? left + 1 : left;largest &#x3D; arr[largest] &gt; arr[index] ? largest : index;if (largest &#x3D;&#x3D; index) &#123;break;&#125;&#x2F;&#x2F; index和较大孩子，要互换swap(arr, largest, index);index &#x3D; largest;left &#x3D; index * 2 + 1;&#125;&#125;private void swap(int[] arr, int i, int j) &#123;int tmp &#x3D; arr[i];arr[i] &#x3D; arr[j];arr[j] &#x3D; tmp;&#125;&#125;&#125;</code></pre><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>0~N-1上找到最小值与下标为0的值交换</p><p>1~N-1上找到最小值与下标为1的值交换</p><p>2~N-1上找到最小值与下标为2的值交换</p><p>······</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void selectionSort(int[] arr) &#123;if (arr &#x3D;&#x3D; null || arr.length &lt; 2) &#123;return;&#125;&#x2F;&#x2F; 0 ~ N-1  找到最小值，在哪，放到0位置上&#x2F;&#x2F; 1 ~ n-1  找到最小值，在哪，放到1 位置上&#x2F;&#x2F; 2 ~ n-1  找到最小值，在哪，放到2 位置上for (int i &#x3D; 0; i &lt; arr.length - 1; i++) &#123;int minIndex &#x3D; i;for (int j &#x3D; i + 1; j &lt; arr.length; j++) &#123; &#x2F;&#x2F; i ~ N-1 上找最小值的下标 minIndex &#x3D; arr[j] &lt; arr[minIndex] ? j : minIndex;&#125;swap(arr, i, minIndex);&#125;&#125;public static void swap(int[] arr, int i, int j) &#123;int tmp &#x3D; arr[i];arr[i] &#x3D; arr[j];arr[j] &#x3D; tmp;&#125;</code></pre><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void bubbleSort(int[] arr) &#123;if (arr &#x3D;&#x3D; null || arr.length &lt; 2) &#123;return;&#125;&#x2F;&#x2F; 0 ~ N-1&#x2F;&#x2F; 0 ~ N-2&#x2F;&#x2F; 0 ~ N-3for (int e &#x3D; arr.length - 1; e &gt; 0; e--) &#123; &#x2F;&#x2F; 0 ~ efor (int i &#x3D; 0; i &lt; e; i++) &#123;if (arr[i] &gt; arr[i + 1]) &#123;swap(arr, i, i + 1);&#125;&#125;&#125;&#125;&#x2F;&#x2F; 交换arr的i和j位置上的值，i和j是一个位置的话，会出错public static void swap(int[] arr, int i, int j) &#123;arr[i] &#x3D; arr[i] ^ arr[j];arr[j] &#x3D; arr[i] ^ arr[j];arr[i] &#x3D; arr[i] ^ arr[j];&#125;</code></pre><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void insertionSort(int[] arr) &#123;if (arr &#x3D;&#x3D; null || arr.length &lt; 2) &#123;return;&#125;&#x2F;&#x2F; 不只1个数for (int i &#x3D; 1; i &lt; arr.length; i++) &#123; &#x2F;&#x2F; 0 ~ i 做到有序for (int j &#x3D; i - 1; j &gt;&#x3D; 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) &#123;swap(arr, j, j + 1);&#125;&#125;&#125;&#x2F;&#x2F; i和j是一个位置的话，会出错public static void swap(int[] arr, int i, int j) &#123;arr[i] &#x3D; arr[i] ^ arr[j];arr[j] &#x3D; arr[i] ^ arr[j];arr[i] &#x3D; arr[i] ^ arr[j];&#125;</code></pre><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 递归方法实现public static void mergeSort1(int[] arr) &#123;if (arr &#x3D;&#x3D; null || arr.length &lt; 2) &#123;return;&#125;process(arr, 0, arr.length - 1);&#125;&#x2F;&#x2F; 请把arr[L..R]排有序&#x2F;&#x2F; l...r N&#x2F;&#x2F; T(N) &#x3D; 2 * T(N &#x2F; 2) + O(N)&#x2F;&#x2F; O(N * logN)public static void process(int[] arr, int L, int R) &#123;if (L &#x3D;&#x3D; R) &#123; &#x2F;&#x2F; base casereturn;&#125;int mid &#x3D; L + ((R - L) &gt;&gt; 1);process(arr, L, mid);process(arr, mid + 1, R);merge(arr, L, mid, R);&#125;public static void merge(int[] arr, int L, int M, int R) &#123;int[] help &#x3D; new int[R - L + 1];int i &#x3D; 0;int p1 &#x3D; L;int p2 &#x3D; M + 1;while (p1 &lt;&#x3D; M &amp;&amp; p2 &lt;&#x3D; R) &#123;help[i++] &#x3D; arr[p1] &lt;&#x3D; arr[p2] ? arr[p1++] : arr[p2++];&#125;&#x2F;&#x2F; 要么p1越界了，要么p2越界了while (p1 &lt;&#x3D; M) &#123;help[i++] &#x3D; arr[p1++];&#125;while (p2 &lt;&#x3D; R) &#123;help[i++] &#x3D; arr[p2++];&#125;for (i &#x3D; 0; i &lt; help.length; i++) &#123;arr[L + i] &#x3D; help[i];&#125;&#125;</code></pre><h3 id="变形1："><a href="#变形1：" class="headerlink" title="变形1："></a>变形1：</h3><p>给定一个数组，求出每个元素左边比他小的元素之和，再求每个元素左边比他小的元素之和的累加和，要求小于O（N^2）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static int smallSum(int[] arr) &#123;if (arr &#x3D;&#x3D; null || arr.length &lt; 2) &#123;return 0;&#125;return process(arr, 0, arr.length - 1);&#125;&#x2F;&#x2F; arr[L..R]既要排好序，也要求小和返回&#x2F;&#x2F; 所有merge时，产生的小和，累加&#x2F;&#x2F; 左 排序   merge&#x2F;&#x2F; 右 排序  merge&#x2F;&#x2F; mergepublic static int process(int[] arr, int l, int r) &#123;if (l &#x3D;&#x3D; r) &#123;return 0;&#125;&#x2F;&#x2F; l &lt; rint mid &#x3D; l + ((r - l) &gt;&gt; 1);return process(arr, l, mid) + process(arr, mid + 1, r) + merge(arr, l, mid, r);&#125;public static int merge(int[] arr, int L, int m, int r) &#123;int[] help &#x3D; new int[r - L + 1];int i &#x3D; 0;int p1 &#x3D; L;int p2 &#x3D; m + 1;int res &#x3D; 0;while (p1 &lt;&#x3D; m &amp;&amp; p2 &lt;&#x3D; r) &#123;res +&#x3D; arr[p1] &lt; arr[p2] ? (r - p2 + 1) * arr[p1] : 0;&#x2F;&#x2F;就多了这一行代码help[i++] &#x3D; arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];&#125;while (p1 &lt;&#x3D; m) &#123;help[i++] &#x3D; arr[p1++];&#125;while (p2 &lt;&#x3D; r) &#123;help[i++] &#x3D; arr[p2++];&#125;for (i &#x3D; 0; i &lt; help.length; i++) &#123;arr[L + i] &#x3D; help[i];&#125;return res;&#125;</code></pre><h3 id="变形2："><a href="#变形2：" class="headerlink" title="变形2："></a>变形2：</h3><p>求逆序对的数量</p><p>给定一个序列有n个数，求n个数中<a class="link"   href="https://so.csdn.net/so/search?q=%E9%80%86%E5%BA%8F&spm=1001.2101.3001.7020" >逆序<i class="fas fa-external-link-alt"></i></a>对的个数，逆序对的定义：i &lt; j &amp;&amp; a[i] &gt; a[j]。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int merge_sort(int a[], int l ,int r)&#123;    &#x2F;&#x2F;序列只有一个数    if (l &#x3D;&#x3D; r) return 0;    &#x2F;&#x2F;递归左边和右边    int mid &#x3D; l + r &gt;&gt; 1;    int res &#x3D; merge_sort(a, l , mid) + merge_sort(a, mid + 1, r);    &#x2F;&#x2F;归并的过程    int i &#x3D; l , j &#x3D; mid + 1, k &#x3D; 0;    while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r)&#123;        if (a[i] &lt;&#x3D; a[j]) t[k++] &#x3D; a[i++];        else&#123;            t[k++] &#x3D; a[j++];            res +&#x3D; mid - i + 1;        &#125;    &#125;    while (i &lt;&#x3D; mid) t[k++] &#x3D; a[i++];    while (j &lt;&#x3D; r) t[k++] &#x3D; a[j++];        &#x2F;&#x2F;还原数组    for (int i &#x3D; 0 , j &#x3D; l ; j &lt;&#x3D; r ; i ++ , j ++) a[j] &#x3D; t[i];        return res;&#125;</code></pre><h3 id="变形3："><a href="#变形3：" class="headerlink" title="变形3："></a>变形3：</h3><p><a class="link"   href="https://leetcode.cn/problems/reverse-pairs/" >翻转对<i class="fas fa-external-link-alt"></i></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;   public static int reversePairs(int[] nums) &#123;if (nums &#x3D;&#x3D; null || nums.length &lt; 2) &#123;return 0;&#125;return process(nums, 0, nums.length - 1);&#125;public static int process(int[] nums, int l, int r) &#123;if (l &#x3D;&#x3D; r) &#123;return 0;&#125;&#x2F;&#x2F; l &lt; rint mid &#x3D; l + ((r - l) &gt;&gt; 1);return process(nums, l, mid) + process(nums, mid + 1, r) + merge(nums, l, mid, r);&#125;public static int merge(int[] nums, int L, int m, int r) &#123;&#x2F;&#x2F; [L....M] [M+1....R]int ans &#x3D; 0;int windowR &#x3D; m + 1;for (int i &#x3D; L; i &lt;&#x3D; m; i++) &#123;while (windowR &lt;&#x3D; r &amp;&amp; (long) nums[i] &gt; (long) nums[windowR] * 2) &#123;windowR++;&#125;ans +&#x3D; windowR - m - 1;&#125;int[] help &#x3D; new int[r - L + 1];int i &#x3D; 0;int p1 &#x3D; L;int p2 &#x3D; m + 1;while (p1 &lt;&#x3D; m &amp;&amp; p2 &lt;&#x3D; r) &#123;help[i++] &#x3D; nums[p1] &lt;&#x3D; nums[p2] ? nums[p1++] : nums[p2++];&#125;while (p1 &lt;&#x3D; m) &#123;help[i++] &#x3D; nums[p1++];&#125;while (p2 &lt;&#x3D; r) &#123;help[i++] &#x3D; nums[p2++];&#125;for (i &#x3D; 0; i &lt; help.length; i++) &#123;nums[L + i] &#x3D; help[i];&#125;return ans;&#125;&#125;</code></pre><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HeapSort&#123;    public static void heapSort(int[] arr) &#123;if (arr &#x3D;&#x3D; null || arr.length &lt; 2) &#123;return;&#125;for (int i &#x3D; 0; i &lt; arr.length; i++) &#123; &#x2F;&#x2F; O(N)heapInsert(arr, i); &#x2F;&#x2F; O(logN)&#125;&#x2F;&#x2F; O(N)&#x2F;&#x2F;for (int i &#x3D; arr.length - 1; i &gt;&#x3D; 0; i--) &#123;&#x2F;&#x2F;heapify(arr, i, arr.length);&#x2F;&#x2F;&#125;int heapSize &#x3D; arr.length;swap(arr, 0, --heapSize);while (heapSize &gt; 0) &#123; &#x2F;&#x2F; O(N) heapify(arr, 0, heapSize); &#x2F;&#x2F; O(logN)swap(arr, 0, --heapSize); &#x2F;&#x2F; O(1)&#125;&#125;&#x2F;&#x2F; arr[index]刚来的数，往上public static void heapInsert(int[] arr, int index) &#123;while (arr[index] &gt; arr[(index - 1) &#x2F; 2]) &#123;swap(arr, index, (index - 1) &#x2F; 2);index &#x3D; (index - 1) &#x2F; 2;&#125;&#125;&#x2F;&#x2F; arr[index]位置的数，能否往下移动public static void heapify(int[] arr, int index, int heapSize) &#123;int left &#x3D; index * 2 + 1; &#x2F;&#x2F; 左孩子的下标while (left &lt; heapSize) &#123; &#x2F;&#x2F; 下方还有孩子的时候&#x2F;&#x2F; 两个孩子中，谁的值大，把下标给largestint largest &#x3D; left + 1 &lt; heapSize &amp;&amp; arr[left + 1] &gt; arr[left] ? left + 1 : left;&#x2F;&#x2F; 父和较大的孩子之间，谁的值大，把下标给largestlargest &#x3D; arr[largest] &gt; arr[index] ? largest : index;if (largest &#x3D;&#x3D; index) &#123;break;&#125;swap(arr, largest, index);index &#x3D; largest;left &#x3D; index * 2 + 1;&#125;&#125;public static void swap(int[] arr, int i, int j) &#123;int tmp &#x3D; arr[i];arr[i] &#x3D; arr[j];arr[j] &#x3D; tmp;&#125;&#125;</code></pre><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><pre class="line-numbers language-none"><code class="language-none">int a &#x3D; 7;int b &#x3D; -a &#x3D; (~a) + 1 &#x3D; -7;</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; arr中，只有一种数，出现奇数次public static void printOddTimesNum1(int[] arr) &#123;int eor &#x3D; 0;for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;eor ^&#x3D; arr[i];&#125;System.out.println(eor);&#125;&#x2F;&#x2F; arr中，有两种数，出现奇数次public static void printOddTimesNum2(int[] arr) &#123;int eor &#x3D; 0;for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;eor ^&#x3D; arr[i];&#125;&#x2F;&#x2F; a 和 b是两种数&#x2F;&#x2F; eor !&#x3D; 0&#x2F;&#x2F; eor最右侧的1，提取出来&#x2F;&#x2F; eor :     00110010110111000&#x2F;&#x2F; rightOne :00000000000001000int rightOne &#x3D; eor &amp; (-eor); &#x2F;&#x2F; 提取出最右的1int onlyOne &#x3D; 0; &#x2F;&#x2F; eor&#39;for (int i &#x3D; 0 ; i &lt; arr.length;i++) &#123;&#x2F;&#x2F;  arr[1] &#x3D;  111100011110000&#x2F;&#x2F; rightOne&#x3D;  000000000010000if ((arr[i] &amp; rightOne) !&#x3D; 0) &#123;onlyOne ^&#x3D; arr[i];&#125;&#125;System.out.println(onlyOne + &quot; &quot; + (eor ^ onlyOne));&#125;   &#x2F;&#x2F; 输入一定能够保证，数组中所有的数都出现了M次，只有一种数出现了K次   &#x2F;&#x2F; 1 &lt;&#x3D; K &lt; M   &#x2F;&#x2F; 返回这种数   public static int km(int[] arr, int k, int m) &#123;       int[] help &#x3D; new int[32];       for (int num : arr) &#123;           for (int i &#x3D; 0; i &lt; 32; i++) &#123;               help[i] +&#x3D; (num &gt;&gt; i) &amp; 1;           &#125;       &#125;       int ans &#x3D; 0;       for (int i &#x3D; 0; i &lt; 32; i++) &#123;           help[i] %&#x3D; m;           if (help[i] !&#x3D; 0) &#123;               ans |&#x3D; 1 &lt;&lt; i;           &#125;       &#125;       return ans;   &#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由于之前并未完整成体系的学习算法，在力扣刷100道题后&lt;/p&gt;
&lt;p&gt;感觉到算法知识不成体系，决定看左程云的体系学习班学习算法&lt;/p&gt;
&lt;h1 id=&quot;学习路线&quot;&gt;&lt;a href=&quot;#学习路线&quot; class=&quot;headerlink&quot; title=&quot;学习路线&quot;&gt;&lt;/a&gt;学习路</summary>
      
    
    
    
    
    <category term="算法与数据结构" scheme="https://2295237514.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>前端三件套</title>
    <link href="https://2295237514.github.io/post/%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8.html"/>
    <id>https://2295237514.github.io/post/%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8.html</id>
    <published>2022-06-30T02:44:09.000Z</published>
    <updated>2022-07-06T06:13:51.796Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><p>HTML：超文本标记语言<br>超文本：超越了文本的的限制，比普通文本更强大，除了文字信息，还可以定义图片，音频，视频等内容。<br>标记语言：由标签构成的语言</p><p>HTML运行在浏览器上，HTML标签由浏览器来解析</p><p>HTML标签都是预定义好的。例如：使用&lt;img&gt;展示图片</p><ul><li>W3C标准：网页主要由三部分组成<ul><li>结构：HTML</li><li>表现：CSS</li><li>行为：JavaScript</li></ul></li></ul><p>HTML结构：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;html&gt;    &lt;head&gt;        &lt;title&gt;&lt;&#x2F;title&gt;    &lt;&#x2F;head&gt;    &lt;body&gt;            &lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220630115827.png"></p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220630124834.png"></p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220630155628.png"></p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220630161831.png"></p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220630162724.png"></p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220630162953.png"></p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220630195445.png"></p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220702135056.png"> </p><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><p>导入方式：</p><p>1、使用“<link href="css文件地址">”引入css样式；</p><p>2、在style标签里写css样式；</p><p>3、在元素标签里使用style属性写css样式。</p><p>具体使用查W3cschool</p><h1 id="js"><a href="#js" class="headerlink" title="js"></a>js</h1><p>导入方式：</p><p>1、直接引入</p><p>&lt;script&gt;<br>alert(<code>&quot;这是js的内部引入&quot;</code>);<br>&lt;&#x2F;script&gt;</p><p>2、</p><p>定义外部js文件</p><p>&lt;script type&#x3D;”text&#x2F;javascript” src&#x3D;”demo.js”&gt;</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>结尾 ; 可有可无</p><p>使用window.alert()写入警告框</p><p>使用document.write()写入html输出</p><p>使用console.log()写入浏览器控制台</p><p>用var声明变量</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var test &#x3D; 20;test &#x3D; &quot;张三&quot;</code></pre><p>Javascript是一门弱类型语言，变量可以存放不同类型的值</p><p>变量名命名规则：</p><ul><li>组成字符可以是任何字母，数组，下划线(_)或美元符号($)</li><li>数字不能开头</li><li>建议使用驼峰命名</li></ul><p>ECMAScript6新增了let关键字来定义变量，它的用法类似于var，但是所声明的变量，只在let关键字所在的代码块内有效，且不允许重复声明</p><p>ECMAScript6新增了const关键字，用来声明一个只读的常量。一旦声明，常量的值就不能改变了</p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220704151254.png"></p><p>运算符 &#x3D;&#x3D;  和  &#x3D;&#x3D;&#x3D; </p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var age1 &#x3D; 20;var age2 &#x3D; &quot;20&quot;;alert(age1 &#x3D;&#x3D; age2) &#x2F;&#x2F;会返回truealert(age1 &#x3D;&#x3D;&#x3D; age2) &#x2F;&#x2F;会返回false&#x2F;*&#x3D;&#x3D; ：1.判断类型是否一样，如果不一样，先转换成一样    2.再判断是否相等&#x3D;&#x3D;&#x3D;：1.判断类型是否一样，如果不一样，直接返回false2.再判断是否相等*&#x2F;</code></pre><p>类型转换：<br>其他类型转为number：</p><ol><li>string: 按照字符串的字面值，转为数字.如果字面值不是数字，则转为NaN。一般使用parseInt</li><li>boolean: true 转为1，false转为0</li></ol><p>其他类型转为boolean：</p><ol><li>number:0和NaN转为false，其他的数字转为true </li><li>string:空字符串转为false，其他的字符串转为true </li><li>null:false </li><li>undefined:false</li></ol><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220704153408.png"></p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220704154040.png"></p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220704154326.png"></p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220704155618.png"></p><h3 id="自定义对象"><a href="#自定义对象" class="headerlink" title="自定义对象"></a>自定义对象</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220704155934.png"></p><h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><p>BOM：Browser Object Model 浏览器对象模型。也就是 JavaScript 将浏览器的各个组成部分封装为对象。</p><p>我们要操作浏览器的各个组成部分就可以通过操作 BOM 中的对象来实现。比如：我现在想将浏览器地址栏的地址改为 <code>https://www.itheima.com</code> 就可以通过使用 BOM 中定义的 <code>Location</code> 对象的 <code>href</code> 属性，代码： <code>location.href = &quot;https://itheima.com&quot;;</code> </p><p> BOM 中包含了如下对象：</p><ul><li>Window：浏览器窗口对象</li><li>Navigator：浏览器对象</li><li>Screen：屏幕对象</li><li>History：历史记录对象</li><li>Location：地址栏对象</li></ul><p>下图是 BOM 中的各个对象和浏览器的各个组成部分的对应关系</p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220704160609.png"></p><h4 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h4><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220704161016.png"></p><h4 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h4><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220704163202.png"></p><h4 id="loaction对象"><a href="#loaction对象" class="headerlink" title="loaction对象"></a>loaction对象</h4><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220704163325.png"></p><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>DOM：Document Object Model 文档对象模型。也就是 JavaScript 将 HTML 文档的各个组成部分封装为对象。</p><p>DOM 其实我们并不陌生，之前在学习 XML 就接触过，只不过 XML 文档中的标签需要我们写代码解析，而 HTML 文档是浏览器解析。封装的对象分为</p><ul><li>Document：整个文档对象</li><li>Element：元素对象</li><li>Attribute：属性对象</li><li>Text：文本对象</li><li>Comment：注释对象</li></ul><p>如下图，左边是 HTML 文档内容，右边是 DOM 树</p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220704164451.png"></p><p><strong>作用：</strong></p><p>JavaScript 通过 DOM， 就能够对 HTML进行操作了</p><ul><li>改变 HTML 元素的内容</li><li>改变 HTML 元素的样式（CSS）</li><li>对 HTML DOM 事件作出反应</li><li>添加和删除 HTML 元素</li></ul><p><strong>DOM相关概念：</strong></p><p>DOM 是 W3C（万维网联盟）定义了访问 HTML 和 XML 文档的标准。该标准被分为 3 个不同的部分：</p><ol><li><p>核心 DOM：针对任何结构化文档的标准模型。 XML 和 HTML 通用的标准</p><ul><li><p>Document：整个文档对象</p></li><li><p>Element：元素对象</p></li><li><p>Attribute：属性对象</p></li><li><p>Text：文本对象</p></li><li><p>Comment：注释对象</p></li></ul></li><li><p>XML DOM： 针对 XML 文档的标准模型</p></li><li><p>HTML DOM： 针对 HTML 文档的标准模型</p><p>该标准是在核心 DOM 基础上，对 HTML 中的每个标签都封装成了不同的对象</p><ul><li>例如：<code>&lt;img&gt;</code> 标签在浏览器加载到内存中时会被封装成 <code>Image</code> 对象，同时该对象也是 <code>Element</code> 对象。</li><li>例如：<code>&lt;input type=&#39;button&#39;&gt;</code> 标签在浏览器加载到内存中时会被封装成 <code>Button</code> 对象，同时该对象也是 <code>Element</code> 对象。</li></ul></li></ol><h4 id="获取Element对象"><a href="#获取Element对象" class="headerlink" title="获取Element对象"></a>获取Element对象</h4><p>HTML 中的 Element 对象可以通过 <code>Document</code> 对象获取，而 <code>Document</code> 对象是通过 <code>window</code> 对象获取。</p><p><code>Document</code> 对象中提供了以下获取 <code>Element</code> 元素对象的函数</p><ul><li><code>getElementById()</code>：根据id属性值获取，返回单个Element对象</li><li><code>getElementsByTagName()</code>：根据标签名称获取，返回Element对象数组</li><li><code>getElementsByName()</code>：根据name属性值获取，返回Element对象数组</li><li><code>getElementsByClassName()</code>：根据class属性值获取，返回Element对象数组</li></ul><h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><ul><li><p>事件：HTML事件是发生在HTML元素身上的“事情”。比如：</p><ul><li>按钮被点击</li><li>鼠标移动到元素之上</li><li>按下键盘按键</li></ul></li><li><p>事件监听：Javascript可以在事件被侦测到时执行代码</p></li></ul><h4 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h4><p>方式一：通过 HTML标签中的事件属性进行绑定</p><p><code>onclick</code> 是 <code>单击事件</code> 的事件属性</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;input type&#x3D;&quot;button&quot; onclick&#x3D;&#39;on()’&gt;function on()&#123;alert(&quot;我被点了&quot;);&#125;</code></pre><p>方式二：通过 DOM 元素属性绑定</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;input type&#x3D;&quot;button&quot; id&#x3D;&quot;btn&quot;&gt;document.getElementById(&quot;btn&quot;).onclick &#x3D; function ()&#123;    alert(&quot;我被点了&quot;);&#125;</code></pre><p><strong>为保证单一职责，建议使用方式二</strong></p><h4 id="常见事件"><a href="#常见事件" class="headerlink" title="常见事件"></a>常见事件</h4><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220704173428.png"></p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则对象有两种创建方式：</p><ul><li><p>直接量方式：注意不要加引号</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">var reg &#x3D; &#x2F;正则表达式&#x2F;;</code></pre></li><li><p>创建 RegExp 对象</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">var reg &#x3D; new RegExp(&quot;正则表达式&quot;);</code></pre></li></ul><p><code>test(str)</code> ：判断指定字符串是否符合规则，返回 true或 false</p><p>从上面创建正则对象的格式中可以看出不管哪种方式都需要正则表达式，那么什么是正则表达式呢？</p><p>正则表达式定义了字符串组成的规则。也就是判断指定的字符串是否符合指定的规则，如果符合返回true，如果不符合返回false。</p><p>正则表达式是和语言无关的。很多语言都支持正则表达式，Java语言也支持，只不过正则表达式在不同的语言中的使用方式不同，js 中需要使用正则对象来使用正则表达式。</p><p>正则表达式常用的规则如下：</p><ul><li><p>^：表示开始</p></li><li><p>$：表示结束</p></li><li><p>[ ]：代表某个范围内的单个字符，比如： [0-9] 单个数字字符</p></li><li><p>.：代表任意单个字符，除了换行和行结束符</p></li><li><p>\w：代表单词字符：字母、数字、下划线(<em>)，相当于 [A-Za-z0-9</em>]</p></li><li><p>\d：代表数字字符： 相当于 [0-9]</p></li></ul><p>量词：</p><ul><li><p>+：至少一个</p></li><li><p>*：零个或多个</p></li><li><p>？：零个或一个</p></li><li><p>{x}：x个</p></li><li><p>{m,}：至少m个</p></li><li><p>{m,n}：至少m个，最多n个</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; title=&quot;HTML&quot;&gt;&lt;/a&gt;HTML&lt;/h1&gt;&lt;p&gt;HTML：超文本标记语言&lt;br&gt;超文本：超越了文本的的限制，比普通文本更强大，除了文字信息，还可以定义图片，音频，视频等内容</summary>
      
    
    
    
    
    <category term="前端" scheme="https://2295237514.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis</title>
    <link href="https://2295237514.github.io/post/Mybatis.html"/>
    <id>https://2295237514.github.io/post/Mybatis.html</id>
    <published>2022-06-07T08:06:27.000Z</published>
    <updated>2022-07-26T07:18:33.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="入门-MyBatis中文网"><a href="#入门-MyBatis中文网" class="headerlink" title="入门_MyBatis中文网"></a><a class="link"   href="https://mybatis.net.cn/getting-started.html" >入门_MyBatis中文网<i class="fas fa-external-link-alt"></i></a></h1><h1 id="Mybatis-pdf"><a href="#Mybatis-pdf" class="headerlink" title="(Mybatis.pdf)"></a><a target="_blank" href="\doc\Mybatis.pdf ">(Mybatis.pdf)</h1><h1 id="什么是Mybatis？"><a href="#什么是Mybatis？" class="headerlink" title="什么是Mybatis？"></a>什么是Mybatis？</h1><ul><li>Mybatis是一款优秀的持久层框架，用于简化JDBC开发</li><li>官网：https://mybatis.org/mybatis-3/zh/index.html</li></ul><p>持久层：</p><ul><li><p>负责将数据保存到数据库的那一层代码</p></li><li><p>JavaEE三层架构：表现层，业务层，持久层</p></li></ul><p>框架：</p><ul><li><p>框架就是一个半成品软件，是一套可重用的、通用的、软件基础代码模型</p></li><li><p>在框架的基础之上构建软件编写更加高效、规范、通用、可扩展</p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220613105156.png"></p></li></ul><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220614171032.png"></p><p>JDBC写的是硬编码，后期维护很麻烦，无论是增删改查语句的修改，或者是用户名密码的改变，</p><p>MyBatis虽然麻烦，不过很多步骤只做一次，后期维护非常的方便</p><h1 id="解决SQL映射文件的警告提示"><a href="#解决SQL映射文件的警告提示" class="headerlink" title="解决SQL映射文件的警告提示"></a>解决SQL映射文件的警告提示</h1><p>产生原因：IDEA和数据库没有建立连接，不识别表信息</p><p>解决方法：在IDEA中配置MySQL数据库连接</p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220617151401.png"></p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220617150956.png"></p><h1 id="Mapper代理开发"><a href="#Mapper代理开发" class="headerlink" title="Mapper代理开发"></a>Mapper代理开发</h1><ul><li><p>目的</p><p>1.解决原生方式中的硬编码</p><p>2.简化后期执行SQL</p></li><li><p>步骤</p><p>1.定义与SQL映射文件同名的Mapper接口，并且将Mapper接口和SQL映射文件放置在同一目录下</p><p>2.设置SQL映射文件的namespace属性为Mapper接口全限定名</p><p>3.在Mapper接口中定义方法，方法名就是SQL映射文件中sql语句的id，并保持参数类型和返回值类型一致</p><p>4.编码</p><ul><li>通过SqlSession的getMapper方法获取Mapper接口的代理对象</li><li>调用对应方法完成sql的执行</li></ul></li><li><p>细节</p><p>如果Mapper接口名称和SQL映射文件名称相同，并在同一目录下，则可以使用包扫描的方式简化SQL映射文件的加载</p><pre class="line-numbers language-none"><code class="language-none">&lt;mappers&gt;&lt;!--        加载sql映射文件--&gt;&lt;!--        &lt;mapper resource&#x3D;&quot;UserMapper.xml&quot;&#x2F;&gt;--&gt;&lt;!--        Mapper代理方式--&gt;        &lt;package name&#x3D;&quot;com.itheima.mapper&quot;&#x2F;&gt;    &lt;&#x2F;mappers&gt;</code></pre></li></ul><h1 id="Mybatis核心配置文件详解"><a href="#Mybatis核心配置文件详解" class="headerlink" title="Mybatis核心配置文件详解"></a>Mybatis核心配置文件详解</h1><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220623153933.png"></p><h1 id="注解完成增删改查"><a href="#注解完成增删改查" class="headerlink" title="注解完成增删改查"></a>注解完成增删改查</h1><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220629172605.png"></p><p>注解即在接口方法上直接写SQL语句，不用在xml文件中再配置</p><h1 id="配置文件完成增删改查"><a href="#配置文件完成增删改查" class="headerlink" title="配置文件完成增删改查"></a>配置文件完成增删改查</h1><p>起别名</p><p>定义&lt;sql&gt;片段</p><p>定义&lt;resultMap&gt;片段</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>参数占位符</li></ol><p>​      #{}: 执行SQL时，会将#{}占位符替换为?，将来自动设置参数值</p><p>​      ${}: 拼SQL。会存在SQL注入问题</p><p>​      使用时机：</p><p>​      参数传递，都是用#{}</p><p>​      如果要对表名，列名进行动态设置，只能使用${}进行sql拼接</p><p>2.parameterType</p><p>​用于设置参数类型，该参数可以省略</p><p>3.SQL语句中特殊字符处理</p><p>​转义字符</p><p>&lt;![CDATA[内容]]&gt;</p><h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h2><p>if标签：用于判断参数是否有值，使用test属性进行条件判断</p><ul><li><p>存在的问题：第一个条件不需要逻辑运算符</p></li><li><p>解决方案：</p><ul><li><p>使用恒等式让所有条件格式都一样</p><pre class="line-numbers language-none"><code class="language-none">&lt;select id&#x3D;&quot;selectByCondition&quot; resultMap&#x3D;&quot;brandResultMap&quot;&gt;        select *        from tb_brandwhere 1 &#x3D; 1        &lt;if test&#x3D;&quot;status !&#x3D; null&quot;&gt;and status &#x3D; #&#123;status&#125;&lt;&#x2F;if&gt;        &lt;if test&#x3D;&quot;companyName !&#x3D; null and companyName !&#x3D; &#39;&#39;&quot;&gt;and company_name like #&#123;companyName&lt;&#x2F;if&gt;        &lt;if test&#x3D;&quot;brandName !&#x3D; null and brandName !&#x3D; &#39;&#39;&quot;&gt;and brand_name like #&#123;brandName&#125;&lt;&#x2F;if&gt;    &lt;&#x2F;select&gt;</code></pre></li><li><p>&lt;where&gt;标签替换where关键字</p><pre class="line-numbers language-none"><code class="language-none">&lt;select id&#x3D;&quot;selectByCondition&quot; resultMap&#x3D;&quot;brandResultMap&quot;&gt;        select *        from tb_brand&lt;where&gt;        &lt;if test&#x3D;&quot;status !&#x3D; null&quot;&gt; status &#x3D; #&#123;status&#125;&lt;&#x2F;if&gt;        &lt;if test&#x3D;&quot;companyName !&#x3D; null and companyName !&#x3D; &#39;&#39;&quot;&gt;and company_name like #&#123;companyName&lt;&#x2F;if&gt;        &lt;if test&#x3D;&quot;brandName !&#x3D; null and brandName !&#x3D; &#39;&#39;&quot;&gt;and brand_name like #&#123;brandName&#125;&lt;&#x2F;if&gt;&lt;&#x2F;where&gt;    &lt;&#x2F;select&gt;</code></pre></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220629122136.png"></p><h3 id="事务提交"><a href="#事务提交" class="headerlink" title="事务提交"></a>事务提交</h3><p>自动提交</p><pre class="line-numbers language-none"><code class="language-none">SqlSession sqlSession &#x3D; sqlSessionFactory.openSession(true);</code></pre><p>手动提交</p><pre class="line-numbers language-none"><code class="language-none">SqlSession sqlSession &#x3D; sqlSessionFactory.openSession();或SqlSession sqlSession &#x3D; sqlSessionFactory.openSession(false);事务后写sqlSession.commit();</code></pre><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220629143452.png"></p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220629143541.png"></p><p>返回添加数据的主键</p><pre class="line-numbers language-none"><code class="language-none">&lt;insert useGeneratedKeys &#x3D; &quot;true&quot; keyProperty &#x3D; &quot;id&quot;&gt; </code></pre><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220629145907.png"></p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220629151218.png"></p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220629152103.png"></p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220629153154.png"></p><p>上图（批量删除） 如果接口方法未加param注解，collection属性的值应该为array</p><h1 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h1><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220629165852.png">  </p><h1 id="参数封装"><a href="#参数封装" class="headerlink" title="参数封装"></a>参数封装</h1><pre class="line-numbers language-none"><code class="language-none">MyBatis 参数封装：   单个参数：      1. POJO类型：直接使用，属性名 和 参数占位符名称 一致      2. Map集合：直接使用，键名 和 参数占位符名称 一致      3. Collection：封装为Map集合，可以使用@Param注解，替换Map集合中默认的arg键名          map.put(&quot;arg0&quot;,collection集合);          map.put(&quot;collection&quot;,collection集合);      4. List：封装为Map集合，可以使用@Param注解，替换Map集合中默认的arg键名          map.put(&quot;arg0&quot;,list集合);          map.put(&quot;collection&quot;,list集合);          map.put(&quot;list&quot;,list集合);      5. Array：封装为Map集合，可以使用@Param注解，替换Map集合中默认的arg键名          map.put(&quot;arg0&quot;,数组);          map.put(&quot;array&quot;,数组);      6. 其他类型：直接使用   多个参数：封装为Map集合,可以使用@Param注解，替换Map集合中默认的arg键名      map.put(&quot;arg0&quot;,参数值1)      map.put(&quot;param1&quot;,参数值1)      map.put(&quot;param2&quot;,参数值2)      map.put(&quot;agr1&quot;,参数值2)      ---------------@Param(&quot;username&quot;)      map.put(&quot;username&quot;,参数值1)      map.put(&quot;param1&quot;,参数值1)      map.put(&quot;param2&quot;,参数值2)      map.put(&quot;agr1&quot;,参数值2) </code></pre><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220629172031.png"></p><h1 id="使用中出现的问题（注意）"><a href="#使用中出现的问题（注意）" class="headerlink" title="使用中出现的问题（注意）"></a>使用中出现的问题（注意）</h1><ol><li>不加@Param注解，取值的时候直接写属性</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void addUser(User user);&lt;insert id&#x3D;&quot;addUser&quot; parameterType&#x3D;&quot;com.xxxx.mybatis.entity.User&quot;&gt;    insert into user(id,user_name,name,birthday,age)    values (#&#123;id&#125;,#&#123;userName&#125;,#&#123;name&#125;,#&#123;birthday&#125;,#&#123;age&#125;)&lt;&#x2F;insert&gt;</code></pre><ol><li>加了@Param注解，取值必须使用对象.属性的方式</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void addUser(@Param(&quot;user&quot;) User user);&lt;insert id&#x3D;&quot;addUser&quot; parameterType&#x3D;&quot;com.xxxx.mybatis.entity.User&quot;&gt;    insert into user(id,user_name,name,birthday,age)    values (#&#123;user.id&#125;,#&#123;user.userName&#125;,#&#123;user.name&#125;,#&#123;user.birthday&#125;,#&#123;user.age&#125;)&lt;&#x2F;insert&gt;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;入门-MyBatis中文网&quot;&gt;&lt;a href=&quot;#入门-MyBatis中文网&quot; class=&quot;headerlink&quot; title=&quot;入门_MyBatis中文网&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot;   href=&quot;https://mybatis.net.cn/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Maven</title>
    <link href="https://2295237514.github.io/post/Maven.html"/>
    <id>https://2295237514.github.io/post/Maven.html</id>
    <published>2022-05-18T08:50:49.000Z</published>
    <updated>2022-09-27T08:56:13.164Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Maven是专门用于管理和构建java项目的工具<h1 id="Maven基础"><a href="#Maven基础" class="headerlink" title="Maven基础"></a>Maven基础</h1><h2 id="Maven的功能"><a href="#Maven的功能" class="headerlink" title="Maven的功能"></a>Maven的功能</h2></li></ul><p>1、提供了一套标准化的项目结构</p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220518171851.png"></p><p>2、提供了一套标准化的构建流程（编译，测试，打包，发布……）</p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220523160341.png"></p><p>3、提供了一套依赖管理机制</p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220527130234.png"></p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220527132204.png"></p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220527134137.png"></p><h2 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h2><ul><li>compile 编译</li><li>clean 清理</li><li>test 测试</li><li>package 打包</li><li>install 安装</li></ul><h2 id="IDEA配置Maven"><a href="#IDEA配置Maven" class="headerlink" title="IDEA配置Maven"></a>IDEA配置Maven</h2><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220604070638.png"></p><h2 id="Maven坐标详解"><a href="#Maven坐标详解" class="headerlink" title="Maven坐标详解"></a>Maven坐标详解</h2><ul><li><p>什么是坐标：</p><ul><li><p>Maven中的坐标是资源的唯一标识</p></li><li><p>使用坐标来定义项目或引入项目中需要的依赖</p></li></ul></li><li><p>Maven坐标的主要组成</p><ul><li>groupld：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima）</li><li>artifactld：定义当前Maven项目名称（通常是模块名称）</li><li>version：定义当前项目版本号</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220604074342.png"></p><h2 id="IDEA创建Maven项目"><a href="#IDEA创建Maven项目" class="headerlink" title="IDEA创建Maven项目"></a>IDEA创建Maven项目</h2><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220604074516.png"></p><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><h3 id="使用坐标导入jar包"><a href="#使用坐标导入jar包" class="headerlink" title="使用坐标导入jar包"></a>使用坐标导入jar包</h3><p>1.在pom.xml中编写&lt;dependencies&gt;标签</p><p>2.在&lt;dependencies&gt;标签中 使用&lt;dependency&gt;引入坐标</p><p>3.定义坐标的groupid，artifactld，version</p><p>4.点击刷新按钮，使坐标生效(建议配置自动生效，无需刷新)</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependencies&gt;    &lt;dependency&gt;      &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;      &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;      &lt;version&gt;4.11&lt;&#x2F;version&gt;      &lt;scope&gt;test&lt;&#x2F;scope&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;      &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;      &lt;version&gt;5.1.48&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;  &lt;&#x2F;dependencies&gt;</code></pre><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220604093854.png"></p><h3 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h3><p> <img src="https://raw.githubusercontent.com/2295237514/image/main/20220604100410.png"></p><h1 id="Maven进阶"><a href="#Maven进阶" class="headerlink" title="Maven进阶"></a>Maven进阶</h1><h2 id="分模块开发与设计"><a href="#分模块开发与设计" class="headerlink" title="分模块开发与设计"></a>分模块开发与设计</h2><ul><li>将原始模块按照功能拆分成若干个子模块，方便模块间的相互调用，接口共享</li></ul><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220922135648.png"></p><p>步骤：</p><p>1.创建Maven模块</p><p>2.书写模块代码</p><p>3.通过maven指令安装模块到本地仓库（install指令）</p><h2 id="依赖管理-1"><a href="#依赖管理-1" class="headerlink" title="依赖管理"></a>依赖管理</h2><ul><li><p>依赖具有传递性</p><ul><li>直接依赖：在当前项目中通过依赖配置建立的依赖关系</li><li>间接依赖：被依赖的资源如果依赖其他资源，当前项目间接依赖其他资源</li></ul></li><li><p>依赖传递冲突问题</p><ul><li>路径优先：当依赖中出现相同的资源时，层级越深，优先级越低，层级越浅，优先级越高</li><li>声明优先：当资源在相同层级被依赖时，配置顺序靠前的覆盖配置顺序靠后的</li><li>特殊优先：当同级配置了相同资源的不同版本，后配置的覆盖先配置的</li></ul></li><li><p>可选依赖</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependency&gt;      &lt;groupId&gt;com.itheima&lt;&#x2F;groupId&gt;      &lt;artifactId&gt;maven_03_pojo&lt;&#x2F;artifactId&gt;      &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;      &lt;!--可选依赖是隐藏当前工程所依赖的资源，隐藏后对应资源将不具有依赖传递--&gt;      &lt;optional&gt;true&lt;&#x2F;optional&gt;  &lt;&#x2F;dependency&gt;</code></pre></li><li><p>排除依赖</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependency&gt;    &lt;groupId&gt;com.itheima&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;maven_04_dao&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;    &lt;!--排除依赖是隐藏当前资源对应的依赖关系--&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;groupId&gt;com.itheima&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;maven_03_pojo&lt;&#x2F;artifactId&gt;        &lt;&#x2F;exclusion&gt;    &lt;&#x2F;exclusions&gt;&lt;&#x2F;dependency&gt;</code></pre></li></ul><p><em>简单来梳理下，就是</em></p><ul><li><code>A依赖B,B依赖C</code>,<code>C</code>通过依赖传递会被<code>A</code>使用到，现在要想办法让<code>A</code>不去依赖<code>C</code></li><li>可选依赖是在B上设置<code>&lt;optional&gt;</code>,<code>A</code>不知道有<code>C</code>的存在，</li><li>排除依赖是在A上设置<code>&lt;exclusions&gt;</code>,<code>A</code>知道有<code>C</code>的存在，主动将其排除掉。</li></ul><h2 id="聚合-与-继承"><a href="#聚合-与-继承" class="headerlink" title="聚合 与 继承"></a>聚合 与 继承</h2><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220922152415.png"></p><p>聚合项目的打包方式为<strong>POM</strong>，并添加所要管理的项目</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;    &lt;groupId&gt;com.itheima&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;maven_01_parent&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.0-RELEASE&lt;&#x2F;version&gt;    &lt;packaging&gt;pom&lt;&#x2F;packaging&gt;            &lt;!--设置管理的模块名称--&gt;    &lt;modules&gt;        &lt;module&gt;..&#x2F;maven_02_ssm&lt;&#x2F;module&gt;        &lt;module&gt;..&#x2F;maven_03_pojo&lt;&#x2F;module&gt;        &lt;module&gt;..&#x2F;maven_04_dao&lt;&#x2F;module&gt;    &lt;&#x2F;modules&gt;&lt;&#x2F;project&gt;</code></pre><ul><li>jar:默认情况，说明该项目为java项目</li><li>war:说明该项目为web项目</li><li>pom:说明该项目为聚合或继承(后面会讲)项目</li></ul><p>使用聚合统一管理项目</p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220922153405.png"></p><p>测试发现，当<code>maven_01_parent</code>的<code>compile</code>被点击后，所有被其管理的项目都会被执行编译操作。这就是聚合工程的作用。</p><p><strong>说明：</strong>聚合工程管理的项目在进行运行的时候，会按照项目与项目之间的依赖关系来自动决定执行的顺序和配置的顺序无关。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li>所谓继承:描述的是两个工程间的关系，与java中的继承相似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承。</li><li>作用：<ul><li>简化配置</li><li>减少版本冲突</li></ul></li></ul><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li><p>创建maven模块，设置打包方式为pom</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;packaging&gt;pom&lt;&#x2F;packaging&gt;</code></pre></li><li><p>在父工程的pom文件中配置依赖关系(子工程将沿用父工程中的依赖关系)</p></li><li><p>配置子工程中可选的依赖关系</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependencyManagement&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;            &lt;version&gt;1.1.16&lt;&#x2F;version&gt;        &lt;&#x2F;dependency&gt;    &lt;&#x2F;dependencies&gt;    ...&lt;&#x2F;dependencyManagement&gt;</code></pre></li><li><p>在子工程中配置当前工程所继承的父工程</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!--定义该工程的父工程--&gt;&lt;parent&gt;    &lt;groupId&gt;com.itheima&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;maven_01_parent&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.0-RELEASE&lt;&#x2F;version&gt;    &lt;!--填写父工程的pom文件,可以不写--&gt;    &lt;relativePath&gt;..&#x2F;maven_01_parent&#x2F;pom.xml&lt;&#x2F;relativePath&gt;&lt;&#x2F;parent&gt;</code></pre></li><li><p>在子工程中配置父工程中可选依赖的坐标</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;</code></pre></li></ol><p><strong>注意事项:</strong></p><p>1.子工程中使用父工程中的可选依赖时，仅需要提供群组id和项目id，无需提供版本，版本由父工程统一提供，避免版本冲突</p><p>2.子工程中还可以定义父工程中没有定义的依赖关系,只不过不能被父工程进行版本统一管理。</p><hr><h3 id="聚合和继承的区别"><a href="#聚合和继承的区别" class="headerlink" title="聚合和继承的区别"></a>聚合和继承的区别</h3><ul><li>作用：<ul><li>聚合用于快速构建项目</li><li>继承用于快速配置</li></ul></li><li>相同点：<ul><li>聚合与继承的pom.xml文件打包方式均为pom，可以将两种关系制作到同一个pom文件中</li><li>聚合和继承均属于设计型模块，并无实际的内容模块</li></ul></li><li>不同点：<ul><li>聚合是在当前模块中配置关系，聚合可以感知到参与聚合的模块有哪些</li><li>继承是在子模块中配置关系，父模块无法感知哪些子模块继承了自己</li></ul></li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>如果我们现在想更新Spring的版本 如何保证多个jar包版本的统一？</p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220924094236.png"></p><p>步骤1:父工程的pom.xml中定义属性</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;properties&gt;    &lt;spring.version&gt;5.2.10.RELEASE&lt;&#x2F;spring.version&gt;    &lt;junit.version&gt;4.12&lt;&#x2F;junit.version&gt;    &lt;mybatis-spring.version&gt;1.3.0&lt;&#x2F;mybatis-spring.version&gt;&lt;&#x2F;properties&gt;</code></pre><p>步骤2:修改依赖的version</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-core&lt;&#x2F;artifactId&gt;    &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;    &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt;    &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre><p>此时，我们只需要更新父工程中properties标签中所维护的jar包版本，所有子项目中的版本也就跟着更新。</p><h3 id="配置文件加载属性"><a href="#配置文件加载属性" class="headerlink" title="配置文件加载属性"></a>配置文件加载属性</h3><h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><h5 id="步骤1-父工程定义属性"><a href="#步骤1-父工程定义属性" class="headerlink" title="步骤1:父工程定义属性"></a>步骤1:父工程定义属性</h5><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;properties&gt;   &lt;jdbc.url&gt;jdbc:mysql:&#x2F;&#x2F;127.1.1.1:3306&#x2F;ssm_db&lt;&#x2F;jdbc.url&gt;&lt;&#x2F;properties&gt;</code></pre><h5 id="步骤2-jdbc-properties文件中引用属性"><a href="#步骤2-jdbc-properties文件中引用属性" class="headerlink" title="步骤2:jdbc.properties文件中引用属性"></a>步骤2:jdbc.properties文件中引用属性</h5><p>在jdbc.properties，将jdbc.url的值直接获取Maven配置的属性</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">jdbc.driver&#x3D;com.mysql.jdbc.Driverjdbc.url&#x3D;$&#123;jdbc.url&#125;jdbc.username&#x3D;rootjdbc.password&#x3D;root</code></pre><h5 id="步骤3-设置maven过滤文件范围"><a href="#步骤3-设置maven过滤文件范围" class="headerlink" title="步骤3:设置maven过滤文件范围"></a>步骤3:设置maven过滤文件范围</h5><p>Maven在默认情况下是从当前项目的<code>src\main\resources</code>下读取文件进行打包。现在我们需要打包的资源文件是在maven_02_ssm下,需要我们通过配置来指定下具体的资源目录。</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;build&gt;    &lt;resources&gt;        &lt;!--设置资源目录--&gt;        &lt;resource&gt;            &lt;directory&gt;..&#x2F;maven_02_ssm&#x2F;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;            &lt;!--设置能够解析$&#123;&#125;，默认是false --&gt;            &lt;filtering&gt;true&lt;&#x2F;filtering&gt;        &lt;&#x2F;resource&gt;    &lt;&#x2F;resources&gt;&lt;&#x2F;build&gt;</code></pre><p>**说明:**directory路径前要添加<code>../</code>的原因是maven_02_ssm相对于父工程的pom.xml路径是在其上一层的目录中，所以需要添加。</p><p>修改完后，注意maven_02_ssm项目的resources目录就多了些东西，如下:</p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220925101433.png"></p><h5 id="步骤4-测试是否生效"><a href="#步骤4-测试是否生效" class="headerlink" title="步骤4:测试是否生效"></a>步骤4:测试是否生效</h5><p>测试的时候，只需要将maven_02_ssm项目进行打包，然后观察打包结果中最终生成的内容是否为Maven中配置的内容。</p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220925101517.png"></p><p>上面的属性管理就已经完成，但是有一个问题没有解决，因为不只是maven_02_ssm项目需要有属性被父工程管理，如果有多个项目需要配置，该如何实现呢?</p><p>方式一:</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;build&gt;    &lt;resources&gt;        &lt;!--设置资源目录，并设置能够解析$&#123;&#125;--&gt;        &lt;resource&gt;            &lt;directory&gt;..&#x2F;maven_02_ssm&#x2F;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;            &lt;filtering&gt;true&lt;&#x2F;filtering&gt;        &lt;&#x2F;resource&gt;        &lt;resource&gt;            &lt;directory&gt;..&#x2F;maven_03_pojo&#x2F;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;            &lt;filtering&gt;true&lt;&#x2F;filtering&gt;        &lt;&#x2F;resource&gt;        ...    &lt;&#x2F;resources&gt;&lt;&#x2F;build&gt;</code></pre><p>可以配，但是如果项目够多的话，这个配置也是比较繁琐</p><p>方式二:</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;build&gt;    &lt;resources&gt;        &lt;!--$&#123;project.basedir&#125;: 当前项目所在目录,子项目继承了父项目，相当于所有的子项目都添加了资源目录的过滤--&gt;        &lt;resource&gt;            &lt;directory&gt;$&#123;project.basedir&#125;&#x2F;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;            &lt;filtering&gt;true&lt;&#x2F;filtering&gt;        &lt;&#x2F;resource&gt;    &lt;&#x2F;resources&gt;&lt;&#x2F;build&gt;</code></pre><p>**说明:**打包的过程中如果报如下错误:</p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220925101605.png"></p><p>原因就是Maven发现你的项目为web项目，就会去找web项目的入口web.xml[配置文件配置的方式]，发现没有找到，就会报错。</p><p>解决方案1：在maven_02_ssm项目的<code>src\main\webapp\WEB-INF\</code>添加一个web.xml文件</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_3_1.xsd&quot;         version&#x3D;&quot;3.1&quot;&gt;&lt;&#x2F;web-app&gt;</code></pre><p>上面我们所使用的都是Maven的自定义属性，除了${project.basedir},它属于Maven的内置系统属性。</p><p>在Maven中的属性分为:</p><ul><li>自定义属性（常用）</li><li>内置属性</li><li>Setting属性</li><li>Java系统属性</li><li>环境变量属性</li></ul><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220925101720.png"></p><p>具体如何查看这些属性:</p><p>在cmd命令行中输入<code>mvn help:system</code></p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220925101751.png"></p><p>具体使用，就是使用 <code>$&#123;key&#125;</code>来获取，key为等号左边的，值为等号右边的，比如获取红线的值，对应的写法为 <code>$&#123;java.runtime.name&#125;</code>。</p><h3 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h3><p>在我们jar包的版本定义中，有两个工程版本用的比较多:</p><ul><li>SNAPSHOT（快照版本）<ul><li>项目开发过程中临时输出的版本，称为快照版本</li><li>快照版本会随着开发的进展不断更新</li></ul></li><li>RELEASE（发布版本）<ul><li>项目开发到一定阶段里程碑后，向团队外部发布较为稳定的版本，这种版本所对应的构件文件是稳定的</li><li>即便进行功能的后续开发，也不会改变当前发布版本内容，这种版本称为发布版本</li></ul></li></ul><p>除了上面的工程版本，我们还经常能看到一些发布版本:</p><ul><li>alpha版:内测版，bug多不稳定内部版本不断添加新功能</li><li>beta版:公测版，不稳定(比alpha稳定些)，bug相对较多不断添加新功能</li><li>纯数字版</li></ul><h3 id="多环境配置与应用"><a href="#多环境配置与应用" class="headerlink" title="多环境配置与应用"></a>多环境配置与应用</h3><h4 id="多环境开发"><a href="#多环境开发" class="headerlink" title="多环境开发"></a>多环境开发</h4><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220925112837.png"></p><ul><li>我们平常都是在自己的开发环境进行开发，</li><li>当开发完成后，需要把开发的功能部署到测试环境供测试人员进行测试使用，</li><li>等测试人员测试通过后，我们会将项目部署到生成环境上线使用。</li><li>这个时候就有一个问题是，不同环境的配置是不相同的，如不可能让三个环境都用一个数据库，所以就会有三个数据库的url配置，</li><li>我们在项目中如何配置?</li><li>要想实现不同环境之间的配置切换又该如何来实现呢?</li></ul><p>maven提供配置多种环境的设定，帮助开发者在使用过程中快速切换环境。具体实现步骤:</p><h4 id="步骤1-父工程配置多个环境-并指定默认激活环境"><a href="#步骤1-父工程配置多个环境-并指定默认激活环境" class="headerlink" title="步骤1:父工程配置多个环境,并指定默认激活环境"></a>步骤1:父工程配置多个环境,并指定默认激活环境</h4><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;profiles&gt;    &lt;!--开发环境--&gt;    &lt;profile&gt;        &lt;id&gt;env_dep&lt;&#x2F;id&gt;        &lt;properties&gt;            &lt;jdbc.url&gt;jdbc:mysql:&#x2F;&#x2F;127.1.1.1:3306&#x2F;ssm_db&lt;&#x2F;jdbc.url&gt;        &lt;&#x2F;properties&gt;        &lt;!--设定是否为默认启动环境--&gt;        &lt;activation&gt;            &lt;activeByDefault&gt;true&lt;&#x2F;activeByDefault&gt;        &lt;&#x2F;activation&gt;    &lt;&#x2F;profile&gt;    &lt;!--生产环境--&gt;    &lt;profile&gt;        &lt;id&gt;env_pro&lt;&#x2F;id&gt;        &lt;properties&gt;            &lt;jdbc.url&gt;jdbc:mysql:&#x2F;&#x2F;127.2.2.2:3306&#x2F;ssm_db&lt;&#x2F;jdbc.url&gt;        &lt;&#x2F;properties&gt;    &lt;&#x2F;profile&gt;    &lt;!--测试环境--&gt;    &lt;profile&gt;        &lt;id&gt;env_test&lt;&#x2F;id&gt;        &lt;properties&gt;            &lt;jdbc.url&gt;jdbc:mysql:&#x2F;&#x2F;127.3.3.3:3306&#x2F;ssm_db&lt;&#x2F;jdbc.url&gt;        &lt;&#x2F;properties&gt;    &lt;&#x2F;profile&gt;&lt;&#x2F;profiles&gt;</code></pre><p><strong>所以总结来说，对于多环境切换只需要两步即可:</strong></p><ul><li><p>父工程中定义多环境</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;profiles&gt;&lt;profile&gt;    &lt;id&gt;环境名称&lt;&#x2F;id&gt;        &lt;properties&gt;        &lt;key&gt;value&lt;&#x2F;key&gt;        &lt;&#x2F;properties&gt;        &lt;activation&gt;        &lt;activeByDefault&gt;true&lt;&#x2F;activeByDefault&gt;        &lt;&#x2F;activation&gt;    &lt;&#x2F;profile&gt;    ...&lt;&#x2F;profiles&gt;</code></pre></li><li><p>使用多环境(构建过程)</p><pre class="line-numbers language-none"><code class="language-none">mvn 指令 -P 环境定义ID[环境定义中获取]</code></pre></li></ul><h4 id="跳过测试"><a href="#跳过测试" class="headerlink" title="跳过测试"></a>跳过测试</h4><ul><li>应用场景<ul><li>功能更新中并且没有开发完毕</li><li>快速打包</li><li>……</li></ul></li></ul><p>前面在执行<code>install</code>指令的时候，Maven都会按照顺序从上往下依次执行，每次都会执行<code>test</code>,</p><p>对于<code>test</code>来说有它存在的意义，</p><ul><li>可以确保每次打包或者安装的时候，程序的正确性，假如测试已经通过在我们没有修改程序的前提下再次执行打包或安装命令，由于顺序执行，测试会被再次执行，就有点耗费时间了。</li><li>功能开发过程中有部分模块还没有开发完毕，测试无法通过，但是想要把其中某一部分进行快速打包，此时由于测试环境失败就会导致打包失败。</li></ul><p>遇到上面这些情况的时候，我们就想跳过测试执行下面的构建命令，具体实现方式有很多：</p><h5 id="方式一-IDEA工具实现跳过测试"><a href="#方式一-IDEA工具实现跳过测试" class="headerlink" title="方式一:IDEA工具实现跳过测试"></a>方式一:IDEA工具实现跳过测试</h5><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220925150619.png"></p><p>图中的按钮为<code>Toggle &#39;Skip Tests&#39; Mode</code>,</p><p>Toggle翻译为切换的意思，也就是说在测试与不测试之间进行切换。</p><p>点击一下，出现测试画横线的图片，如下:</p><p><img src="/../../../BaiduNetdiskDownload/%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B68%E7%AC%94%E8%AE%B0/Maven%E9%AB%98%E7%BA%A7%E7%AC%94%E8%AE%B0/assets/1630985411766.png" alt="1630985411766"></p><p>说明测试已经被关闭，再次点击就会恢复。</p><p>这种方式最简单，但是有点”暴力”，会把所有的测试都跳过，如果我们想更精细的控制哪些跳过哪些不跳过，就需要使用配置插件的方式。</p><h5 id="方式二-配置插件实现跳过测试"><a href="#方式二-配置插件实现跳过测试" class="headerlink" title="方式二:配置插件实现跳过测试"></a>方式二:配置插件实现跳过测试</h5><p>在父工程中的pom.xml中添加测试插件配置</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;artifactId&gt;maven-surefire-plugin&lt;&#x2F;artifactId&gt;            &lt;version&gt;2.12.4&lt;&#x2F;version&gt;            &lt;configuration&gt;                &lt;skipTests&gt;false&lt;&#x2F;skipTests&gt;                &lt;!--排除掉不参与测试的内容--&gt;                &lt;excludes&gt;                    &lt;exclude&gt;**&#x2F;BookServiceTest.java&lt;&#x2F;exclude&gt;                &lt;&#x2F;excludes&gt;            &lt;&#x2F;configuration&gt;        &lt;&#x2F;plugin&gt;    &lt;&#x2F;plugins&gt;&lt;&#x2F;build&gt;</code></pre><p>skipTests:如果为true，则跳过所有测试，如果为false，则不跳过测试</p><p>excludes：哪些测试类不参与测试，即排除，针对skipTests为false来设置的</p><p>includes: 哪些测试类要参与测试，即包含,针对skipTests为true来设置的</p><h5 id="方式三-命令行跳过测试"><a href="#方式三-命令行跳过测试" class="headerlink" title="方式三:命令行跳过测试"></a>方式三:命令行跳过测试</h5><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220925150717.png"></p><p>使用Maven的命令行，<code>mvn 指令 -D skipTests</code></p><p>注意事项:</p><ul><li>执行的项目构建指令必须包含测试生命周期，否则无效果。例如执行compile生命周期，不经过test生命周期。</li><li>该命令可以不借助IDEA，直接使用cmd命令行进行跳过测试，需要注意的是cmd要在pom.xml所在目录下进行执行。</li></ul><h3 id="私服"><a href="#私服" class="headerlink" title="私服"></a>私服</h3><h4 id="私服简介及使用"><a href="#私服简介及使用" class="headerlink" title="私服简介及使用"></a>私服简介及使用</h4><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220926111028.png"></p><ul><li>私服是一台独立的服务器，用于解决团队内部的资源共享与资源同步问题</li></ul><p>搭建Maven私服的方式有很多，我们来介绍其中一种使用量比较大的实现方式:</p><ul><li>Nexus<ul><li>Sonatype公司的一款maven私服产品</li><li>下载地址：<a class="link"   href="https://help.sonatype.com/repomanager3/download" >https://help.sonatype.com/repomanager3/download<i class="fas fa-external-link-alt"></i></a></li></ul></li></ul><p>使用cmd进入到解压目录下的<code>nexus-3.30.1-01\bin</code>,执行如下命令:</p><pre class="line-numbers language-none"><code class="language-none">nexus.exe &#x2F;run nexus</code></pre><p>至此私服就已经安装成功。如果要想修改一些基础配置信息，可以使用:</p><ul><li>修改基础配置信息<ul><li>安装路径下etc目录中nexus-default.properties文件保存有nexus基础配置信息，例如默认访问端口。</li></ul></li><li>修改服务器运行配置信息<ul><li>安装路径下bin目录中nexus.vmoptions文件保存有nexus服务器启动对应的配置信息，例如默认占用内存空间。</li></ul></li></ul><h4 id="私服仓库分类"><a href="#私服仓库分类" class="headerlink" title="私服仓库分类"></a>私服仓库分类</h4><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220927085153.png"></p><h4 id="本地仓库访问私服配置"><a href="#本地仓库访问私服配置" class="headerlink" title="本地仓库访问私服配置"></a>本地仓库访问私服配置</h4><p>步骤1:私服上配置仓库</p><h4 id="步骤2-配置本地Maven对私服的访问权限"><a href="#步骤2-配置本地Maven对私服的访问权限" class="headerlink" title="步骤2:配置本地Maven对私服的访问权限"></a>步骤2:配置本地Maven对私服的访问权限</h4><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;servers&gt;    &lt;server&gt;        &lt;id&gt;itheima-snapshot&lt;&#x2F;id&gt;        &lt;username&gt;admin&lt;&#x2F;username&gt;        &lt;password&gt;admin&lt;&#x2F;password&gt;    &lt;&#x2F;server&gt;    &lt;server&gt;        &lt;id&gt;itheima-release&lt;&#x2F;id&gt;        &lt;username&gt;admin&lt;&#x2F;username&gt;        &lt;password&gt;admin&lt;&#x2F;password&gt;    &lt;&#x2F;server&gt;&lt;&#x2F;servers&gt;</code></pre><h4 id="步骤3-配置私服的访问路径"><a href="#步骤3-配置私服的访问路径" class="headerlink" title="步骤3:配置私服的访问路径"></a>步骤3:配置私服的访问路径</h4><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;mirrors&gt;    &lt;mirror&gt;        &lt;!--配置仓库组的ID--&gt;        &lt;id&gt;maven-public&lt;&#x2F;id&gt;        &lt;!--*代表所有内容都从私服获取--&gt;        &lt;mirrorOf&gt;*&lt;&#x2F;mirrorOf&gt;        &lt;!--私服仓库组maven-public的访问路径--&gt;        &lt;url&gt;http:&#x2F;&#x2F;localhost:8081&#x2F;repository&#x2F;maven-public&#x2F;&lt;&#x2F;url&gt;    &lt;&#x2F;mirror&gt;&lt;&#x2F;mirrors&gt;</code></pre><p><strong>为了避免阿里云Maven私服地址的影响，建议先将之前配置的阿里云Maven私服镜像地址注释掉，等练习完后，再将其恢复。</strong></p><h4 id="资源上传与下载"><a href="#资源上传与下载" class="headerlink" title="资源上传与下载"></a>资源上传与下载</h4><p>本地仓库与私服已经建立了连接，接下来我们就需要往私服上上传资源和下载资源，具体的实现步骤为:</p><h5 id="步骤1-配置工程上传私服的具体位置"><a href="#步骤1-配置工程上传私服的具体位置" class="headerlink" title="步骤1:配置工程上传私服的具体位置"></a>步骤1:配置工程上传私服的具体位置</h5><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"> &lt;!--配置当前工程保存在私服中的具体位置--&gt;&lt;distributionManagement&gt;    &lt;repository&gt;        &lt;!--和maven&#x2F;settings.xml中server中的id一致，表示使用该id对应的用户名和密码--&gt;        &lt;id&gt;itheima-release&lt;&#x2F;id&gt;         &lt;!--release版本上传仓库的具体地址--&gt;        &lt;url&gt;http:&#x2F;&#x2F;localhost:8081&#x2F;repository&#x2F;itheima-release&#x2F;&lt;&#x2F;url&gt;    &lt;&#x2F;repository&gt;    &lt;snapshotRepository&gt;        &lt;!--和maven&#x2F;settings.xml中server中的id一致，表示使用该id对应的用户名和密码--&gt;        &lt;id&gt;itheima-snapshot&lt;&#x2F;id&gt;        &lt;!--snapshot版本上传仓库的具体地址--&gt;        &lt;url&gt;http:&#x2F;&#x2F;localhost:8081&#x2F;repository&#x2F;itheima-snapshot&#x2F;&lt;&#x2F;url&gt;    &lt;&#x2F;snapshotRepository&gt;&lt;&#x2F;distributionManagement&gt;</code></pre><h5 id="步骤2-发布资源到私服"><a href="#步骤2-发布资源到私服" class="headerlink" title="步骤2:发布资源到私服"></a>步骤2:发布资源到私服</h5><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220927164136.png"></p><p>或者执行Maven命令</p><pre class="line-numbers language-none"><code class="language-none">mvn deploy</code></pre><p><strong>注意:</strong></p><p>要发布的项目都需要配置<code>distributionManagement</code>标签，要么在自己的pom.xml中配置，要么在其父项目中配置，然后子项目中继承父项目即可。</p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220927165603.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;Maven是专门用于管理和构建java项目的工具&lt;h1 id=&quot;Maven基础&quot;&gt;&lt;a href=&quot;#Maven基础&quot; class=&quot;headerlink&quot; title=&quot;Maven基础&quot;&gt;&lt;/a&gt;Maven基础&lt;/h1&gt;&lt;h2 id=&quot;Maven的功能&quot;&gt;&lt;a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JDBC总结</title>
    <link href="https://2295237514.github.io/post/JDBC%E6%80%BB%E7%BB%93.html"/>
    <id>https://2295237514.github.io/post/JDBC%E6%80%BB%E7%BB%93.html</id>
    <published>2022-05-07T02:47:07.000Z</published>
    <updated>2022-05-23T15:00:59.686Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDBC快速入门-JDBC-pdf"><a href="#JDBC快速入门-JDBC-pdf" class="headerlink" title="JDBC快速入门(JDBC.pdf)"></a>JDBC快速入门<a target="_blank" href="\doc\JDBC.pdf ">(JDBC.pdf)</h1><h2 id="1、编写代码步骤"><a href="#1、编写代码步骤" class="headerlink" title="1、编写代码步骤"></a>1、编写代码步骤</h2><h3 id="1、创建工程-导入驱动jar包"><a href="#1、创建工程-导入驱动jar包" class="headerlink" title="1、创建工程,导入驱动jar包"></a>1、创建工程,导入驱动jar包</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220507155303.png"></p><p><a target = "_blank" href = "\doc\mysql-connector-java-5.1.48.jar"> <em><strong>jar包</strong></em></p><h3 id="2、注册驱动"><a href="#2、注册驱动" class="headerlink" title="2、注册驱动"></a>2、注册驱动</h3><pre class="line-numbers language-none"><code class="language-none">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code></pre><h3 id="3、获取连接"><a href="#3、获取连接" class="headerlink" title="3、获取连接"></a>3、获取连接</h3><pre class="line-numbers language-none"><code class="language-none">Connection conn &#x3D; DriverMannager.getConnection(url,username,password);</code></pre><h3 id="4、定义SQL语句"><a href="#4、定义SQL语句" class="headerlink" title="4、定义SQL语句"></a>4、定义SQL语句</h3><pre class="line-numbers language-none"><code class="language-none">String sql &#x3D; &quot;&quot;;</code></pre><h3 id="5、获取执行SQL的对象"><a href="#5、获取执行SQL的对象" class="headerlink" title="5、获取执行SQL的对象"></a>5、获取执行SQL的对象</h3><pre class="line-numbers language-none"><code class="language-none">Statement stmt &#x3D; conn.createStatement();</code></pre><h3 id="6、执行SQL语句"><a href="#6、执行SQL语句" class="headerlink" title="6、执行SQL语句"></a>6、执行SQL语句</h3><pre class="line-numbers language-none"><code class="language-none">stmt.executeUpdate(sql);  &#x2F;&#x2F;此方法会执行sql语句并返回受影响的行数。可以用int count &#x3D; stmt.executeUpdate(sql)接受返回值;</code></pre><h3 id="7、处理返回结果"><a href="#7、处理返回结果" class="headerlink" title="7、处理返回结果"></a>7、处理返回结果</h3><h3 id="8、释放资源"><a href="#8、释放资源" class="headerlink" title="8、释放资源"></a>8、释放资源</h3><pre class="line-numbers language-none"><code class="language-none">stmt.close();conn.cloes();</code></pre><h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220507161018.png"></p><h1 id="API详解"><a href="#API详解" class="headerlink" title="API详解"></a>API详解</h1><h2 id="1、DriverManager"><a href="#1、DriverManager" class="headerlink" title="1、DriverManager"></a>1、DriverManager</h2><h3 id="1、注册驱动"><a href="#1、注册驱动" class="headerlink" title="1、注册驱动"></a>1、注册驱动</h3><p>*** MYSQL 5之后的驱动包，可以省略注册驱动的步骤***</p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220507220942.png"></p><p>这个方法可以完成驱动的注册，但是实际开发中一般不会使用这个方法完成驱动的注册</p><p>原因：</p><p>如果需要注册驱动，就会使用，DriverManager.registerDriver(new Driver()); ,但是查看源代码发现，在代码中一段静态代码块，静态代码块已经调用了注册驱动的方法。</p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220507221217.png"></p><p>如果再手动调用该方法注册驱动，就会导致驱动被注册两次。实际开发中一般户次爱用;</p><pre class="line-numbers language-none"><code class="language-none">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code></pre><h3 id="2、获得与数据库的连接"><a href="#2、获得与数据库的连接" class="headerlink" title="2、获得与数据库的连接"></a>2、获得与数据库的连接</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220507221414.png"></p><p>这个方法就是用来获得与数据库连接的方法，这个方法中的三个参数为 与数据库连接的路径(url)，与数据库连接的用户名(user)，与数据库连接的密码(password)。</p><p>主要是url的写法：</p><pre class="line-numbers language-none"><code class="language-none">jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;db1</code></pre><pre class="line-numbers language-none"><code class="language-none">jdbc:mysql:&#x2F;&#x2F;ip地址:端口号&#x2F;数据库名称?参数键值对1&amp;参数键值对2...</code></pre><p>localhost           :连接的MySQL数据库服务器的主机ip地址。（连接是本机就可以写成localhost），如果连接不是本机的，就需要写上连接主机的IP地址。</p><p>url如果连接的是本机的路径，可以简化为如下格式：</p><p>jdbc:mysql:&#x2F;&#x2F;&#x2F;db1</p><p><em><strong>配置useSSL &#x3D; false 参数，禁用安全连接方式，解决警告提示</strong></em></p><h2 id="2、Connection"><a href="#2、Connection" class="headerlink" title="2、Connection"></a>2、Connection</h2><h3 id="1、获取执行SQL对象"><a href="#1、获取执行SQL对象" class="headerlink" title="1、获取执行SQL对象"></a>1、获取执行SQL对象</h3><p>普通执行SQL对象</p><pre class="line-numbers language-none"><code class="language-none">Statement createStatement();</code></pre><p> 预编译SQL的执行SQL对象；防止SQL注入</p><pre class="line-numbers language-none"><code class="language-none">PreparedStatement prepareStatement(sql);</code></pre><p>执行存储过程的对象</p><pre class="line-numbers language-none"><code class="language-none">CallableStatement prepareCall(sql)</code></pre><h3 id="2、事务管理"><a href="#2、事务管理" class="headerlink" title="2、事务管理"></a>2、事务管理</h3><h4 id="MYSQL事务管理"><a href="#MYSQL事务管理" class="headerlink" title="MYSQL事务管理"></a>MYSQL事务管理</h4><pre class="line-numbers language-none"><code class="language-none">开启事务：  begin;&#x2F;start transaction;提交事务：  commit;回滚事务：  rollback;MYSQL默认自动提交事务</code></pre><h4 id="JDBC事务管理"><a href="#JDBC事务管理" class="headerlink" title="JDBC事务管理"></a>JDBC事务管理</h4><p>Connection接口中定义了3个对应的方法</p><pre class="line-numbers language-none"><code class="language-none">开启事务：setAutoCommit(bollean autoCommit): true为自动提交事务；false为手动提交事务，即为开启事务提交事务：commit()回滚事务：rollback()</code></pre><p>例：</p><pre class="line-numbers language-none"><code class="language-none">package com.itheima.jdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;&#x2F;** * JDBC API 详解：Connection *&#x2F;public class JDBCDemo3_Connection &#123;    public static void main(String[] args) throws Exception &#123;        &#x2F;&#x2F;1. 注册驱动        &#x2F;&#x2F;Class.forName(&quot;com.mysql.jdbc.Driver&quot;);        &#x2F;&#x2F;2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写        String url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;db1?useSSL&#x3D;false&quot;;        String username &#x3D; &quot;root&quot;;        String password &#x3D; &quot;1234&quot;;        Connection conn &#x3D; DriverManager.getConnection(url, username, password);        &#x2F;&#x2F;3. 定义sql        String sql1 &#x3D; &quot;update account set money &#x3D; 3000 where id &#x3D; 1&quot;;        String sql2 &#x3D; &quot;update account set money &#x3D; 3000 where id &#x3D; 2&quot;;        &#x2F;&#x2F;4. 获取执行sql的对象 Statement        Statement stmt &#x3D; conn.createStatement();        try &#123;            &#x2F;&#x2F; 开启事务            conn.setAutoCommit(false);            &#x2F;&#x2F;5. 执行sql            int count1 &#x3D; stmt.executeUpdate(sql1);&#x2F;&#x2F;受影响的行数            &#x2F;&#x2F;6. 处理结果            System.out.println(count1);            int i &#x3D; 3&#x2F;0;            &#x2F;&#x2F;5. 执行sql            int count2 &#x3D; stmt.executeUpdate(sql2);&#x2F;&#x2F;受影响的行数            &#x2F;&#x2F;6. 处理结果            System.out.println(count2);            &#x2F;&#x2F; 提交事务            conn.commit();        &#125; catch (Exception throwables) &#123;            &#x2F;&#x2F; 回滚事务            conn.rollback();            throwables.printStackTrace();        &#125;        &#x2F;&#x2F;7. 释放资源        stmt.close();        conn.close();    &#125;&#125;</code></pre><h2 id="3、Statement"><a href="#3、Statement" class="headerlink" title="3、Statement"></a>3、Statement</h2><h3 id="1、执行SQL语句"><a href="#1、执行SQL语句" class="headerlink" title="1、执行SQL语句"></a>1、执行SQL语句</h3><pre class="line-numbers language-none"><code class="language-none">int executeUpdate(sql):执行DML、DDL语句返回值（1）DML语句影响的行数（2）DDL语句执行后，执行成功也可能返回0</code></pre><pre class="line-numbers language-none"><code class="language-none">ResultSet executeQuery(sql):执行DQL语句返回值：Result结果集对象</code></pre><h2 id="4、ResultSet"><a href="#4、ResultSet" class="headerlink" title="4、ResultSet"></a>4、ResultSet</h2><h3 id="封装了DQL查询语句的结果"><a href="#封装了DQL查询语句的结果" class="headerlink" title="封装了DQL查询语句的结果"></a>封装了DQL查询语句的结果</h3><pre class="line-numbers language-none"><code class="language-none">ResultSet stmt.executeQuery(sql); 执行DQL语句，返回ResultSet对象</code></pre><h3 id="获取查询结果"><a href="#获取查询结果" class="headerlink" title="获取查询结果"></a>获取查询结果</h3><pre class="line-numbers language-none"><code class="language-none">boolean next(): (1)将光标从当前位置向前移动一行 (2)判断当前行是否为有效行返回值 true：有效行，当前行有数据   false：无效行，当前行没有数据</code></pre><pre class="line-numbers language-none"><code class="language-none">xxx getXxx(参数):获取数据xxx：数据类型，如 ： int getInt(参数) String getString(参数)参数：int： 列的编号，从1开始 string：列的名称</code></pre><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><p>1、游标向下移动一行，并判断该行是否有数据：next()</p><p>2 、获取数据：getXxx(参数)</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;循环判断游标是否是最后一行末尾while(rs.next())&#123;&#x2F;&#x2F;获取数据rs.getXxx(参数);&#125;</code></pre><h2 id="5、PreparedStatement"><a href="#5、PreparedStatement" class="headerlink" title="5、PreparedStatement"></a>5、PreparedStatement</h2><h3 id="作用：预编译SQL语句并执行，防止SQL注入问题"><a href="#作用：预编译SQL语句并执行，防止SQL注入问题" class="headerlink" title="作用：预编译SQL语句并执行，防止SQL注入问题"></a>作用：预编译SQL语句并执行，防止SQL注入问题</h3><p>如：用户名随便写，密码写成’ or ‘ 1 ‘ &#x3D; ‘1</p><h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><h4 id="1、获取PreparedStatement对象"><a href="#1、获取PreparedStatement对象" class="headerlink" title="1、获取PreparedStatement对象"></a>1、获取PreparedStatement对象</h4><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;SQL语句中的参数值，使用？占位符替代String sql &#x3D; &quot;select * from user where username &#x3D; ? and password &#x3D; ？&quot;;&#x2F;&#x2F;通过Connection对象获取，并传入对应的SQL语句PreparedStatement pstmt &#x3D; conn.prepareStatement(sql);</code></pre><h4 id="2、设置参数值"><a href="#2、设置参数值" class="headerlink" title="2、设置参数值"></a>2、设置参数值</h4><pre class="line-numbers language-none"><code class="language-none">PreparedStatement对象:setXxx(参数1,参数2):给？赋值Xxx:数据类型，如setInt(参数1,参数2)参数：参数1：？的位置编号，从1开始参数2：？的值</code></pre><h4 id="3、执行SQL"><a href="#3、执行SQL" class="headerlink" title="3、执行SQL"></a>3、执行SQL</h4><pre class="line-numbers language-none"><code class="language-none">executeUpdate();&#x2F;executeQuery(); :不需要再传递sql</code></pre><h4 id="例-1"><a href="#例-1" class="headerlink" title="例"></a>例</h4><pre class="line-numbers language-none"><code class="language-none">public class JDBCDemo7_PreparedStatement &#123;    @Test    public void testPreparedStatement() throws  Exception &#123;       &#x2F;&#x2F;2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写       String url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;db1?useSSL&#x3D;false&quot;;       String username &#x3D; &quot;root&quot;;       String password &#x3D; &quot;1234&quot;;       Connection conn &#x3D; DriverManager.getConnection(url, username, password);       &#x2F;&#x2F; 接收用户输入 用户名和密码        String name &#x3D; &quot;zhangsan&quot;;        String pwd &#x3D; &quot;&#39; or &#39;1&#39; &#x3D; &#39;1&quot;;        &#x2F;&#x2F; 定义sql        String sql &#x3D; &quot;select * from tb_user where username &#x3D; ? and password &#x3D; ?&quot;;        &#x2F;&#x2F; 获取pstmt对象        PreparedStatement pstmt &#x3D; conn.prepareStatement(sql);        &#x2F;&#x2F; 设置？的值        pstmt.setString(1,name);        pstmt.setString(2,pwd);        &#x2F;&#x2F; 执行sql        ResultSet rs &#x3D; pstmt.executeQuery();        &#x2F;&#x2F; 判断登录是否成功        if(rs.next())&#123;            System.out.println(&quot;登录成功~&quot;);        &#125;else&#123;            System.out.println(&quot;登录失败~&quot;);        &#125;        &#x2F;&#x2F;7. 释放资源        rs.close();        pstmt.close();        conn.close();    &#125;</code></pre><h3 id="好处："><a href="#好处：" class="headerlink" title="好处："></a>好处：</h3><p>1、预编译SQL，性能更高</p><p>2、防止SQL注入，将敏感字符进行转义</p><p>PreparedStatement预编译功能开启：useServerPrepStmts&#x3D;true</p><p>（参数键值对）应加在URL最后</p><p>配置MySQL执行日志（重启mysql服务后生效）</p><pre class="line-numbers language-none"><code class="language-none">log-output&#x3D;FILEgeneral-log&#x3D;1general_log_file&#x3D;&quot;D:\mysql.log&quot;slow-query-log&#x3D;1slow_query_log_file&#x3D;&quot;D:\mysql_slow.log&quot;long_query_time&#x3D;2</code></pre><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>1、在获取PreparedStatement对象时，将sql语句发送给mysql服务器进行检查，编译（这些步骤很耗时）</p><p>2、执行时就不用再进行这些步骤了，速度更快</p><p>3、如果sql模板一样，则只需要进行一次检查编译</p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220513112641.png"></p><h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><p>数据库连接池是个容器，负责分配，，管理数据库连接</p></li><li><p>它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个</p></li><li><p>释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏</p></li><li><p>好处：</p><ul><li><p>资源重用</p></li><li><p>提升系统响应速度</p></li><li><p>避免数据库连接遗漏</p></li></ul></li></ul><h2 id="数据库连接池实现"><a href="#数据库连接池实现" class="headerlink" title="数据库连接池实现"></a>数据库连接池实现</h2><h3 id="标准接口"><a href="#标准接口" class="headerlink" title="标准接口"></a>标准接口</h3><ul><li>官方（SUN）提供的数据库连接池标准接口，由第三方组织实现此接口。</li><li>功能：获取连接</li></ul><pre class="line-numbers language-none"><code class="language-none">Connection getConnection()</code></pre><h3 id="常见的数据库连接池："><a href="#常见的数据库连接池：" class="headerlink" title="常见的数据库连接池："></a>常见的数据库连接池：</h3><ul><li>DBCP</li><li>C3P0</li><li>Druid</li></ul><h3 id="Druid（德鲁伊）"><a href="#Druid（德鲁伊）" class="headerlink" title="Druid（德鲁伊）"></a>Druid（德鲁伊）</h3><ul><li>Druid连接池是阿里巴巴开源的数据库连接池项目</li><li>功能强大，性能优秀，是Java语言最好的数据库连接池之一</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JDBC快速入门-JDBC-pdf&quot;&gt;&lt;a href=&quot;#JDBC快速入门-JDBC-pdf&quot; class=&quot;headerlink&quot; title=&quot;JDBC快速入门	(JDBC.pdf)&quot;&gt;&lt;/a&gt;JDBC快速入门	&lt;a target=&quot;_blank&quot; href=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>SQL总结</title>
    <link href="https://2295237514.github.io/post/SQL%E6%80%BB%E7%BB%93.html"/>
    <id>https://2295237514.github.io/post/SQL%E6%80%BB%E7%BB%93.html</id>
    <published>2022-04-30T08:59:10.000Z</published>
    <updated>2022-07-31T08:07:41.034Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL通用语法"><a href="#SQL通用语法" class="headerlink" title="SQL通用语法"></a>SQL通用语法</h1><p>1.SQL语句可以单行或多行书写，以分号结尾。</p><p>2.MYSQL数据库的SQL语句不区分大小写，关键字建议适用大写。</p><p>3.注释</p><p> （1） 单行注释：– 注释内容（<em><strong>两个横杠一个空格+注释内容</strong></em>） 或 #注释内容（MYSQL特有)</p><p>（2） 多行注释： &#x2F;* 注释 *&#x2F;</p><h1 id="对-MYSQL-的-windows命令"><a href="#对-MYSQL-的-windows命令" class="headerlink" title="对 MYSQL 的 windows命令"></a>对 MYSQL 的 windows命令</h1><h3 id="1、启动mysql服务"><a href="#1、启动mysql服务" class="headerlink" title="1、启动mysql服务"></a>1、启动mysql服务</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">net start mysql 启动 mysql 服务net stop mysql 关闭 mysql 服务</code></pre><h3 id="2、进入mysql，输入密码："><a href="#2、进入mysql，输入密码：" class="headerlink" title="2、进入mysql，输入密码："></a>2、进入mysql，输入密码：</h3><pre class="line-numbers language-none"><code class="language-none">mysql -hlocalhost -uroot -proot 进入mysql数据库，其中-h表示服务器名，localhost表示本地；-u为数据库用户名，root是mysql默认用户名；-p为密码，如果设置了密码，可直接在-p后直接输入。mysql -u root -p;</code></pre><h1 id="对数据库的操作"><a href="#对数据库的操作" class="headerlink" title="对数据库的操作"></a>对数据库的操作</h1><h3 id="1、查看所有数据库"><a href="#1、查看所有数据库" class="headerlink" title="1、查看所有数据库"></a>1、查看所有数据库</h3><pre class="line-numbers language-none"><code class="language-none">mysql&gt; show databases;</code></pre><h3 id="2、创建数据库"><a href="#2、创建数据库" class="headerlink" title="2、创建数据库"></a>2、创建数据库</h3><pre class="line-numbers language-none"><code class="language-none">mysql&gt; create database 数据库名称如果数据库已经存在，则会报错可使用mysql&gt; create database if not exists; 数据库名称</code></pre><h3 id="3、删除数据库"><a href="#3、删除数据库" class="headerlink" title="3、删除数据库"></a>3、删除数据库</h3><pre class="line-numbers language-none"><code class="language-none">drop database 数据库名称;drop database if exists 数据库名称;</code></pre><h3 id="4、使用数据库"><a href="#4、使用数据库" class="headerlink" title="4、使用数据库"></a>4、使用数据库</h3><pre class="line-numbers language-none"><code class="language-none">使用数据库 use 数据库名称;</code></pre><h3 id="5、查看当前使用的数据库"><a href="#5、查看当前使用的数据库" class="headerlink" title="5、查看当前使用的数据库"></a>5、查看当前使用的数据库</h3><pre class="line-numbers language-none"><code class="language-none">select database();</code></pre><h1 id="对表的操作"><a href="#对表的操作" class="headerlink" title="对表的操作"></a>对表的操作</h1><p>· 创建（create）</p><p>·查询（retrieve）</p><p>·修改（update）</p><p>·删除（delete）</p><h2 id="1、创建（create）"><a href="#1、创建（create）" class="headerlink" title="1、创建（create）"></a>1、创建（create）</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><pre class="line-numbers language-none"><code class="language-none">create table 表名(字段名1 数据类型1,字段名2 数据类型2,...字段名n 数据类型n);</code></pre><p><em><strong>最后一行末尾不能加逗号</strong></em></p><h2 id="2、查询（retrieve）"><a href="#2、查询（retrieve）" class="headerlink" title="2、查询（retrieve）"></a>2、查询（retrieve）</h2><h3 id="查询当前数据库下所有表名称"><a href="#查询当前数据库下所有表名称" class="headerlink" title="查询当前数据库下所有表名称"></a>查询当前数据库下所有表名称</h3><pre class="line-numbers language-none"><code class="language-none">show tables;</code></pre><h3 id="查询表结构"><a href="#查询表结构" class="headerlink" title="查询表结构"></a>查询表结构</h3><pre class="line-numbers language-none"><code class="language-none">desc 表名称;</code></pre><h2 id="3、修改（update）"><a href="#3、修改（update）" class="headerlink" title="3、修改（update）"></a>3、修改（update）</h2><h3 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h3><pre class="line-numbers language-none"><code class="language-none">alter table 表名 rename to 新的表名;</code></pre><h3 id="添加一列"><a href="#添加一列" class="headerlink" title="添加一列"></a>添加一列</h3><pre class="line-numbers language-none"><code class="language-none">alter table 表名 add 列名 数据类型;</code></pre><h3 id="修改数据类型"><a href="#修改数据类型" class="headerlink" title="修改数据类型"></a>修改数据类型</h3><pre class="line-numbers language-none"><code class="language-none">alter table 表名 modify 列名 新数据类型;</code></pre><h3 id="修改列名和数据类型"><a href="#修改列名和数据类型" class="headerlink" title="修改列名和数据类型"></a>修改列名和数据类型</h3><pre class="line-numbers language-none"><code class="language-none">alter table 表名 change 列名 新列名 新数据类型;</code></pre><h3 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h3><pre class="line-numbers language-none"><code class="language-none">alter table 表名 drop 列名;</code></pre><h2 id="4、删除（delete）"><a href="#4、删除（delete）" class="headerlink" title="4、删除（delete）"></a>4、删除（delete）</h2><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><pre class="line-numbers language-none"><code class="language-none">drop table 表名;drop table if exists 表名;</code></pre><h1 id="对数据的操作"><a href="#对数据的操作" class="headerlink" title="对数据的操作"></a>对数据的操作</h1><h2 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h2><h3 id="1、给指定列添加数据"><a href="#1、给指定列添加数据" class="headerlink" title="1、给指定列添加数据"></a>1、给指定列添加数据</h3><pre class="line-numbers language-none"><code class="language-none">insert into 表名(列名1,列名2，...)values(值1,值2,...); </code></pre><h3 id="2、给全部列添加数据"><a href="#2、给全部列添加数据" class="headerlink" title="2、给全部列添加数据"></a>2、给全部列添加数据</h3><pre class="line-numbers language-none"><code class="language-none">insert into 表名 values(值1,值2,...);</code></pre><h3 id="3、批量添加数据"><a href="#3、批量添加数据" class="headerlink" title="3、批量添加数据"></a>3、批量添加数据</h3><pre class="line-numbers language-none"><code class="language-none">insert into 表名(列名1,列名2,...) values(值1,值2,...),(值1,值2,...),(值1,值2,...)...;insert into 表名 values(值1,值2,...),(值1,值2,...),(值1,值2,...)...;</code></pre><h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><h3 id="1、修改表数据"><a href="#1、修改表数据" class="headerlink" title="1、修改表数据"></a>1、修改表数据</h3><pre class="line-numbers language-none"><code class="language-none">update 表名 set 列名1&#x3D;值1,列名2&#x3D;值2,...[where 条件];</code></pre><p><em><strong>修改语句如果不加条件，则所有数据都将被修改!</strong></em></p><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><h3 id="1、删除数据"><a href="#1、删除数据" class="headerlink" title="1、删除数据"></a>1、删除数据</h3><pre class="line-numbers language-none"><code class="language-none">delete from 表名 [where 条件];</code></pre><p><em><strong>删除语句如果不加条件，则所有数据都将被删除</strong></em></p><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><pre class="line-numbers language-none"><code class="language-none">select字段列表from表名列表where条件列表group by分组字段having分组后条件order by排序字段limit分页限定</code></pre><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220504212604.png"></p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220504212646.png"></p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220504213436.png"></p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220504214112.png"></p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220505150558.png"></p><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220505173339.png"> </p><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220505174727.png"></p><h1 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h1><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220505181909.png"></p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220505182737.png"></p><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220505182947.png"></p><h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><pre class="line-numbers language-none"><code class="language-none">隐式内连接select 字段列表 from 表1,表2... where 条件;显式内连接select 字段列表 from 表1 [inner] join 表2 on 条件；</code></pre><p>内连接相当于查询A B 交集数据</p><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><pre class="line-numbers language-none"><code class="language-none">左外连接select 字段列表 from 表1 left [outer] join 表2 on 条件；右外连接select 字段列表 from 表1 right [outer] join 表2 on 条件；</code></pre><p>左外连接 ：相当于查询A表所有数据和交集部分数据</p><p>右外连接 ：相当于查询B表所有数据和交集部分数据</p><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>子查询根据查询结果不同，作用不同;<br>1、单行单列:作为条件值，使用&#x3D;,!&#x3D;,&gt;,&lt;等进行条件判断</p><pre class="line-numbers language-none"><code class="language-none">select 字段列表 from 表 where 字段名 &#x3D; (子查询)；</code></pre><p>2、多行单列:作为条件值，使用in等关键字进行条件判断</p><pre class="line-numbers language-none"><code class="language-none">select 字段列表 from 表 where 字段名 in (子查询)；</code></pre><p> 3、多行duolie:作为虚拟表</p><pre class="line-numbers language-none"><code class="language-none">select 字段列表 from (子查询) where 条件；</code></pre><h1 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h1><h3 id="1、开启事务"><a href="#1、开启事务" class="headerlink" title="1、开启事务"></a>1、开启事务</h3><pre class="line-numbers language-none"><code class="language-none">start transaction; 或者 begin;</code></pre><h3 id="2、提交事务"><a href="#2、提交事务" class="headerlink" title="2、提交事务"></a>2、提交事务</h3><pre class="line-numbers language-none"><code class="language-none">commit;</code></pre><h3 id="3、回滚事务"><a href="#3、回滚事务" class="headerlink" title="3、回滚事务"></a>3、回滚事务</h3><pre class="line-numbers language-none"><code class="language-none">rollback;</code></pre><h3 id="4、事务的特性"><a href="#4、事务的特性" class="headerlink" title="4、事务的特性"></a>4、事务的特性</h3><p><img src="https://raw.githubusercontent.com/2295237514/image/main/20220507102843.png"></p><h3 id="5-事务提交"><a href="#5-事务提交" class="headerlink" title="5.事务提交"></a>5.事务提交</h3><p>mysql事务默认自动提交</p><pre class="line-numbers language-none"><code class="language-none">-- 查看事物的默认提交方式select @@autocommit;-- 1 自动提交 0 手动提交-- 修改事务提交方式set @@autocommit &#x3D; 0;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SQL通用语法&quot;&gt;&lt;a href=&quot;#SQL通用语法&quot; class=&quot;headerlink&quot; title=&quot;SQL通用语法&quot;&gt;&lt;/a&gt;SQL通用语法&lt;/h1&gt;&lt;p&gt;1.SQL语句可以单行或多行书写，以分号结尾。&lt;/p&gt;
&lt;p&gt;2.MYSQL数据库的SQL语句不区分</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java核心技术卷总结</title>
    <link href="https://2295237514.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E6%80%BB%E7%BB%93.html"/>
    <id>https://2295237514.github.io/post/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E6%80%BB%E7%BB%93.html</id>
    <published>2022-04-25T11:48:12.000Z</published>
    <updated>2022-05-02T14:54:29.544Z</updated>
    
    <content type="html"><![CDATA[<p>1.&amp;&amp;和|| 运算符是按照“短路”方式来求值的：如果第一个操作数已经能够确定表达式的值，第二个操作数就不必计算了。<br>2.位移运算符的右操作数要完成模32的运算（除非左操作数是long类型，在这种情况下需要对右操作数模64）。例如，1&lt;&lt;35的值等同于1&lt;&lt;3或8。<br>3.同一个级别的运算符按照从左到右的次序进行计算（但右结合运算符除外）&amp;&amp; 优先级大于 | | 。<br>4.String类的substring方法可以从一个较大的字符串提取出一个子串。例如：<br>    String greeting &#x3D; “Hello”;<br>            String a &#x3D; greeting.substring(0,3);<br>    打印 a 会输出    Hel。<br>    即输出[a,b)。<br>5.检测字符串是否相等<br>string a &#x3D; “ok”;<br>string b &#x3D; “ok”;<br>a.equals(b)；<br>“ok”.equals(“ok”);<br>“ok”.equals(“b”);<br>想要检测两个字符串是否相等，而不区分大小写，可用equalsIgnoreCase方法。<br>“Hello”. equalsIgnoreCase(“hello”);<br>6.一定不要使用&#x3D;&#x3D;来检测两个字符串是否相等!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!<br> &#x3D;&#x3D;只能够确定两个字符串是否存放在同一位置上。当然，如果存放在同一位置上，它们必然相等。<br>但是，完全有可能将内容相同的多个字符串副本放置在不同位置上。<br>如果虚拟机始终将相同的字符串共享，就可以使用&#x3D;&#x3D;运算符检测是否相等。但实际上只有字符串字面量是共享的，而+或substring等操作得到的字符串并不共享。<br>因此，千万不要视同&#x3D;&#x3D;运算符测试字符串的相等性！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！<br>7.检查一个字符串既不是null也不是空串 if(str!&#x3D;null &amp;&amp; str.length()!&#x3D;0)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.&amp;amp;&amp;amp;和|| 运算符是按照“短路”方式来求值的：如果第一个操作数已经能够确定表达式的值，第二个操作数就不必计算了。&lt;br&gt;2.位移运算符的右操作数要完成模32的运算（除非左操作数是long类型，在这种情况下需要对右操作数模64）。例如，1&amp;lt;&amp;lt;3</summary>
      
    
    
    
    
  </entry>
  
</feed>
